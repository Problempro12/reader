# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template client.py.jinja --
import warnings
import logging
from datetime import timedelta
from pathlib import Path
from types import TracebackType
from typing_extensions import override

from pydantic import BaseModel

from . import types, models, errors, actions
from ._base_client import BasePrisma, UseClientDefault, USE_CLIENT_DEFAULT
from .types import DatasourceOverride, HttpConfig, MetricsFormat
from ._types import BaseModelT, PrismaMethod, TransactionId, Datasource
from .bases import _PrismaModel
from ._builder import QueryBuilder, dumps
from .generator.models import EngineType, OptionalValueFromEnvVar, BinaryPaths
from ._compat import removeprefix, model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED, DEFAULT_CONNECT_TIMEOUT, DEFAULT_TX_MAX_WAIT, DEFAULT_TX_TIMEOUT
from ._raw_query import deserialize_raw_results
from ._metrics import Metrics
from .metadata import PRISMA_MODELS, RELATIONAL_FIELD_MAPPINGS
from ._transactions import AsyncTransactionManager, SyncTransactionManager

# re-exports
from ._base_client import SyncBasePrisma, AsyncBasePrisma, load_env as load_env
from ._registry import (
    register as register,
    get_client as get_client,
    RegisteredClient as RegisteredClient,
)


__all__ = (
    'ENGINE_TYPE',
    'SCHEMA_PATH',
    'BINARY_PATHS',
    'Batch',
    'Prisma',
    'Client',
    'load_env',
    'register',
    'get_client',
)

log: logging.Logger = logging.getLogger(__name__)

SCHEMA_PATH = Path('/Users/aleksandrkocergin/Documents/kpit.pw/reader/backend/prisma/schema.prisma')
PACKAGED_SCHEMA_PATH = Path(__file__).parent.joinpath('schema.prisma')
ENGINE_TYPE: EngineType = EngineType.binary
BINARY_PATHS = model_parse(BinaryPaths, {'queryEngine': {'darwin-arm64': '/Users/aleksandrkocergin/.npm/_npx/55ad0b431757dc30/node_modules/prisma/query-engine-darwin-arm64'}, 'introspectionEngine': {}, 'migrationEngine': {}, 'libqueryEngine': {}, 'prismaFmt': {}})


class Prisma(AsyncBasePrisma):
    # Note: these property names can be customised using `/// @Python(instance_name: '...')`
    # https://prisma-client-py.readthedocs.io/en/stable/reference/schema-extensions/#instance_name
    user: 'actions.UserActions[models.User]'
    genre: 'actions.GenreActions[models.Genre]'
    agecategory: 'actions.AgeCategoryActions[models.AgeCategory]'
    book: 'actions.BookActions[models.Book]'
    userbook: 'actions.UserBookActions[models.UserBook]'
    vote: 'actions.VoteActions[models.Vote]'
    readingprogress: 'actions.ReadingProgressActions[models.ReadingProgress]'
    weeklyresult: 'actions.WeeklyResultActions[models.WeeklyResult]'
    notification: 'actions.NotificationActions[models.Notification]'
    advertisement: 'actions.AdvertisementActions[models.Advertisement]'
    partner: 'actions.PartnerActions[models.Partner]'
    achievement: 'actions.AchievementActions[models.Achievement]'
    userachievement: 'actions.UserAchievementActions[models.UserAchievement]'
    auth_group: 'actions.auth_groupActions[models.auth_group]'
    auth_group_permissions: 'actions.auth_group_permissionsActions[models.auth_group_permissions]'
    auth_permission: 'actions.auth_permissionActions[models.auth_permission]'
    authtoken_token: 'actions.authtoken_tokenActions[models.authtoken_token]'
    books_agecategory: 'actions.books_agecategoryActions[models.books_agecategory]'
    books_book: 'actions.books_bookActions[models.books_book]'
    books_genre: 'actions.books_genreActions[models.books_genre]'
    django_admin_log: 'actions.django_admin_logActions[models.django_admin_log]'
    django_content_type: 'actions.django_content_typeActions[models.django_content_type]'
    django_migrations: 'actions.django_migrationsActions[models.django_migrations]'
    django_session: 'actions.django_sessionActions[models.django_session]'
    token_blacklist_blacklistedtoken: 'actions.token_blacklist_blacklistedtokenActions[models.token_blacklist_blacklistedtoken]'
    token_blacklist_outstandingtoken: 'actions.token_blacklist_outstandingtokenActions[models.token_blacklist_outstandingtoken]'
    users_user: 'actions.users_userActions[models.users_user]'
    users_user_groups: 'actions.users_user_groupsActions[models.users_user_groups]'
    users_user_user_permissions: 'actions.users_user_user_permissionsActions[models.users_user_user_permissions]'

    __slots__ = (
        'user',
        'genre',
        'agecategory',
        'book',
        'userbook',
        'vote',
        'readingprogress',
        'weeklyresult',
        'notification',
        'advertisement',
        'partner',
        'achievement',
        'userachievement',
        'auth_group',
        'auth_group_permissions',
        'auth_permission',
        'authtoken_token',
        'books_agecategory',
        'books_book',
        'books_genre',
        'django_admin_log',
        'django_content_type',
        'django_migrations',
        'django_session',
        'token_blacklist_blacklistedtoken',
        'token_blacklist_outstandingtoken',
        'users_user',
        'users_user_groups',
        'users_user_user_permissions',
    )

    def __init__(
        self,
        *,
        use_dotenv: bool = True,
        log_queries: bool = False,
        auto_register: bool = False,
        datasource: DatasourceOverride | None = None,
        connect_timeout: int | timedelta = DEFAULT_CONNECT_TIMEOUT,
        http: HttpConfig | None = None,
    ) -> None:
        super().__init__(
            http=http,
            use_dotenv=use_dotenv,
            log_queries=log_queries,
            datasource=datasource,
            connect_timeout=connect_timeout,
        )
        self._set_generated_properties(
            schema_path=SCHEMA_PATH,
            engine_type=ENGINE_TYPE,
            prisma_models=PRISMA_MODELS,
            packaged_schema_path=PACKAGED_SCHEMA_PATH,
            relational_field_mappings=RELATIONAL_FIELD_MAPPINGS,
            preview_features=set([]),
            active_provider='postgresql',
            default_datasource_name='db',
        )

        self.user = actions.UserActions[models.User](self, models.User)
        self.genre = actions.GenreActions[models.Genre](self, models.Genre)
        self.agecategory = actions.AgeCategoryActions[models.AgeCategory](self, models.AgeCategory)
        self.book = actions.BookActions[models.Book](self, models.Book)
        self.userbook = actions.UserBookActions[models.UserBook](self, models.UserBook)
        self.vote = actions.VoteActions[models.Vote](self, models.Vote)
        self.readingprogress = actions.ReadingProgressActions[models.ReadingProgress](self, models.ReadingProgress)
        self.weeklyresult = actions.WeeklyResultActions[models.WeeklyResult](self, models.WeeklyResult)
        self.notification = actions.NotificationActions[models.Notification](self, models.Notification)
        self.advertisement = actions.AdvertisementActions[models.Advertisement](self, models.Advertisement)
        self.partner = actions.PartnerActions[models.Partner](self, models.Partner)
        self.achievement = actions.AchievementActions[models.Achievement](self, models.Achievement)
        self.userachievement = actions.UserAchievementActions[models.UserAchievement](self, models.UserAchievement)
        self.auth_group = actions.auth_groupActions[models.auth_group](self, models.auth_group)
        self.auth_group_permissions = actions.auth_group_permissionsActions[models.auth_group_permissions](self, models.auth_group_permissions)
        self.auth_permission = actions.auth_permissionActions[models.auth_permission](self, models.auth_permission)
        self.authtoken_token = actions.authtoken_tokenActions[models.authtoken_token](self, models.authtoken_token)
        self.books_agecategory = actions.books_agecategoryActions[models.books_agecategory](self, models.books_agecategory)
        self.books_book = actions.books_bookActions[models.books_book](self, models.books_book)
        self.books_genre = actions.books_genreActions[models.books_genre](self, models.books_genre)
        self.django_admin_log = actions.django_admin_logActions[models.django_admin_log](self, models.django_admin_log)
        self.django_content_type = actions.django_content_typeActions[models.django_content_type](self, models.django_content_type)
        self.django_migrations = actions.django_migrationsActions[models.django_migrations](self, models.django_migrations)
        self.django_session = actions.django_sessionActions[models.django_session](self, models.django_session)
        self.token_blacklist_blacklistedtoken = actions.token_blacklist_blacklistedtokenActions[models.token_blacklist_blacklistedtoken](self, models.token_blacklist_blacklistedtoken)
        self.token_blacklist_outstandingtoken = actions.token_blacklist_outstandingtokenActions[models.token_blacklist_outstandingtoken](self, models.token_blacklist_outstandingtoken)
        self.users_user = actions.users_userActions[models.users_user](self, models.users_user)
        self.users_user_groups = actions.users_user_groupsActions[models.users_user_groups](self, models.users_user_groups)
        self.users_user_user_permissions = actions.users_user_user_permissionsActions[models.users_user_user_permissions](self, models.users_user_user_permissions)

        if auto_register:
            register(self)

    @property
    @override
    def _default_datasource(self) -> Datasource:
        return {
            'name': 'db',
            'url': OptionalValueFromEnvVar(**{'value': None, 'fromEnvVar': 'DATABASE_URL'}).resolve(),
            'source_file_path': '/Users/aleksandrkocergin/Documents/kpit.pw/reader/backend/prisma/schema.prisma',
        }

    async def execute_raw(self, query: LiteralString, *args: Any) -> int:
        resp = await self._execute(
            method='execute_raw',
            arguments={
                'query': query,
                'parameters': args,
            },
            model=None,
        )
        return int(resp['data']['result'])

    @overload
    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> dict[str, Any]:
        ...

    @overload
    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
        model: Type[BaseModelT],
    ) -> Optional[BaseModelT]:
        ...

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
        model: Optional[Type[BaseModelT]] = None,
    ) -> Union[Optional[BaseModelT], dict[str, Any]]:
        """This function is the exact same as `query_raw()` but returns the first result.

        If model is given, the returned record is converted to the pydantic model first,
        otherwise a raw dictionary will be returned.
        """
        results: Sequence[Union[BaseModelT, dict[str, Any]]]
        if model is not None:
            results = await self.query_raw(query, *args, model=model)
        else:
            results = await self.query_raw(query, *args)

        if not results:
            return None

        return results[0]

    @overload
    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[dict[str, Any]]:
        ...

    @overload
    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
        model: Type[BaseModelT],
    ) -> List[BaseModelT]:
        ...

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
        model: Optional[Type[BaseModelT]] = None,
    ) -> Union[List[BaseModelT], List[dict[str, Any]]]:
        """Execute a raw SQL query against the database.

        If model is given, each returned record is converted to the pydantic model first,
        otherwise results will be raw dictionaries.
        """
        resp = await self._execute(
            method='query_raw',
            arguments={
                'query': query,
                'parameters': args,
            },
            model=model,
        )
        result = resp['data']['result']
        if model is not None:
            return deserialize_raw_results(result, model=model)

        return deserialize_raw_results(result)

    def batch_(self) -> Batch:
        """Returns a context manager for grouping write queries into a single transaction."""
        return Batch(client=self)

    def tx(
        self,
        *,
        max_wait: Union[int, timedelta] = DEFAULT_TX_MAX_WAIT,
        timeout: Union[int, timedelta] = DEFAULT_TX_TIMEOUT,
    ) -> TransactionManager:
        """Returns a context manager for executing queries within a database transaction.

        Entering the context manager returns a new Prisma instance wrapping all
        actions within a transaction, queries will be isolated to the Prisma instance and
        will not be commited to the database until the context manager exits.

        By default, Prisma will wait a maximum of 2 seconds to acquire a transaction from the database. You can modify this
        default with the `max_wait` argument which accepts a value in milliseconds or `datetime.timedelta`.

        By default, Prisma will cancel and rollback ay transactions that last longer than 5 seconds. You can modify this timeout
        with the `timeout` argument which accepts a value in milliseconds or `datetime.timedelta`.

        Example usage:

        ```py
        async with client.tx() as transaction:
            user1 = await client.user.create({'name': 'Robert'})
            user2 = await client.user.create({'name': 'Tegan'})
        ```

        In the above example, if the first database call succeeds but the second does not then neither of the records will be created.
        """
        return TransactionManager(
            client=self,
            max_wait=max_wait,
            timeout=timeout,
        )


TransactionManager = AsyncTransactionManager[Prisma]


# TODO: this should return the results as well
# TODO: don't require copy-pasting arguments between actions and batch actions
class Batch:
    user: 'UserBatchActions'
    genre: 'GenreBatchActions'
    agecategory: 'AgeCategoryBatchActions'
    book: 'BookBatchActions'
    userbook: 'UserBookBatchActions'
    vote: 'VoteBatchActions'
    readingprogress: 'ReadingProgressBatchActions'
    weeklyresult: 'WeeklyResultBatchActions'
    notification: 'NotificationBatchActions'
    advertisement: 'AdvertisementBatchActions'
    partner: 'PartnerBatchActions'
    achievement: 'AchievementBatchActions'
    userachievement: 'UserAchievementBatchActions'
    auth_group: 'auth_groupBatchActions'
    auth_group_permissions: 'auth_group_permissionsBatchActions'
    auth_permission: 'auth_permissionBatchActions'
    authtoken_token: 'authtoken_tokenBatchActions'
    books_agecategory: 'books_agecategoryBatchActions'
    books_book: 'books_bookBatchActions'
    books_genre: 'books_genreBatchActions'
    django_admin_log: 'django_admin_logBatchActions'
    django_content_type: 'django_content_typeBatchActions'
    django_migrations: 'django_migrationsBatchActions'
    django_session: 'django_sessionBatchActions'
    token_blacklist_blacklistedtoken: 'token_blacklist_blacklistedtokenBatchActions'
    token_blacklist_outstandingtoken: 'token_blacklist_outstandingtokenBatchActions'
    users_user: 'users_userBatchActions'
    users_user_groups: 'users_user_groupsBatchActions'
    users_user_user_permissions: 'users_user_user_permissionsBatchActions'

    def __init__(self, client: Prisma) -> None:
        self.__client = client
        self.__queries: List[str] = []
        self._active_provider = client._active_provider
        self.user = UserBatchActions(self)
        self.genre = GenreBatchActions(self)
        self.agecategory = AgeCategoryBatchActions(self)
        self.book = BookBatchActions(self)
        self.userbook = UserBookBatchActions(self)
        self.vote = VoteBatchActions(self)
        self.readingprogress = ReadingProgressBatchActions(self)
        self.weeklyresult = WeeklyResultBatchActions(self)
        self.notification = NotificationBatchActions(self)
        self.advertisement = AdvertisementBatchActions(self)
        self.partner = PartnerBatchActions(self)
        self.achievement = AchievementBatchActions(self)
        self.userachievement = UserAchievementBatchActions(self)
        self.auth_group = auth_groupBatchActions(self)
        self.auth_group_permissions = auth_group_permissionsBatchActions(self)
        self.auth_permission = auth_permissionBatchActions(self)
        self.authtoken_token = authtoken_tokenBatchActions(self)
        self.books_agecategory = books_agecategoryBatchActions(self)
        self.books_book = books_bookBatchActions(self)
        self.books_genre = books_genreBatchActions(self)
        self.django_admin_log = django_admin_logBatchActions(self)
        self.django_content_type = django_content_typeBatchActions(self)
        self.django_migrations = django_migrationsBatchActions(self)
        self.django_session = django_sessionBatchActions(self)
        self.token_blacklist_blacklistedtoken = token_blacklist_blacklistedtokenBatchActions(self)
        self.token_blacklist_outstandingtoken = token_blacklist_outstandingtokenBatchActions(self)
        self.users_user = users_userBatchActions(self)
        self.users_user_groups = users_user_groupsBatchActions(self)
        self.users_user_user_permissions = users_user_user_permissionsBatchActions(self)

    def _add(self, **kwargs: Any) -> None:
        builder = QueryBuilder(
            **kwargs,
            prisma_models=PRISMA_MODELS,
            relational_field_mappings=RELATIONAL_FIELD_MAPPINGS,
        )
        self.__queries.append(builder.build_query())

    async def commit(self) -> None:
        """Execute the queries"""
        # TODO: normalise this, we should still call client._execute
        queries = self.__queries
        self.__queries = []

        payload = {
            'batch': [
                {
                    'query': query,
                    'variables': {},
                }
                for query in queries
            ],
            'transaction': True,
        }
        await self.__client._engine.query(
            dumps(payload),
            tx_id=self.__client._tx_id,
        )

    def execute_raw(self, query: LiteralString, *args: Any) -> None:
        self._add(
            method='execute_raw',
            arguments={
                'query': query,
                'parameters': args,
            }
        )

    async def __aenter__(self) -> 'Batch':
        return self

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> None:
        if exc is None:
            await self.commit()


# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class UserBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.User,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.User,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.User,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.User,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.User,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.User,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.User,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class GenreBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.GenreCreateInput,
        include: Optional[types.GenreInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.Genre,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.GenreCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.Genre,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.Genre,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.GenreUpdateInput,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.Genre,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.GenreWhereUniqueInput,
        data: types.GenreUpsertInput,
        include: Optional[types.GenreInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.Genre,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.GenreUpdateManyMutationInput,
        where: types.GenreWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.Genre,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.GenreWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.Genre,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AgeCategoryBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AgeCategoryCreateInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AgeCategory,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AgeCategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AgeCategory,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AgeCategory,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AgeCategoryUpdateInput,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AgeCategory,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        data: types.AgeCategoryUpsertInput,
        include: Optional[types.AgeCategoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AgeCategory,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AgeCategoryUpdateManyMutationInput,
        where: types.AgeCategoryWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AgeCategory,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AgeCategoryWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AgeCategory,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class BookBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.BookCreateInput,
        include: Optional[types.BookInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.Book,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.BookCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.Book,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.Book,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.BookUpdateInput,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.Book,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.BookWhereUniqueInput,
        data: types.BookUpsertInput,
        include: Optional[types.BookInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.Book,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.BookUpdateManyMutationInput,
        where: types.BookWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.Book,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.BookWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.Book,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class UserBookBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.UserBookCreateInput,
        include: Optional[types.UserBookInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.UserBook,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.UserBookCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.UserBook,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.UserBook,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.UserBookUpdateInput,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.UserBook,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.UserBookWhereUniqueInput,
        data: types.UserBookUpsertInput,
        include: Optional[types.UserBookInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.UserBook,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.UserBookUpdateManyMutationInput,
        where: types.UserBookWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.UserBook,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.UserBookWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.UserBook,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class VoteBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.VoteCreateInput,
        include: Optional[types.VoteInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.Vote,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.VoteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.Vote,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.Vote,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.VoteUpdateInput,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.Vote,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.VoteWhereUniqueInput,
        data: types.VoteUpsertInput,
        include: Optional[types.VoteInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.Vote,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.VoteUpdateManyMutationInput,
        where: types.VoteWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.Vote,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.VoteWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.Vote,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class ReadingProgressBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.ReadingProgressCreateInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.ReadingProgress,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.ReadingProgressCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.ReadingProgress,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.ReadingProgress,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.ReadingProgressUpdateInput,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.ReadingProgress,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        data: types.ReadingProgressUpsertInput,
        include: Optional[types.ReadingProgressInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.ReadingProgress,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.ReadingProgressUpdateManyMutationInput,
        where: types.ReadingProgressWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.ReadingProgress,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.ReadingProgressWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.ReadingProgress,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class WeeklyResultBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.WeeklyResultCreateInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.WeeklyResult,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.WeeklyResultCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.WeeklyResult,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.WeeklyResult,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.WeeklyResultUpdateInput,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.WeeklyResult,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        data: types.WeeklyResultUpsertInput,
        include: Optional[types.WeeklyResultInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.WeeklyResult,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.WeeklyResultUpdateManyMutationInput,
        where: types.WeeklyResultWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.WeeklyResult,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.WeeklyResultWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.WeeklyResult,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class NotificationBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.Notification,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.Notification,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.Notification,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.Notification,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.Notification,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.Notification,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.Notification,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AdvertisementBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AdvertisementCreateInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.Advertisement,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AdvertisementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.Advertisement,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.Advertisement,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AdvertisementUpdateInput,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.Advertisement,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AdvertisementWhereUniqueInput,
        data: types.AdvertisementUpsertInput,
        include: Optional[types.AdvertisementInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.Advertisement,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AdvertisementUpdateManyMutationInput,
        where: types.AdvertisementWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.Advertisement,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AdvertisementWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.Advertisement,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class PartnerBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.PartnerCreateInput,
        include: Optional[types.PartnerInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.Partner,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.PartnerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.Partner,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.Partner,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.PartnerUpdateInput,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.Partner,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.PartnerWhereUniqueInput,
        data: types.PartnerUpsertInput,
        include: Optional[types.PartnerInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.Partner,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.PartnerUpdateManyMutationInput,
        where: types.PartnerWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.Partner,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.PartnerWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.Partner,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AchievementBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AchievementCreateInput,
        include: Optional[types.AchievementInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.Achievement,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AchievementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.Achievement,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.Achievement,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AchievementUpdateInput,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.Achievement,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AchievementWhereUniqueInput,
        data: types.AchievementUpsertInput,
        include: Optional[types.AchievementInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.Achievement,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AchievementUpdateManyMutationInput,
        where: types.AchievementWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.Achievement,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AchievementWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.Achievement,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class UserAchievementBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.UserAchievementCreateInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.UserAchievement,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.UserAchievementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.UserAchievement,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.UserAchievementWhereUniqueInput,
        include: Optional[types.UserAchievementInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.UserAchievement,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.UserAchievementUpdateInput,
        where: types.UserAchievementWhereUniqueInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.UserAchievement,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.UserAchievementWhereUniqueInput,
        data: types.UserAchievementUpsertInput,
        include: Optional[types.UserAchievementInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.UserAchievement,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.UserAchievementUpdateManyMutationInput,
        where: types.UserAchievementWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.UserAchievement,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.UserAchievementWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.UserAchievement,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class auth_groupBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.auth_groupCreateInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.auth_group,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.auth_groupCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.auth_group,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.auth_groupWhereUniqueInput,
        include: Optional[types.auth_groupInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.auth_group,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.auth_groupUpdateInput,
        where: types.auth_groupWhereUniqueInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.auth_group,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.auth_groupWhereUniqueInput,
        data: types.auth_groupUpsertInput,
        include: Optional[types.auth_groupInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.auth_group,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.auth_groupUpdateManyMutationInput,
        where: types.auth_groupWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.auth_group,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.auth_groupWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.auth_group,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class auth_group_permissionsBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.auth_group_permissionsCreateInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.auth_group_permissions,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.auth_group_permissionsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.auth_group_permissions,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.auth_group_permissionsWhereUniqueInput,
        include: Optional[types.auth_group_permissionsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.auth_group_permissions,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.auth_group_permissionsUpdateInput,
        where: types.auth_group_permissionsWhereUniqueInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.auth_group_permissions,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.auth_group_permissionsWhereUniqueInput,
        data: types.auth_group_permissionsUpsertInput,
        include: Optional[types.auth_group_permissionsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.auth_group_permissions,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.auth_group_permissionsUpdateManyMutationInput,
        where: types.auth_group_permissionsWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.auth_group_permissions,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.auth_group_permissions,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class auth_permissionBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.auth_permissionCreateInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.auth_permission,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.auth_permissionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.auth_permission,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.auth_permissionWhereUniqueInput,
        include: Optional[types.auth_permissionInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.auth_permission,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.auth_permissionUpdateInput,
        where: types.auth_permissionWhereUniqueInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.auth_permission,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.auth_permissionWhereUniqueInput,
        data: types.auth_permissionUpsertInput,
        include: Optional[types.auth_permissionInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.auth_permission,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.auth_permissionUpdateManyMutationInput,
        where: types.auth_permissionWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.auth_permission,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.auth_permissionWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.auth_permission,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class authtoken_tokenBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.authtoken_tokenCreateInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.authtoken_token,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.authtoken_tokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.authtoken_token,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.authtoken_tokenWhereUniqueInput,
        include: Optional[types.authtoken_tokenInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.authtoken_token,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.authtoken_tokenUpdateInput,
        where: types.authtoken_tokenWhereUniqueInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.authtoken_token,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.authtoken_tokenWhereUniqueInput,
        data: types.authtoken_tokenUpsertInput,
        include: Optional[types.authtoken_tokenInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.authtoken_token,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.authtoken_tokenUpdateManyMutationInput,
        where: types.authtoken_tokenWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.authtoken_token,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.authtoken_tokenWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.authtoken_token,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class books_agecategoryBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.books_agecategoryCreateInput,
        include: Optional[types.books_agecategoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.books_agecategory,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.books_agecategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.books_agecategory,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.books_agecategoryWhereUniqueInput,
        include: Optional[types.books_agecategoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.books_agecategory,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.books_agecategoryUpdateInput,
        where: types.books_agecategoryWhereUniqueInput,
        include: Optional[types.books_agecategoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.books_agecategory,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.books_agecategoryWhereUniqueInput,
        data: types.books_agecategoryUpsertInput,
        include: Optional[types.books_agecategoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.books_agecategory,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.books_agecategoryUpdateManyMutationInput,
        where: types.books_agecategoryWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.books_agecategory,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.books_agecategoryWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.books_agecategory,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class books_bookBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.books_bookCreateInput,
        include: Optional[types.books_bookInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.books_book,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.books_bookCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.books_book,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.books_bookWhereUniqueInput,
        include: Optional[types.books_bookInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.books_book,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.books_bookUpdateInput,
        where: types.books_bookWhereUniqueInput,
        include: Optional[types.books_bookInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.books_book,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.books_bookWhereUniqueInput,
        data: types.books_bookUpsertInput,
        include: Optional[types.books_bookInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.books_book,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.books_bookUpdateManyMutationInput,
        where: types.books_bookWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.books_book,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.books_bookWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.books_book,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class books_genreBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.books_genreCreateInput,
        include: Optional[types.books_genreInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.books_genre,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.books_genreCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.books_genre,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.books_genreWhereUniqueInput,
        include: Optional[types.books_genreInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.books_genre,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.books_genreUpdateInput,
        where: types.books_genreWhereUniqueInput,
        include: Optional[types.books_genreInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.books_genre,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.books_genreWhereUniqueInput,
        data: types.books_genreUpsertInput,
        include: Optional[types.books_genreInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.books_genre,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.books_genreUpdateManyMutationInput,
        where: types.books_genreWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.books_genre,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.books_genreWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.books_genre,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class django_admin_logBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.django_admin_logCreateInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.django_admin_log,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.django_admin_logCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.django_admin_log,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.django_admin_logWhereUniqueInput,
        include: Optional[types.django_admin_logInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.django_admin_log,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.django_admin_logUpdateInput,
        where: types.django_admin_logWhereUniqueInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.django_admin_log,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.django_admin_logWhereUniqueInput,
        data: types.django_admin_logUpsertInput,
        include: Optional[types.django_admin_logInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.django_admin_log,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.django_admin_logUpdateManyMutationInput,
        where: types.django_admin_logWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.django_admin_log,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.django_admin_logWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.django_admin_log,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class django_content_typeBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.django_content_typeCreateInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.django_content_type,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.django_content_typeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.django_content_type,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.django_content_typeWhereUniqueInput,
        include: Optional[types.django_content_typeInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.django_content_type,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.django_content_typeUpdateInput,
        where: types.django_content_typeWhereUniqueInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.django_content_type,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.django_content_typeWhereUniqueInput,
        data: types.django_content_typeUpsertInput,
        include: Optional[types.django_content_typeInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.django_content_type,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.django_content_typeUpdateManyMutationInput,
        where: types.django_content_typeWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.django_content_type,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.django_content_typeWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.django_content_type,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class django_migrationsBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.django_migrationsCreateInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.django_migrations,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.django_migrationsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.django_migrations,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.django_migrationsWhereUniqueInput,
        include: Optional[types.django_migrationsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.django_migrations,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.django_migrationsUpdateInput,
        where: types.django_migrationsWhereUniqueInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.django_migrations,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.django_migrationsWhereUniqueInput,
        data: types.django_migrationsUpsertInput,
        include: Optional[types.django_migrationsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.django_migrations,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.django_migrationsUpdateManyMutationInput,
        where: types.django_migrationsWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.django_migrations,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.django_migrationsWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.django_migrations,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class django_sessionBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.django_sessionCreateInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.django_session,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.django_sessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.django_session,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.django_sessionWhereUniqueInput,
        include: Optional[types.django_sessionInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.django_session,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.django_sessionUpdateInput,
        where: types.django_sessionWhereUniqueInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.django_session,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.django_sessionWhereUniqueInput,
        data: types.django_sessionUpsertInput,
        include: Optional[types.django_sessionInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.django_session,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.django_sessionUpdateManyMutationInput,
        where: types.django_sessionWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.django_session,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.django_sessionWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.django_session,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class token_blacklist_blacklistedtokenBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.token_blacklist_blacklistedtokenCreateInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.token_blacklist_blacklistedtoken,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.token_blacklist_blacklistedtokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.token_blacklist_blacklistedtoken,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.token_blacklist_blacklistedtoken,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.token_blacklist_blacklistedtokenUpdateInput,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.token_blacklist_blacklistedtoken,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        data: types.token_blacklist_blacklistedtokenUpsertInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.token_blacklist_blacklistedtoken,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.token_blacklist_blacklistedtokenUpdateManyMutationInput,
        where: types.token_blacklist_blacklistedtokenWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.token_blacklist_blacklistedtoken,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.token_blacklist_blacklistedtoken,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class token_blacklist_outstandingtokenBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.token_blacklist_outstandingtokenCreateInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.token_blacklist_outstandingtoken,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.token_blacklist_outstandingtokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.token_blacklist_outstandingtoken,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.token_blacklist_outstandingtoken,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.token_blacklist_outstandingtokenUpdateInput,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.token_blacklist_outstandingtoken,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        data: types.token_blacklist_outstandingtokenUpsertInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.token_blacklist_outstandingtoken,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.token_blacklist_outstandingtokenUpdateManyMutationInput,
        where: types.token_blacklist_outstandingtokenWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.token_blacklist_outstandingtoken,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.token_blacklist_outstandingtoken,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class users_userBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.users_userCreateInput,
        include: Optional[types.users_userInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.users_user,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.users_userCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.users_user,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.users_userWhereUniqueInput,
        include: Optional[types.users_userInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.users_user,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.users_userUpdateInput,
        where: types.users_userWhereUniqueInput,
        include: Optional[types.users_userInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.users_user,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.users_userWhereUniqueInput,
        data: types.users_userUpsertInput,
        include: Optional[types.users_userInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.users_user,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.users_userUpdateManyMutationInput,
        where: types.users_userWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.users_user,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.users_userWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.users_user,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class users_user_groupsBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.users_user_groupsCreateInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.users_user_groups,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.users_user_groupsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.users_user_groups,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.users_user_groupsWhereUniqueInput,
        include: Optional[types.users_user_groupsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.users_user_groups,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.users_user_groupsUpdateInput,
        where: types.users_user_groupsWhereUniqueInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.users_user_groups,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.users_user_groupsWhereUniqueInput,
        data: types.users_user_groupsUpsertInput,
        include: Optional[types.users_user_groupsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.users_user_groups,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.users_user_groupsUpdateManyMutationInput,
        where: types.users_user_groupsWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.users_user_groups,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.users_user_groupsWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.users_user_groups,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class users_user_user_permissionsBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.users_user_user_permissionsCreateInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.users_user_user_permissions,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.users_user_user_permissionsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.users_user_user_permissions,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.users_user_user_permissionsWhereUniqueInput,
        include: Optional[types.users_user_user_permissionsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.users_user_user_permissions,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.users_user_user_permissionsUpdateInput,
        where: types.users_user_user_permissionsWhereUniqueInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.users_user_user_permissions,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.users_user_user_permissionsWhereUniqueInput,
        data: types.users_user_user_permissionsUpsertInput,
        include: Optional[types.users_user_user_permissionsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.users_user_user_permissions,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.users_user_user_permissionsUpdateManyMutationInput,
        where: types.users_user_user_permissionsWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.users_user_user_permissions,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.users_user_user_permissions,
            arguments={'where': where},
            root_selection=['count'],
        )



Client = Prisma