# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _int
    email: _str
    username: _str
    passwordHash: _str
    registrationDate: datetime.datetime
    isPremium: _bool
    premiumExpirationDate: Optional[datetime.datetime] = None
    hideAds: _bool
    votes: Optional[List['models.Vote']] = None
    readingProgress: Optional[List['models.ReadingProgress']] = None
    notifications: Optional[List['models.Notification']] = None
    leaderResults: Optional[List['models.WeeklyResult']] = None
    userBooks: Optional[List['models.UserBook']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Genre(bases.BaseGenre):
    """Represents a Genre record"""

    id: _str
    name: _str
    parentId: Optional[_str] = None
    parent: Optional['models.Genre'] = None
    subgenres: Optional[List['models.Genre']] = None
    books: Optional[List['models.Book']] = None
    weeklyResults: Optional[List['models.WeeklyResult']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.GenreKeys']] = None,
        exclude: Optional[Iterable['types.GenreKeys']] = None,
        required: Optional[Iterable['types.GenreKeys']] = None,
        optional: Optional[Iterable['types.GenreKeys']] = None,
        relations: Optional[Mapping['types.GenreRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.GenreKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Genre_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Genre_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Genre_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Genre_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Genre_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Genre_relational_fields:
                        raise errors.UnknownRelationalFieldError('Genre', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Genre / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Genre',
            }
        )
        _created_partial_types.add(name)


class AgeCategory(bases.BaseAgeCategory):
    """Represents a AgeCategory record"""

    id: _int
    name: _str
    books: Optional[List['models.Book']] = None
    weeklyResults: Optional[List['models.WeeklyResult']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AgeCategoryKeys']] = None,
        exclude: Optional[Iterable['types.AgeCategoryKeys']] = None,
        required: Optional[Iterable['types.AgeCategoryKeys']] = None,
        optional: Optional[Iterable['types.AgeCategoryKeys']] = None,
        relations: Optional[Mapping['types.AgeCategoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AgeCategoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AgeCategory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AgeCategory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AgeCategory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AgeCategory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AgeCategory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AgeCategory_relational_fields:
                        raise errors.UnknownRelationalFieldError('AgeCategory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AgeCategory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AgeCategory',
            }
        )
        _created_partial_types.add(name)


class Book(bases.BaseBook):
    """Represents a Book record"""

    id: _int
    title: _str
    author: _str
    description: Optional[_str] = None
    coverUrl: Optional[_str] = None
    litresId: _int
    genreId: Optional[_str] = None
    ageCategoryId: _int
    rating: _float
    isPremium: _bool
    litresRating: Optional[_float] = None
    litresRatingCount: Optional[_int] = None
    series: Optional[_str] = None
    translator: Optional[_str] = None
    volume: Optional[_str] = None
    year: Optional[_str] = None
    isbn: Optional[_str] = None
    copyrightHolder: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    genre: Optional['models.Genre'] = None
    ageCategory: Optional['models.AgeCategory'] = None
    votes: Optional[List['models.Vote']] = None
    readingProgress: Optional[List['models.ReadingProgress']] = None
    weeklyResults: Optional[List['models.WeeklyResult']] = None
    userBooks: Optional[List['models.UserBook']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.BookKeys']] = None,
        exclude: Optional[Iterable['types.BookKeys']] = None,
        required: Optional[Iterable['types.BookKeys']] = None,
        optional: Optional[Iterable['types.BookKeys']] = None,
        relations: Optional[Mapping['types.BookRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.BookKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Book_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Book_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Book_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Book_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Book_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Book_relational_fields:
                        raise errors.UnknownRelationalFieldError('Book', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Book / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Book',
            }
        )
        _created_partial_types.add(name)


class UserBook(bases.BaseUserBook):
    """Represents a UserBook record"""

    id: _int
    userId: _int
    bookId: _int
    status: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: Optional['models.User'] = None
    book: Optional['models.Book'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserBookKeys']] = None,
        exclude: Optional[Iterable['types.UserBookKeys']] = None,
        required: Optional[Iterable['types.UserBookKeys']] = None,
        optional: Optional[Iterable['types.UserBookKeys']] = None,
        relations: Optional[Mapping['types.UserBookRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserBookKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserBook_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserBook_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserBook_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserBook_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserBook_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserBook_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserBook', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserBook / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserBook',
            }
        )
        _created_partial_types.add(name)


class Vote(bases.BaseVote):
    """Represents a Vote record"""

    id: _int
    userId: _int
    bookId: _int
    weekNumber: _int
    voteDate: datetime.datetime
    user: Optional['models.User'] = None
    book: Optional['models.Book'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.VoteKeys']] = None,
        exclude: Optional[Iterable['types.VoteKeys']] = None,
        required: Optional[Iterable['types.VoteKeys']] = None,
        optional: Optional[Iterable['types.VoteKeys']] = None,
        relations: Optional[Mapping['types.VoteRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.VoteKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Vote_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Vote_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Vote_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Vote_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Vote_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Vote_relational_fields:
                        raise errors.UnknownRelationalFieldError('Vote', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Vote / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Vote',
            }
        )
        _created_partial_types.add(name)


class ReadingProgress(bases.BaseReadingProgress):
    """Represents a ReadingProgress record"""

    id: _int
    userId: _int
    bookId: _int
    weekNumber: _int
    marks: _int
    progressDate: datetime.datetime
    user: Optional['models.User'] = None
    book: Optional['models.Book'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ReadingProgressKeys']] = None,
        exclude: Optional[Iterable['types.ReadingProgressKeys']] = None,
        required: Optional[Iterable['types.ReadingProgressKeys']] = None,
        optional: Optional[Iterable['types.ReadingProgressKeys']] = None,
        relations: Optional[Mapping['types.ReadingProgressRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ReadingProgressKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ReadingProgress_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ReadingProgress_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ReadingProgress_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ReadingProgress_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ReadingProgress_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ReadingProgress_relational_fields:
                        raise errors.UnknownRelationalFieldError('ReadingProgress', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ReadingProgress / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ReadingProgress',
            }
        )
        _created_partial_types.add(name)


class WeeklyResult(bases.BaseWeeklyResult):
    """Represents a WeeklyResult record"""

    id: _int
    weekNumber: _int
    genreId: Optional[_str] = None
    ageCategoryId: _int
    bookId: _int
    leaderUserId: _int
    totalMarks: _int
    genre: Optional['models.Genre'] = None
    ageCategory: Optional['models.AgeCategory'] = None
    book: Optional['models.Book'] = None
    leader: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.WeeklyResultKeys']] = None,
        exclude: Optional[Iterable['types.WeeklyResultKeys']] = None,
        required: Optional[Iterable['types.WeeklyResultKeys']] = None,
        optional: Optional[Iterable['types.WeeklyResultKeys']] = None,
        relations: Optional[Mapping['types.WeeklyResultRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.WeeklyResultKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _WeeklyResult_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _WeeklyResult_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _WeeklyResult_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _WeeklyResult_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _WeeklyResult_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _WeeklyResult_relational_fields:
                        raise errors.UnknownRelationalFieldError('WeeklyResult', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid WeeklyResult / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'WeeklyResult',
            }
        )
        _created_partial_types.add(name)


class Notification(bases.BaseNotification):
    """Represents a Notification record"""

    id: _int
    userId: _int
    message: _str
    sentDate: datetime.datetime
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.NotificationKeys']] = None,
        exclude: Optional[Iterable['types.NotificationKeys']] = None,
        required: Optional[Iterable['types.NotificationKeys']] = None,
        optional: Optional[Iterable['types.NotificationKeys']] = None,
        relations: Optional[Mapping['types.NotificationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.NotificationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Notification_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Notification_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Notification_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Notification_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Notification_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Notification_relational_fields:
                        raise errors.UnknownRelationalFieldError('Notification', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Notification / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Notification',
            }
        )
        _created_partial_types.add(name)


class Advertisement(bases.BaseAdvertisement):
    """Represents a Advertisement record"""

    id: _int
    content: _str
    partnerId: _int
    isActive: _bool
    partner: Optional['models.Partner'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AdvertisementKeys']] = None,
        exclude: Optional[Iterable['types.AdvertisementKeys']] = None,
        required: Optional[Iterable['types.AdvertisementKeys']] = None,
        optional: Optional[Iterable['types.AdvertisementKeys']] = None,
        relations: Optional[Mapping['types.AdvertisementRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AdvertisementKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Advertisement_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Advertisement_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Advertisement_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Advertisement_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Advertisement_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Advertisement_relational_fields:
                        raise errors.UnknownRelationalFieldError('Advertisement', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Advertisement / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Advertisement',
            }
        )
        _created_partial_types.add(name)


class Partner(bases.BasePartner):
    """Represents a Partner record"""

    id: _int
    name: _str
    contactInfo: _str
    advertisements: Optional[List['models.Advertisement']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PartnerKeys']] = None,
        exclude: Optional[Iterable['types.PartnerKeys']] = None,
        required: Optional[Iterable['types.PartnerKeys']] = None,
        optional: Optional[Iterable['types.PartnerKeys']] = None,
        relations: Optional[Mapping['types.PartnerRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PartnerKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Partner_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Partner_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Partner_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Partner_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Partner_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Partner_relational_fields:
                        raise errors.UnknownRelationalFieldError('Partner', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Partner / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Partner',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'votes',
        'readingProgress',
        'notifications',
        'leaderResults',
        'userBooks',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('passwordHash', {
            'name': 'passwordHash',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('registrationDate', {
            'name': 'registrationDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('isPremium', {
            'name': 'isPremium',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('premiumExpirationDate', {
            'name': 'premiumExpirationDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('hideAds', {
            'name': 'hideAds',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('votes', {
            'name': 'votes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Vote\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('readingProgress', {
            'name': 'readingProgress',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ReadingProgress\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('notifications', {
            'name': 'notifications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Notification\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('leaderResults', {
            'name': 'leaderResults',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WeeklyResult\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('userBooks', {
            'name': 'userBooks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserBook\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Genre_relational_fields: Set[str] = {
        'parent',
        'subgenres',
        'books',
        'weeklyResults',
    }
_Genre_fields: Dict['types.GenreKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('parentId', {
            'name': 'parentId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('parent', {
            'name': 'parent',
            'is_list': False,
            'optional': True,
            'type': 'models.Genre',
            'is_relational': True,
            'documentation': None,
        }),
        ('subgenres', {
            'name': 'subgenres',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Genre\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('books', {
            'name': 'books',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Book\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('weeklyResults', {
            'name': 'weeklyResults',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WeeklyResult\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AgeCategory_relational_fields: Set[str] = {
        'books',
        'weeklyResults',
    }
_AgeCategory_fields: Dict['types.AgeCategoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('books', {
            'name': 'books',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Book\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('weeklyResults', {
            'name': 'weeklyResults',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WeeklyResult\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Book_relational_fields: Set[str] = {
        'genre',
        'ageCategory',
        'votes',
        'readingProgress',
        'weeklyResults',
        'userBooks',
    }
_Book_fields: Dict['types.BookKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('author', {
            'name': 'author',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('coverUrl', {
            'name': 'coverUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litresId', {
            'name': 'litresId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('genreId', {
            'name': 'genreId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ageCategoryId', {
            'name': 'ageCategoryId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rating', {
            'name': 'rating',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('isPremium', {
            'name': 'isPremium',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('litresRating', {
            'name': 'litresRating',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('litresRatingCount', {
            'name': 'litresRatingCount',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('series', {
            'name': 'series',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('translator', {
            'name': 'translator',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('volume', {
            'name': 'volume',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('year', {
            'name': 'year',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isbn', {
            'name': 'isbn',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('copyrightHolder', {
            'name': 'copyrightHolder',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('genre', {
            'name': 'genre',
            'is_list': False,
            'optional': True,
            'type': 'models.Genre',
            'is_relational': True,
            'documentation': None,
        }),
        ('ageCategory', {
            'name': 'ageCategory',
            'is_list': False,
            'optional': True,
            'type': 'models.AgeCategory',
            'is_relational': True,
            'documentation': None,
        }),
        ('votes', {
            'name': 'votes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Vote\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('readingProgress', {
            'name': 'readingProgress',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ReadingProgress\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('weeklyResults', {
            'name': 'weeklyResults',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WeeklyResult\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('userBooks', {
            'name': 'userBooks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserBook\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserBook_relational_fields: Set[str] = {
        'user',
        'book',
    }
_UserBook_fields: Dict['types.UserBookKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('bookId', {
            'name': 'bookId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('book', {
            'name': 'book',
            'is_list': False,
            'optional': True,
            'type': 'models.Book',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Vote_relational_fields: Set[str] = {
        'user',
        'book',
    }
_Vote_fields: Dict['types.VoteKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('bookId', {
            'name': 'bookId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('weekNumber', {
            'name': 'weekNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('voteDate', {
            'name': 'voteDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('book', {
            'name': 'book',
            'is_list': False,
            'optional': True,
            'type': 'models.Book',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ReadingProgress_relational_fields: Set[str] = {
        'user',
        'book',
    }
_ReadingProgress_fields: Dict['types.ReadingProgressKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('bookId', {
            'name': 'bookId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('weekNumber', {
            'name': 'weekNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('marks', {
            'name': 'marks',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('progressDate', {
            'name': 'progressDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('book', {
            'name': 'book',
            'is_list': False,
            'optional': True,
            'type': 'models.Book',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_WeeklyResult_relational_fields: Set[str] = {
        'genre',
        'ageCategory',
        'book',
        'leader',
    }
_WeeklyResult_fields: Dict['types.WeeklyResultKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('weekNumber', {
            'name': 'weekNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('genreId', {
            'name': 'genreId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ageCategoryId', {
            'name': 'ageCategoryId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('bookId', {
            'name': 'bookId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('leaderUserId', {
            'name': 'leaderUserId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalMarks', {
            'name': 'totalMarks',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('genre', {
            'name': 'genre',
            'is_list': False,
            'optional': True,
            'type': 'models.Genre',
            'is_relational': True,
            'documentation': None,
        }),
        ('ageCategory', {
            'name': 'ageCategory',
            'is_list': False,
            'optional': True,
            'type': 'models.AgeCategory',
            'is_relational': True,
            'documentation': None,
        }),
        ('book', {
            'name': 'book',
            'is_list': False,
            'optional': True,
            'type': 'models.Book',
            'is_relational': True,
            'documentation': None,
        }),
        ('leader', {
            'name': 'leader',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Notification_relational_fields: Set[str] = {
        'user',
    }
_Notification_fields: Dict['types.NotificationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('message', {
            'name': 'message',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sentDate', {
            'name': 'sentDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Advertisement_relational_fields: Set[str] = {
        'partner',
    }
_Advertisement_fields: Dict['types.AdvertisementKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('partnerId', {
            'name': 'partnerId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('partner', {
            'name': 'partner',
            'is_list': False,
            'optional': True,
            'type': 'models.Partner',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Partner_relational_fields: Set[str] = {
        'advertisements',
    }
_Partner_fields: Dict['types.PartnerKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('contactInfo', {
            'name': 'contactInfo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('advertisements', {
            'name': 'advertisements',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Advertisement\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(Genre)
model_rebuild(AgeCategory)
model_rebuild(Book)
model_rebuild(UserBook)
model_rebuild(Vote)
model_rebuild(ReadingProgress)
model_rebuild(WeeklyResult)
model_rebuild(Notification)
model_rebuild(Advertisement)
model_rebuild(Partner)
