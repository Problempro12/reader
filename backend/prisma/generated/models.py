# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _int
    email: _str
    username: _str
    passwordHash: _str
    isPremium: _bool
    premiumExpirationDate: Optional[datetime.datetime] = None
    hideAds: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    registrationDate: datetime.datetime
    about: Optional[_str] = None
    avatar: Optional[_str] = None
    isActive: _bool
    isStaff: _bool
    isSuperuser: _bool
    lastLogin: Optional[datetime.datetime] = None
    groups: Optional[List['models.UserGroup']] = None
    permissions: Optional[List['models.UserPermission']] = None
    tokens: Optional[List['models.Token']] = None
    sessions: Optional[List['models.Session']] = None
    notifications: Optional[List['models.Notification']] = None
    readingProgress: Optional[List['models.ReadingProgress']] = None
    userBooks: Optional[List['models.UserBook']] = None
    votes: Optional[List['models.Vote']] = None
    leaderResults: Optional[List['models.WeeklyResult']] = None
    userAchievements: Optional[List['models.UserAchievement']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Group(bases.BaseGroup):
    """Represents a Group record"""

    id: _int
    name: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    users: Optional[List['models.UserGroup']] = None
    permissions: Optional[List['models.GroupPermission']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.GroupKeys']] = None,
        exclude: Optional[Iterable['types.GroupKeys']] = None,
        required: Optional[Iterable['types.GroupKeys']] = None,
        optional: Optional[Iterable['types.GroupKeys']] = None,
        relations: Optional[Mapping['types.GroupRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.GroupKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Group_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Group_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Group_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Group_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Group_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Group_relational_fields:
                        raise errors.UnknownRelationalFieldError('Group', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Group / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Group',
            }
        )
        _created_partial_types.add(name)


class Permission(bases.BasePermission):
    """Represents a Permission record"""

    id: _int
    name: _str
    codename: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    users: Optional[List['models.UserPermission']] = None
    groups: Optional[List['models.GroupPermission']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PermissionKeys']] = None,
        exclude: Optional[Iterable['types.PermissionKeys']] = None,
        required: Optional[Iterable['types.PermissionKeys']] = None,
        optional: Optional[Iterable['types.PermissionKeys']] = None,
        relations: Optional[Mapping['types.PermissionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PermissionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Permission_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Permission_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Permission_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Permission_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Permission_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Permission_relational_fields:
                        raise errors.UnknownRelationalFieldError('Permission', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Permission / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Permission',
            }
        )
        _created_partial_types.add(name)


class UserGroup(bases.BaseUserGroup):
    """Represents a UserGroup record"""

    id: _int
    userId: _int
    groupId: _int
    createdAt: datetime.datetime
    user: Optional['models.User'] = None
    group: Optional['models.Group'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserGroupKeys']] = None,
        exclude: Optional[Iterable['types.UserGroupKeys']] = None,
        required: Optional[Iterable['types.UserGroupKeys']] = None,
        optional: Optional[Iterable['types.UserGroupKeys']] = None,
        relations: Optional[Mapping['types.UserGroupRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserGroupKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserGroup_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserGroup_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserGroup_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserGroup_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserGroup_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserGroup_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserGroup', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserGroup / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserGroup',
            }
        )
        _created_partial_types.add(name)


class UserPermission(bases.BaseUserPermission):
    """Represents a UserPermission record"""

    id: _int
    userId: _int
    permissionId: _int
    createdAt: datetime.datetime
    user: Optional['models.User'] = None
    permission: Optional['models.Permission'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserPermissionKeys']] = None,
        exclude: Optional[Iterable['types.UserPermissionKeys']] = None,
        required: Optional[Iterable['types.UserPermissionKeys']] = None,
        optional: Optional[Iterable['types.UserPermissionKeys']] = None,
        relations: Optional[Mapping['types.UserPermissionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserPermissionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserPermission_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserPermission_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserPermission_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserPermission_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserPermission_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserPermission_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserPermission', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserPermission / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserPermission',
            }
        )
        _created_partial_types.add(name)


class GroupPermission(bases.BaseGroupPermission):
    """Represents a GroupPermission record"""

    id: _int
    groupId: _int
    permissionId: _int
    createdAt: datetime.datetime
    group: Optional['models.Group'] = None
    permission: Optional['models.Permission'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.GroupPermissionKeys']] = None,
        exclude: Optional[Iterable['types.GroupPermissionKeys']] = None,
        required: Optional[Iterable['types.GroupPermissionKeys']] = None,
        optional: Optional[Iterable['types.GroupPermissionKeys']] = None,
        relations: Optional[Mapping['types.GroupPermissionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.GroupPermissionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _GroupPermission_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _GroupPermission_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _GroupPermission_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _GroupPermission_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _GroupPermission_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _GroupPermission_relational_fields:
                        raise errors.UnknownRelationalFieldError('GroupPermission', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid GroupPermission / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'GroupPermission',
            }
        )
        _created_partial_types.add(name)


class Token(bases.BaseToken):
    """Represents a Token record"""

    id: _int
    userId: _int
    token: _str
    createdAt: datetime.datetime
    expiresAt: datetime.datetime
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TokenKeys']] = None,
        exclude: Optional[Iterable['types.TokenKeys']] = None,
        required: Optional[Iterable['types.TokenKeys']] = None,
        optional: Optional[Iterable['types.TokenKeys']] = None,
        relations: Optional[Mapping['types.TokenRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TokenKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Token_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Token_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Token_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Token_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Token_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Token_relational_fields:
                        raise errors.UnknownRelationalFieldError('Token', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Token / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Token',
            }
        )
        _created_partial_types.add(name)


class Session(bases.BaseSession):
    """Represents a Session record"""

    id: _int
    userId: _int
    sessionKey: _str
    createdAt: datetime.datetime
    expiresAt: datetime.datetime
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SessionKeys']] = None,
        exclude: Optional[Iterable['types.SessionKeys']] = None,
        required: Optional[Iterable['types.SessionKeys']] = None,
        optional: Optional[Iterable['types.SessionKeys']] = None,
        relations: Optional[Mapping['types.SessionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SessionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Session_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Session_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Session_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Session_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Session_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Session_relational_fields:
                        raise errors.UnknownRelationalFieldError('Session', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Session / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Session',
            }
        )
        _created_partial_types.add(name)


class Genre(bases.BaseGenre):
    """Represents a Genre record"""

    name: _str
    createdAt: Optional[datetime.datetime] = None
    updatedAt: Optional[datetime.datetime] = None
    id: _int
    parentId: Optional[_int] = None
    books: Optional[List['models.Book']] = None
    parent: Optional['models.Genre'] = None
    subgenres: Optional[List['models.Genre']] = None
    weeklyResults: Optional[List['models.WeeklyResult']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.GenreKeys']] = None,
        exclude: Optional[Iterable['types.GenreKeys']] = None,
        required: Optional[Iterable['types.GenreKeys']] = None,
        optional: Optional[Iterable['types.GenreKeys']] = None,
        relations: Optional[Mapping['types.GenreRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.GenreKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Genre_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Genre_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Genre_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Genre_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Genre_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Genre_relational_fields:
                        raise errors.UnknownRelationalFieldError('Genre', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Genre / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Genre',
            }
        )
        _created_partial_types.add(name)


class AgeCategory(bases.BaseAgeCategory):
    """Represents a AgeCategory record"""

    id: _int
    name: _str
    books: Optional[List['models.Book']] = None
    weeklyResults: Optional[List['models.WeeklyResult']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AgeCategoryKeys']] = None,
        exclude: Optional[Iterable['types.AgeCategoryKeys']] = None,
        required: Optional[Iterable['types.AgeCategoryKeys']] = None,
        optional: Optional[Iterable['types.AgeCategoryKeys']] = None,
        relations: Optional[Mapping['types.AgeCategoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AgeCategoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AgeCategory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AgeCategory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AgeCategory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AgeCategory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AgeCategory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AgeCategory_relational_fields:
                        raise errors.UnknownRelationalFieldError('AgeCategory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AgeCategory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AgeCategory',
            }
        )
        _created_partial_types.add(name)


class Author(bases.BaseAuthor):
    """Represents a Author record"""

    id: _int
    name: _str
    books: Optional[List['models.Book']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AuthorKeys']] = None,
        exclude: Optional[Iterable['types.AuthorKeys']] = None,
        required: Optional[Iterable['types.AuthorKeys']] = None,
        optional: Optional[Iterable['types.AuthorKeys']] = None,
        relations: Optional[Mapping['types.AuthorRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AuthorKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Author_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Author_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Author_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Author_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Author_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Author_relational_fields:
                        raise errors.UnknownRelationalFieldError('Author', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Author / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Author',
            }
        )
        _created_partial_types.add(name)


class Book(bases.BaseBook):
    """Represents a Book record"""

    id: _int
    title: _str
    authorId: _int
    author: Optional['models.Author'] = None
    description: Optional[_str] = None
    coverUrl: Optional[_str] = None
    externalId: Optional[_str] = None
    ageCategoryId: _int
    rating: _float
    rating_count: _int
    isPremium: _bool
    litresRating: Optional[_float] = None
    litresRatingCount: Optional[_int] = None
    series: Optional[_str] = None
    translator: Optional[_str] = None
    volume: Optional[_str] = None
    year: Optional[_str] = None
    isbn: Optional[_str] = None
    copyrightHolder: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    genreId: _int
    ageCategory: Optional['models.AgeCategory'] = None
    genre: Optional['models.Genre'] = None
    readingProgress: Optional[List['models.ReadingProgress']] = None
    userBooks: Optional[List['models.UserBook']] = None
    votes: Optional[List['models.Vote']] = None
    weeklyResults: Optional[List['models.WeeklyResult']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.BookKeys']] = None,
        exclude: Optional[Iterable['types.BookKeys']] = None,
        required: Optional[Iterable['types.BookKeys']] = None,
        optional: Optional[Iterable['types.BookKeys']] = None,
        relations: Optional[Mapping['types.BookRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.BookKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Book_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Book_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Book_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Book_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Book_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Book_relational_fields:
                        raise errors.UnknownRelationalFieldError('Book', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Book / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Book',
            }
        )
        _created_partial_types.add(name)


class UserBook(bases.BaseUserBook):
    """Represents a UserBook record"""

    id: _int
    userId: _int
    bookId: _int
    status: _str
    rating: Optional[_int] = None
    addedAt: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    book: Optional['models.Book'] = None
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserBookKeys']] = None,
        exclude: Optional[Iterable['types.UserBookKeys']] = None,
        required: Optional[Iterable['types.UserBookKeys']] = None,
        optional: Optional[Iterable['types.UserBookKeys']] = None,
        relations: Optional[Mapping['types.UserBookRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserBookKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserBook_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserBook_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserBook_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserBook_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserBook_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserBook_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserBook', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserBook / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserBook',
            }
        )
        _created_partial_types.add(name)


class Vote(bases.BaseVote):
    """Represents a Vote record"""

    id: _int
    userId: _int
    bookId: _int
    weekNumber: _int
    voteDate: datetime.datetime
    book: Optional['models.Book'] = None
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.VoteKeys']] = None,
        exclude: Optional[Iterable['types.VoteKeys']] = None,
        required: Optional[Iterable['types.VoteKeys']] = None,
        optional: Optional[Iterable['types.VoteKeys']] = None,
        relations: Optional[Mapping['types.VoteRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.VoteKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Vote_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Vote_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Vote_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Vote_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Vote_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Vote_relational_fields:
                        raise errors.UnknownRelationalFieldError('Vote', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Vote / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Vote',
            }
        )
        _created_partial_types.add(name)


class ReadingProgress(bases.BaseReadingProgress):
    """Represents a ReadingProgress record"""

    id: _int
    userId: _int
    bookId: _int
    weekNumber: _int
    marks: _int
    progressDate: datetime.datetime
    book: Optional['models.Book'] = None
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ReadingProgressKeys']] = None,
        exclude: Optional[Iterable['types.ReadingProgressKeys']] = None,
        required: Optional[Iterable['types.ReadingProgressKeys']] = None,
        optional: Optional[Iterable['types.ReadingProgressKeys']] = None,
        relations: Optional[Mapping['types.ReadingProgressRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ReadingProgressKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ReadingProgress_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ReadingProgress_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ReadingProgress_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ReadingProgress_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ReadingProgress_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ReadingProgress_relational_fields:
                        raise errors.UnknownRelationalFieldError('ReadingProgress', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ReadingProgress / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ReadingProgress',
            }
        )
        _created_partial_types.add(name)


class WeeklyResult(bases.BaseWeeklyResult):
    """Represents a WeeklyResult record"""

    id: _int
    weekNumber: _int
    ageCategoryId: _int
    bookId: _int
    leaderUserId: _int
    totalMarks: _int
    genreId: Optional[_int] = None
    ageCategory: Optional['models.AgeCategory'] = None
    book: Optional['models.Book'] = None
    genre: Optional['models.Genre'] = None
    leader: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.WeeklyResultKeys']] = None,
        exclude: Optional[Iterable['types.WeeklyResultKeys']] = None,
        required: Optional[Iterable['types.WeeklyResultKeys']] = None,
        optional: Optional[Iterable['types.WeeklyResultKeys']] = None,
        relations: Optional[Mapping['types.WeeklyResultRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.WeeklyResultKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _WeeklyResult_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _WeeklyResult_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _WeeklyResult_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _WeeklyResult_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _WeeklyResult_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _WeeklyResult_relational_fields:
                        raise errors.UnknownRelationalFieldError('WeeklyResult', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid WeeklyResult / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'WeeklyResult',
            }
        )
        _created_partial_types.add(name)


class Notification(bases.BaseNotification):
    """Represents a Notification record"""

    id: _int
    userId: _int
    message: _str
    sentDate: datetime.datetime
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.NotificationKeys']] = None,
        exclude: Optional[Iterable['types.NotificationKeys']] = None,
        required: Optional[Iterable['types.NotificationKeys']] = None,
        optional: Optional[Iterable['types.NotificationKeys']] = None,
        relations: Optional[Mapping['types.NotificationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.NotificationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Notification_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Notification_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Notification_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Notification_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Notification_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Notification_relational_fields:
                        raise errors.UnknownRelationalFieldError('Notification', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Notification / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Notification',
            }
        )
        _created_partial_types.add(name)


class Advertisement(bases.BaseAdvertisement):
    """Represents a Advertisement record"""

    id: _int
    content: _str
    partnerId: _int
    isActive: _bool
    partner: Optional['models.Partner'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AdvertisementKeys']] = None,
        exclude: Optional[Iterable['types.AdvertisementKeys']] = None,
        required: Optional[Iterable['types.AdvertisementKeys']] = None,
        optional: Optional[Iterable['types.AdvertisementKeys']] = None,
        relations: Optional[Mapping['types.AdvertisementRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AdvertisementKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Advertisement_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Advertisement_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Advertisement_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Advertisement_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Advertisement_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Advertisement_relational_fields:
                        raise errors.UnknownRelationalFieldError('Advertisement', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Advertisement / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Advertisement',
            }
        )
        _created_partial_types.add(name)


class Partner(bases.BasePartner):
    """Represents a Partner record"""

    id: _int
    name: _str
    contactInfo: _str
    advertisements: Optional[List['models.Advertisement']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PartnerKeys']] = None,
        exclude: Optional[Iterable['types.PartnerKeys']] = None,
        required: Optional[Iterable['types.PartnerKeys']] = None,
        optional: Optional[Iterable['types.PartnerKeys']] = None,
        relations: Optional[Mapping['types.PartnerRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PartnerKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Partner_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Partner_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Partner_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Partner_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Partner_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Partner_relational_fields:
                        raise errors.UnknownRelationalFieldError('Partner', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Partner / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Partner',
            }
        )
        _created_partial_types.add(name)


class Achievement(bases.BaseAchievement):
    """Represents a Achievement record"""

    id: _int
    name: _str
    description: _str
    type: _str
    criteria: 'fields.Json'
    reward: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    userAchievements: Optional[List['models.UserAchievement']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AchievementKeys']] = None,
        exclude: Optional[Iterable['types.AchievementKeys']] = None,
        required: Optional[Iterable['types.AchievementKeys']] = None,
        optional: Optional[Iterable['types.AchievementKeys']] = None,
        relations: Optional[Mapping['types.AchievementRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AchievementKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Achievement_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Achievement_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Achievement_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Achievement_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Achievement_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Achievement_relational_fields:
                        raise errors.UnknownRelationalFieldError('Achievement', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Achievement / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Achievement',
            }
        )
        _created_partial_types.add(name)


class UserAchievement(bases.BaseUserAchievement):
    """Represents a UserAchievement record"""

    id: _int
    userId: _int
    achievementId: _int
    achievedAt: datetime.datetime
    user: Optional['models.User'] = None
    achievement: Optional['models.Achievement'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserAchievementKeys']] = None,
        exclude: Optional[Iterable['types.UserAchievementKeys']] = None,
        required: Optional[Iterable['types.UserAchievementKeys']] = None,
        optional: Optional[Iterable['types.UserAchievementKeys']] = None,
        relations: Optional[Mapping['types.UserAchievementRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserAchievementKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserAchievement_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserAchievement_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserAchievement_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserAchievement_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserAchievement_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserAchievement_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserAchievement', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserAchievement / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserAchievement',
            }
        )
        _created_partial_types.add(name)


class auth_group(bases.Baseauth_group):
    """Represents a auth_group record"""

    id: _int
    name: _str
    auth_group_permissions: Optional[List['models.auth_group_permissions']] = None
    users_user_groups: Optional[List['models.users_user_groups']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.auth_groupKeys']] = None,
        exclude: Optional[Iterable['types.auth_groupKeys']] = None,
        required: Optional[Iterable['types.auth_groupKeys']] = None,
        optional: Optional[Iterable['types.auth_groupKeys']] = None,
        relations: Optional[Mapping['types.auth_groupRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.auth_groupKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _auth_group_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _auth_group_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _auth_group_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _auth_group_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _auth_group_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _auth_group_relational_fields:
                        raise errors.UnknownRelationalFieldError('auth_group', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid auth_group / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'auth_group',
            }
        )
        _created_partial_types.add(name)


class auth_group_permissions(bases.Baseauth_group_permissions):
    """This model has constraints using non-default deferring rules and requires additional setup for migrations. Visit https://pris.ly/d/constraint-deferring for more info.
    """

    id: _int
    group_id: _int
    permission_id: _int
    auth_permission: Optional['models.auth_permission'] = None
    auth_group: Optional['models.auth_group'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.auth_group_permissionsKeys']] = None,
        exclude: Optional[Iterable['types.auth_group_permissionsKeys']] = None,
        required: Optional[Iterable['types.auth_group_permissionsKeys']] = None,
        optional: Optional[Iterable['types.auth_group_permissionsKeys']] = None,
        relations: Optional[Mapping['types.auth_group_permissionsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.auth_group_permissionsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _auth_group_permissions_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _auth_group_permissions_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _auth_group_permissions_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _auth_group_permissions_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _auth_group_permissions_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _auth_group_permissions_relational_fields:
                        raise errors.UnknownRelationalFieldError('auth_group_permissions', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid auth_group_permissions / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'auth_group_permissions',
            }
        )
        _created_partial_types.add(name)


class auth_permission(bases.Baseauth_permission):
    """This model has constraints using non-default deferring rules and requires additional setup for migrations. Visit https://pris.ly/d/constraint-deferring for more info.
    """

    id: _int
    name: _str
    content_type_id: _int
    codename: _str
    auth_group_permissions: Optional[List['models.auth_group_permissions']] = None
    django_content_type: Optional['models.django_content_type'] = None
    users_user_user_permissions: Optional[List['models.users_user_user_permissions']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.auth_permissionKeys']] = None,
        exclude: Optional[Iterable['types.auth_permissionKeys']] = None,
        required: Optional[Iterable['types.auth_permissionKeys']] = None,
        optional: Optional[Iterable['types.auth_permissionKeys']] = None,
        relations: Optional[Mapping['types.auth_permissionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.auth_permissionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _auth_permission_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _auth_permission_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _auth_permission_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _auth_permission_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _auth_permission_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _auth_permission_relational_fields:
                        raise errors.UnknownRelationalFieldError('auth_permission', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid auth_permission / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'auth_permission',
            }
        )
        _created_partial_types.add(name)


class authtoken_token(bases.Baseauthtoken_token):
    """This model has constraints using non-default deferring rules and requires additional setup for migrations. Visit https://pris.ly/d/constraint-deferring for more info.
    """

    key: _str
    created: datetime.datetime
    user_id: _int
    users_user: Optional['models.users_user'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.authtoken_tokenKeys']] = None,
        exclude: Optional[Iterable['types.authtoken_tokenKeys']] = None,
        required: Optional[Iterable['types.authtoken_tokenKeys']] = None,
        optional: Optional[Iterable['types.authtoken_tokenKeys']] = None,
        relations: Optional[Mapping['types.authtoken_tokenRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.authtoken_tokenKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _authtoken_token_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _authtoken_token_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _authtoken_token_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _authtoken_token_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _authtoken_token_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _authtoken_token_relational_fields:
                        raise errors.UnknownRelationalFieldError('authtoken_token', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid authtoken_token / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'authtoken_token',
            }
        )
        _created_partial_types.add(name)


class django_admin_log(bases.Basedjango_admin_log):
    """This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
    This model has constraints using non-default deferring rules and requires additional setup for migrations. Visit https://pris.ly/d/constraint-deferring for more info.
    """

    id: _int
    action_time: datetime.datetime
    object_id: Optional[_str] = None
    object_repr: _str
    action_flag: _int
    change_message: _str
    content_type_id: Optional[_int] = None
    user_id: _int
    django_content_type: Optional['models.django_content_type'] = None
    users_user: Optional['models.users_user'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.django_admin_logKeys']] = None,
        exclude: Optional[Iterable['types.django_admin_logKeys']] = None,
        required: Optional[Iterable['types.django_admin_logKeys']] = None,
        optional: Optional[Iterable['types.django_admin_logKeys']] = None,
        relations: Optional[Mapping['types.django_admin_logRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.django_admin_logKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _django_admin_log_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _django_admin_log_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _django_admin_log_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _django_admin_log_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _django_admin_log_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _django_admin_log_relational_fields:
                        raise errors.UnknownRelationalFieldError('django_admin_log', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid django_admin_log / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'django_admin_log',
            }
        )
        _created_partial_types.add(name)


class django_content_type(bases.Basedjango_content_type):
    """Represents a django_content_type record"""

    id: _int
    app_label: _str
    model: _str
    auth_permission: Optional[List['models.auth_permission']] = None
    django_admin_log: Optional[List['models.django_admin_log']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.django_content_typeKeys']] = None,
        exclude: Optional[Iterable['types.django_content_typeKeys']] = None,
        required: Optional[Iterable['types.django_content_typeKeys']] = None,
        optional: Optional[Iterable['types.django_content_typeKeys']] = None,
        relations: Optional[Mapping['types.django_content_typeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.django_content_typeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _django_content_type_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _django_content_type_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _django_content_type_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _django_content_type_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _django_content_type_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _django_content_type_relational_fields:
                        raise errors.UnknownRelationalFieldError('django_content_type', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid django_content_type / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'django_content_type',
            }
        )
        _created_partial_types.add(name)


class django_migrations(bases.Basedjango_migrations):
    """Represents a django_migrations record"""

    id: _int
    app: _str
    name: _str
    applied: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.django_migrationsKeys']] = None,
        exclude: Optional[Iterable['types.django_migrationsKeys']] = None,
        required: Optional[Iterable['types.django_migrationsKeys']] = None,
        optional: Optional[Iterable['types.django_migrationsKeys']] = None,
        relations: Optional[Mapping['types.django_migrationsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.django_migrationsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _django_migrations_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _django_migrations_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _django_migrations_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _django_migrations_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "django_migrations" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid django_migrations / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'django_migrations',
            }
        )
        _created_partial_types.add(name)


class django_session(bases.Basedjango_session):
    """Represents a django_session record"""

    session_key: _str
    session_data: _str
    expire_date: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.django_sessionKeys']] = None,
        exclude: Optional[Iterable['types.django_sessionKeys']] = None,
        required: Optional[Iterable['types.django_sessionKeys']] = None,
        optional: Optional[Iterable['types.django_sessionKeys']] = None,
        relations: Optional[Mapping['types.django_sessionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.django_sessionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _django_session_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _django_session_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _django_session_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _django_session_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "django_session" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid django_session / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'django_session',
            }
        )
        _created_partial_types.add(name)


class token_blacklist_blacklistedtoken(bases.Basetoken_blacklist_blacklistedtoken):
    """This model has constraints using non-default deferring rules and requires additional setup for migrations. Visit https://pris.ly/d/constraint-deferring for more info.
    """

    id: _int
    blacklisted_at: datetime.datetime
    token_id: _int
    token_blacklist_outstandingtoken: Optional['models.token_blacklist_outstandingtoken'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.token_blacklist_blacklistedtokenKeys']] = None,
        exclude: Optional[Iterable['types.token_blacklist_blacklistedtokenKeys']] = None,
        required: Optional[Iterable['types.token_blacklist_blacklistedtokenKeys']] = None,
        optional: Optional[Iterable['types.token_blacklist_blacklistedtokenKeys']] = None,
        relations: Optional[Mapping['types.token_blacklist_blacklistedtokenRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.token_blacklist_blacklistedtokenKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _token_blacklist_blacklistedtoken_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _token_blacklist_blacklistedtoken_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _token_blacklist_blacklistedtoken_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _token_blacklist_blacklistedtoken_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _token_blacklist_blacklistedtoken_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _token_blacklist_blacklistedtoken_relational_fields:
                        raise errors.UnknownRelationalFieldError('token_blacklist_blacklistedtoken', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid token_blacklist_blacklistedtoken / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'token_blacklist_blacklistedtoken',
            }
        )
        _created_partial_types.add(name)


class token_blacklist_outstandingtoken(bases.Basetoken_blacklist_outstandingtoken):
    """This model has constraints using non-default deferring rules and requires additional setup for migrations. Visit https://pris.ly/d/constraint-deferring for more info.
    """

    id: _int
    token: _str
    created_at: Optional[datetime.datetime] = None
    expires_at: datetime.datetime
    user_id: Optional[_int] = None
    jti: _str
    token_blacklist_blacklistedtoken: Optional['models.token_blacklist_blacklistedtoken'] = None
    users_user: Optional['models.users_user'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.token_blacklist_outstandingtokenKeys']] = None,
        exclude: Optional[Iterable['types.token_blacklist_outstandingtokenKeys']] = None,
        required: Optional[Iterable['types.token_blacklist_outstandingtokenKeys']] = None,
        optional: Optional[Iterable['types.token_blacklist_outstandingtokenKeys']] = None,
        relations: Optional[Mapping['types.token_blacklist_outstandingtokenRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.token_blacklist_outstandingtokenKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _token_blacklist_outstandingtoken_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _token_blacklist_outstandingtoken_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _token_blacklist_outstandingtoken_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _token_blacklist_outstandingtoken_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _token_blacklist_outstandingtoken_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _token_blacklist_outstandingtoken_relational_fields:
                        raise errors.UnknownRelationalFieldError('token_blacklist_outstandingtoken', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid token_blacklist_outstandingtoken / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'token_blacklist_outstandingtoken',
            }
        )
        _created_partial_types.add(name)


class users_user(bases.Baseusers_user):
    """Represents a users_user record"""

    id: _int
    password: _str
    last_login: Optional[datetime.datetime] = None
    is_superuser: _bool
    username: _str
    first_name: _str
    last_name: _str
    is_staff: _bool
    is_active: _bool
    date_joined: datetime.datetime
    email: _str
    is_premium: _bool
    premium_expiration_date: Optional[datetime.datetime] = None
    hide_ads: _bool
    avatar: Optional[_str] = None
    about: Optional[_str] = None
    authtoken_token: Optional['models.authtoken_token'] = None
    django_admin_log: Optional[List['models.django_admin_log']] = None
    token_blacklist_outstandingtoken: Optional[List['models.token_blacklist_outstandingtoken']] = None
    users_user_groups: Optional[List['models.users_user_groups']] = None
    users_user_user_permissions: Optional[List['models.users_user_user_permissions']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.users_userKeys']] = None,
        exclude: Optional[Iterable['types.users_userKeys']] = None,
        required: Optional[Iterable['types.users_userKeys']] = None,
        optional: Optional[Iterable['types.users_userKeys']] = None,
        relations: Optional[Mapping['types.users_userRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.users_userKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _users_user_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _users_user_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _users_user_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _users_user_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _users_user_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _users_user_relational_fields:
                        raise errors.UnknownRelationalFieldError('users_user', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid users_user / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'users_user',
            }
        )
        _created_partial_types.add(name)


class users_user_groups(bases.Baseusers_user_groups):
    """This model has constraints using non-default deferring rules and requires additional setup for migrations. Visit https://pris.ly/d/constraint-deferring for more info.
    """

    id: _int
    user_id: _int
    group_id: _int
    auth_group: Optional['models.auth_group'] = None
    users_user: Optional['models.users_user'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.users_user_groupsKeys']] = None,
        exclude: Optional[Iterable['types.users_user_groupsKeys']] = None,
        required: Optional[Iterable['types.users_user_groupsKeys']] = None,
        optional: Optional[Iterable['types.users_user_groupsKeys']] = None,
        relations: Optional[Mapping['types.users_user_groupsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.users_user_groupsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _users_user_groups_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _users_user_groups_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _users_user_groups_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _users_user_groups_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _users_user_groups_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _users_user_groups_relational_fields:
                        raise errors.UnknownRelationalFieldError('users_user_groups', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid users_user_groups / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'users_user_groups',
            }
        )
        _created_partial_types.add(name)


class users_user_user_permissions(bases.Baseusers_user_user_permissions):
    """This model has constraints using non-default deferring rules and requires additional setup for migrations. Visit https://pris.ly/d/constraint-deferring for more info.
    """

    id: _int
    user_id: _int
    permission_id: _int
    auth_permission: Optional['models.auth_permission'] = None
    users_user: Optional['models.users_user'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.users_user_user_permissionsKeys']] = None,
        exclude: Optional[Iterable['types.users_user_user_permissionsKeys']] = None,
        required: Optional[Iterable['types.users_user_user_permissionsKeys']] = None,
        optional: Optional[Iterable['types.users_user_user_permissionsKeys']] = None,
        relations: Optional[Mapping['types.users_user_user_permissionsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.users_user_user_permissionsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _users_user_user_permissions_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _users_user_user_permissions_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _users_user_user_permissions_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _users_user_user_permissions_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _users_user_user_permissions_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _users_user_user_permissions_relational_fields:
                        raise errors.UnknownRelationalFieldError('users_user_user_permissions', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid users_user_user_permissions / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'users_user_user_permissions',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'groups',
        'permissions',
        'tokens',
        'sessions',
        'notifications',
        'readingProgress',
        'userBooks',
        'votes',
        'leaderResults',
        'userAchievements',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('passwordHash', {
            'name': 'passwordHash',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isPremium', {
            'name': 'isPremium',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('premiumExpirationDate', {
            'name': 'premiumExpirationDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('hideAds', {
            'name': 'hideAds',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('registrationDate', {
            'name': 'registrationDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('about', {
            'name': 'about',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('avatar', {
            'name': 'avatar',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isStaff', {
            'name': 'isStaff',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isSuperuser', {
            'name': 'isSuperuser',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastLogin', {
            'name': 'lastLogin',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('groups', {
            'name': 'groups',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserGroup\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('permissions', {
            'name': 'permissions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserPermission\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('tokens', {
            'name': 'tokens',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Token\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('sessions', {
            'name': 'sessions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Session\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('notifications', {
            'name': 'notifications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Notification\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('readingProgress', {
            'name': 'readingProgress',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ReadingProgress\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('userBooks', {
            'name': 'userBooks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserBook\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('votes', {
            'name': 'votes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Vote\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('leaderResults', {
            'name': 'leaderResults',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WeeklyResult\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('userAchievements', {
            'name': 'userAchievements',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserAchievement\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Group_relational_fields: Set[str] = {
        'users',
        'permissions',
    }
_Group_fields: Dict['types.GroupKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserGroup\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('permissions', {
            'name': 'permissions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.GroupPermission\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Permission_relational_fields: Set[str] = {
        'users',
        'groups',
    }
_Permission_fields: Dict['types.PermissionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('codename', {
            'name': 'codename',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserPermission\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('groups', {
            'name': 'groups',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.GroupPermission\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserGroup_relational_fields: Set[str] = {
        'user',
        'group',
    }
_UserGroup_fields: Dict['types.UserGroupKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('groupId', {
            'name': 'groupId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('group', {
            'name': 'group',
            'is_list': False,
            'optional': True,
            'type': 'models.Group',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserPermission_relational_fields: Set[str] = {
        'user',
        'permission',
    }
_UserPermission_fields: Dict['types.UserPermissionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('permissionId', {
            'name': 'permissionId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('permission', {
            'name': 'permission',
            'is_list': False,
            'optional': True,
            'type': 'models.Permission',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_GroupPermission_relational_fields: Set[str] = {
        'group',
        'permission',
    }
_GroupPermission_fields: Dict['types.GroupPermissionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('groupId', {
            'name': 'groupId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('permissionId', {
            'name': 'permissionId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('group', {
            'name': 'group',
            'is_list': False,
            'optional': True,
            'type': 'models.Group',
            'is_relational': True,
            'documentation': None,
        }),
        ('permission', {
            'name': 'permission',
            'is_list': False,
            'optional': True,
            'type': 'models.Permission',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Token_relational_fields: Set[str] = {
        'user',
    }
_Token_fields: Dict['types.TokenKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('token', {
            'name': 'token',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiresAt', {
            'name': 'expiresAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Session_relational_fields: Set[str] = {
        'user',
    }
_Session_fields: Dict['types.SessionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sessionKey', {
            'name': 'sessionKey',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiresAt', {
            'name': 'expiresAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Genre_relational_fields: Set[str] = {
        'books',
        'parent',
        'subgenres',
        'weeklyResults',
    }
_Genre_fields: Dict['types.GenreKeys', PartialModelField] = OrderedDict(
    [
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('parentId', {
            'name': 'parentId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('books', {
            'name': 'books',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Book\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('parent', {
            'name': 'parent',
            'is_list': False,
            'optional': True,
            'type': 'models.Genre',
            'is_relational': True,
            'documentation': None,
        }),
        ('subgenres', {
            'name': 'subgenres',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Genre\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('weeklyResults', {
            'name': 'weeklyResults',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WeeklyResult\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AgeCategory_relational_fields: Set[str] = {
        'books',
        'weeklyResults',
    }
_AgeCategory_fields: Dict['types.AgeCategoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('books', {
            'name': 'books',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Book\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('weeklyResults', {
            'name': 'weeklyResults',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WeeklyResult\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Author_relational_fields: Set[str] = {
        'books',
    }
_Author_fields: Dict['types.AuthorKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('books', {
            'name': 'books',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Book\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Book_relational_fields: Set[str] = {
        'author',
        'ageCategory',
        'genre',
        'readingProgress',
        'userBooks',
        'votes',
        'weeklyResults',
    }
_Book_fields: Dict['types.BookKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('authorId', {
            'name': 'authorId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('author', {
            'name': 'author',
            'is_list': False,
            'optional': True,
            'type': 'models.Author',
            'is_relational': True,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('coverUrl', {
            'name': 'coverUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('externalId', {
            'name': 'externalId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ageCategoryId', {
            'name': 'ageCategoryId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rating', {
            'name': 'rating',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('rating_count', {
            'name': 'rating_count',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('isPremium', {
            'name': 'isPremium',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('litresRating', {
            'name': 'litresRating',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('litresRatingCount', {
            'name': 'litresRatingCount',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('series', {
            'name': 'series',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('translator', {
            'name': 'translator',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('volume', {
            'name': 'volume',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('year', {
            'name': 'year',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isbn', {
            'name': 'isbn',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('copyrightHolder', {
            'name': 'copyrightHolder',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('genreId', {
            'name': 'genreId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('ageCategory', {
            'name': 'ageCategory',
            'is_list': False,
            'optional': True,
            'type': 'models.AgeCategory',
            'is_relational': True,
            'documentation': None,
        }),
        ('genre', {
            'name': 'genre',
            'is_list': False,
            'optional': True,
            'type': 'models.Genre',
            'is_relational': True,
            'documentation': None,
        }),
        ('readingProgress', {
            'name': 'readingProgress',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ReadingProgress\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('userBooks', {
            'name': 'userBooks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserBook\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('votes', {
            'name': 'votes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Vote\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('weeklyResults', {
            'name': 'weeklyResults',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WeeklyResult\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserBook_relational_fields: Set[str] = {
        'book',
        'user',
    }
_UserBook_fields: Dict['types.UserBookKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('bookId', {
            'name': 'bookId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rating', {
            'name': 'rating',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('addedAt', {
            'name': 'addedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('book', {
            'name': 'book',
            'is_list': False,
            'optional': True,
            'type': 'models.Book',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Vote_relational_fields: Set[str] = {
        'book',
        'user',
    }
_Vote_fields: Dict['types.VoteKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('bookId', {
            'name': 'bookId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('weekNumber', {
            'name': 'weekNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('voteDate', {
            'name': 'voteDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('book', {
            'name': 'book',
            'is_list': False,
            'optional': True,
            'type': 'models.Book',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ReadingProgress_relational_fields: Set[str] = {
        'book',
        'user',
    }
_ReadingProgress_fields: Dict['types.ReadingProgressKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('bookId', {
            'name': 'bookId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('weekNumber', {
            'name': 'weekNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('marks', {
            'name': 'marks',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('progressDate', {
            'name': 'progressDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('book', {
            'name': 'book',
            'is_list': False,
            'optional': True,
            'type': 'models.Book',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_WeeklyResult_relational_fields: Set[str] = {
        'ageCategory',
        'book',
        'genre',
        'leader',
    }
_WeeklyResult_fields: Dict['types.WeeklyResultKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('weekNumber', {
            'name': 'weekNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('ageCategoryId', {
            'name': 'ageCategoryId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('bookId', {
            'name': 'bookId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('leaderUserId', {
            'name': 'leaderUserId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalMarks', {
            'name': 'totalMarks',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('genreId', {
            'name': 'genreId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('ageCategory', {
            'name': 'ageCategory',
            'is_list': False,
            'optional': True,
            'type': 'models.AgeCategory',
            'is_relational': True,
            'documentation': None,
        }),
        ('book', {
            'name': 'book',
            'is_list': False,
            'optional': True,
            'type': 'models.Book',
            'is_relational': True,
            'documentation': None,
        }),
        ('genre', {
            'name': 'genre',
            'is_list': False,
            'optional': True,
            'type': 'models.Genre',
            'is_relational': True,
            'documentation': None,
        }),
        ('leader', {
            'name': 'leader',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Notification_relational_fields: Set[str] = {
        'user',
    }
_Notification_fields: Dict['types.NotificationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('message', {
            'name': 'message',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sentDate', {
            'name': 'sentDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Advertisement_relational_fields: Set[str] = {
        'partner',
    }
_Advertisement_fields: Dict['types.AdvertisementKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('partnerId', {
            'name': 'partnerId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('partner', {
            'name': 'partner',
            'is_list': False,
            'optional': True,
            'type': 'models.Partner',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Partner_relational_fields: Set[str] = {
        'advertisements',
    }
_Partner_fields: Dict['types.PartnerKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('contactInfo', {
            'name': 'contactInfo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('advertisements', {
            'name': 'advertisements',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Advertisement\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Achievement_relational_fields: Set[str] = {
        'userAchievements',
    }
_Achievement_fields: Dict['types.AchievementKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('criteria', {
            'name': 'criteria',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('reward', {
            'name': 'reward',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('userAchievements', {
            'name': 'userAchievements',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserAchievement\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserAchievement_relational_fields: Set[str] = {
        'user',
        'achievement',
    }
_UserAchievement_fields: Dict['types.UserAchievementKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('achievementId', {
            'name': 'achievementId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('achievedAt', {
            'name': 'achievedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('achievement', {
            'name': 'achievement',
            'is_list': False,
            'optional': True,
            'type': 'models.Achievement',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_auth_group_relational_fields: Set[str] = {
        'auth_group_permissions',
        'users_user_groups',
    }
_auth_group_fields: Dict['types.auth_groupKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('auth_group_permissions', {
            'name': 'auth_group_permissions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.auth_group_permissions\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('users_user_groups', {
            'name': 'users_user_groups',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.users_user_groups\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_auth_group_permissions_relational_fields: Set[str] = {
        'auth_permission',
        'auth_group',
    }
_auth_group_permissions_fields: Dict['types.auth_group_permissionsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('group_id', {
            'name': 'group_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('permission_id', {
            'name': 'permission_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('auth_permission', {
            'name': 'auth_permission',
            'is_list': False,
            'optional': True,
            'type': 'models.auth_permission',
            'is_relational': True,
            'documentation': None,
        }),
        ('auth_group', {
            'name': 'auth_group',
            'is_list': False,
            'optional': True,
            'type': 'models.auth_group',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_auth_permission_relational_fields: Set[str] = {
        'auth_group_permissions',
        'django_content_type',
        'users_user_user_permissions',
    }
_auth_permission_fields: Dict['types.auth_permissionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content_type_id', {
            'name': 'content_type_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('codename', {
            'name': 'codename',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('auth_group_permissions', {
            'name': 'auth_group_permissions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.auth_group_permissions\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('django_content_type', {
            'name': 'django_content_type',
            'is_list': False,
            'optional': True,
            'type': 'models.django_content_type',
            'is_relational': True,
            'documentation': None,
        }),
        ('users_user_user_permissions', {
            'name': 'users_user_user_permissions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.users_user_user_permissions\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_authtoken_token_relational_fields: Set[str] = {
        'users_user',
    }
_authtoken_token_fields: Dict['types.authtoken_tokenKeys', PartialModelField] = OrderedDict(
    [
        ('key', {
            'name': 'key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created', {
            'name': 'created',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('users_user', {
            'name': 'users_user',
            'is_list': False,
            'optional': True,
            'type': 'models.users_user',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_django_admin_log_relational_fields: Set[str] = {
        'django_content_type',
        'users_user',
    }
_django_admin_log_fields: Dict['types.django_admin_logKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('action_time', {
            'name': 'action_time',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('object_id', {
            'name': 'object_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('object_repr', {
            'name': 'object_repr',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('action_flag', {
            'name': 'action_flag',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('change_message', {
            'name': 'change_message',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content_type_id', {
            'name': 'content_type_id',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('django_content_type', {
            'name': 'django_content_type',
            'is_list': False,
            'optional': True,
            'type': 'models.django_content_type',
            'is_relational': True,
            'documentation': None,
        }),
        ('users_user', {
            'name': 'users_user',
            'is_list': False,
            'optional': True,
            'type': 'models.users_user',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_django_content_type_relational_fields: Set[str] = {
        'auth_permission',
        'django_admin_log',
    }
_django_content_type_fields: Dict['types.django_content_typeKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('app_label', {
            'name': 'app_label',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model', {
            'name': 'model',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('auth_permission', {
            'name': 'auth_permission',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.auth_permission\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('django_admin_log', {
            'name': 'django_admin_log',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.django_admin_log\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_django_migrations_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_django_migrations_fields: Dict['types.django_migrationsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('app', {
            'name': 'app',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('applied', {
            'name': 'applied',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_django_session_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_django_session_fields: Dict['types.django_sessionKeys', PartialModelField] = OrderedDict(
    [
        ('session_key', {
            'name': 'session_key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('session_data', {
            'name': 'session_data',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expire_date', {
            'name': 'expire_date',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_token_blacklist_blacklistedtoken_relational_fields: Set[str] = {
        'token_blacklist_outstandingtoken',
    }
_token_blacklist_blacklistedtoken_fields: Dict['types.token_blacklist_blacklistedtokenKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('blacklisted_at', {
            'name': 'blacklisted_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('token_id', {
            'name': 'token_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('token_blacklist_outstandingtoken', {
            'name': 'token_blacklist_outstandingtoken',
            'is_list': False,
            'optional': True,
            'type': 'models.token_blacklist_outstandingtoken',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_token_blacklist_outstandingtoken_relational_fields: Set[str] = {
        'token_blacklist_blacklistedtoken',
        'users_user',
    }
_token_blacklist_outstandingtoken_fields: Dict['types.token_blacklist_outstandingtokenKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('token', {
            'name': 'token',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('expires_at', {
            'name': 'expires_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('jti', {
            'name': 'jti',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('token_blacklist_blacklistedtoken', {
            'name': 'token_blacklist_blacklistedtoken',
            'is_list': False,
            'optional': True,
            'type': 'models.token_blacklist_blacklistedtoken',
            'is_relational': True,
            'documentation': None,
        }),
        ('users_user', {
            'name': 'users_user',
            'is_list': False,
            'optional': True,
            'type': 'models.users_user',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_users_user_relational_fields: Set[str] = {
        'authtoken_token',
        'django_admin_log',
        'token_blacklist_outstandingtoken',
        'users_user_groups',
        'users_user_user_permissions',
    }
_users_user_fields: Dict['types.users_userKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_login', {
            'name': 'last_login',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_superuser', {
            'name': 'is_superuser',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('first_name', {
            'name': 'first_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_name', {
            'name': 'last_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_staff', {
            'name': 'is_staff',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_active', {
            'name': 'is_active',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('date_joined', {
            'name': 'date_joined',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_premium', {
            'name': 'is_premium',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('premium_expiration_date', {
            'name': 'premium_expiration_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('hide_ads', {
            'name': 'hide_ads',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('avatar', {
            'name': 'avatar',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('about', {
            'name': 'about',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('authtoken_token', {
            'name': 'authtoken_token',
            'is_list': False,
            'optional': True,
            'type': 'models.authtoken_token',
            'is_relational': True,
            'documentation': None,
        }),
        ('django_admin_log', {
            'name': 'django_admin_log',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.django_admin_log\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('token_blacklist_outstandingtoken', {
            'name': 'token_blacklist_outstandingtoken',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.token_blacklist_outstandingtoken\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('users_user_groups', {
            'name': 'users_user_groups',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.users_user_groups\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('users_user_user_permissions', {
            'name': 'users_user_user_permissions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.users_user_user_permissions\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_users_user_groups_relational_fields: Set[str] = {
        'auth_group',
        'users_user',
    }
_users_user_groups_fields: Dict['types.users_user_groupsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('group_id', {
            'name': 'group_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('auth_group', {
            'name': 'auth_group',
            'is_list': False,
            'optional': True,
            'type': 'models.auth_group',
            'is_relational': True,
            'documentation': None,
        }),
        ('users_user', {
            'name': 'users_user',
            'is_list': False,
            'optional': True,
            'type': 'models.users_user',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_users_user_user_permissions_relational_fields: Set[str] = {
        'auth_permission',
        'users_user',
    }
_users_user_user_permissions_fields: Dict['types.users_user_user_permissionsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('permission_id', {
            'name': 'permission_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('auth_permission', {
            'name': 'auth_permission',
            'is_list': False,
            'optional': True,
            'type': 'models.auth_permission',
            'is_relational': True,
            'documentation': None,
        }),
        ('users_user', {
            'name': 'users_user',
            'is_list': False,
            'optional': True,
            'type': 'models.users_user',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(Group)
model_rebuild(Permission)
model_rebuild(UserGroup)
model_rebuild(UserPermission)
model_rebuild(GroupPermission)
model_rebuild(Token)
model_rebuild(Session)
model_rebuild(Genre)
model_rebuild(AgeCategory)
model_rebuild(Author)
model_rebuild(Book)
model_rebuild(UserBook)
model_rebuild(Vote)
model_rebuild(ReadingProgress)
model_rebuild(WeeklyResult)
model_rebuild(Notification)
model_rebuild(Advertisement)
model_rebuild(Partner)
model_rebuild(Achievement)
model_rebuild(UserAchievement)
model_rebuild(auth_group)
model_rebuild(auth_group_permissions)
model_rebuild(auth_permission)
model_rebuild(authtoken_token)
model_rebuild(django_admin_log)
model_rebuild(django_content_type)
model_rebuild(django_migrations)
model_rebuild(django_session)
model_rebuild(token_blacklist_blacklistedtoken)
model_rebuild(token_blacklist_outstandingtoken)
model_rebuild(users_user)
model_rebuild(users_user_groups)
model_rebuild(users_user_user_permissions)
