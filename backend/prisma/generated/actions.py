# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
                'username': 'bbehjachib',
                'passwordHash': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'dgiiaaijj',
                    'username': 'bfaiacjjfc',
                    'passwordHash': 'eigcfgbif',
                },
                {
                    # data to create a User record
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'passwordHash': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 836760821,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 595337866,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 790425851,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the username field
        users = await User.prisma().find_many(
            take=5,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the passwordHash field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'passwordHash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the isPremium field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'isPremium': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 2111915288,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 1149758321,
            },
            data={
                'create': {
                    'id': 1149758321,
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'passwordHash': 'biabhbdai',
                },
                'update': {
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'passwordHash': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'premiumExpirationDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'hideAds': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by updatedAt values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GenreActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Genre]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Genre.prisma().query_raw(
            'SELECT * FROM Genre WHERE name = $1',
            'bgeecijdgg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Genre
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Genre.prisma().query_first(
            'SELECT * FROM Genre WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GenreCreateInput,
        include: Optional[types.GenreInclude] = None
    ) -> _PrismaModelT:
        """Create a new Genre record.

        Parameters
        ----------
        data
            Genre record data
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The created Genre record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Genre record from just the required fields
        genre = await Genre.prisma().create(
            data={
                # data to create a Genre record
                'name': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GenreCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Genre records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Genre record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Genre.prisma().create_many(
            data=[
                {
                    # data to create a Genre record
                    'name': 'bgehebiafc',
                },
                {
                    # data to create a Genre record
                    'name': 'bghffegacj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Genre record.

        Parameters
        ----------
        where
            Genre filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The deleted Genre record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().delete(
            where={
                'id': 1767274722,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Genre record.

        Parameters
        ----------
        where
            Genre filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The found Genre record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().find_unique(
            where={
                'id': 326272115,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Genre record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Genre filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The found Genre record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().find_unique_or_raise(
            where={
                'id': 1343201072,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
        include: Optional[types.GenreInclude] = None,
        order: Optional[Union[types.GenreOrderByInput, List[types.GenreOrderByInput]]] = None,
        distinct: Optional[List[types.GenreScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Genre records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Genre records returned
        skip
            Ignore the first N results
        where
            Genre filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Genre model
        order
            Order the returned Genre records by any field
        distinct
            Filter Genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Genre]
            The list of all Genre records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Genre records
        genres = await Genre.prisma().find_many(take=10)

        # find the first 5 Genre records ordered by the updatedAt field
        genres = await Genre.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
        include: Optional[types.GenreInclude] = None,
        order: Optional[Union[types.GenreOrderByInput, List[types.GenreOrderByInput]]] = None,
        distinct: Optional[List[types.GenreScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Genre record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Genre filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Genre model
        order
            Order the returned Genre records by any field
        distinct
            Filter Genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Genre
            The first Genre record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Genre record ordered by the id field
        genre = await Genre.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
        include: Optional[types.GenreInclude] = None,
        order: Optional[Union[types.GenreOrderByInput, List[types.GenreOrderByInput]]] = None,
        distinct: Optional[List[types.GenreScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Genre record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Genre filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Genre model
        order
            Order the returned Genre records by any field
        distinct
            Filter Genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Genre
            The first Genre record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Genre record ordered by the parentId field
        genre = await Genre.prisma().find_first_or_raise(
            skip=1,
            order={
                'parentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GenreUpdateInput,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Genre record.

        Parameters
        ----------
        data
            Genre record data specifying what to update
        where
            Genre filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The updated Genre record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        genre = await Genre.prisma().update(
            where={
                'id': 675780521,
            },
            data={
                # data to update the Genre record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GenreWhereUniqueInput,
        data: types.GenreUpsertInput,
        include: Optional[types.GenreInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Genre filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The created or updated Genre record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().upsert(
            where={
                'id': 744964398,
            },
            data={
                'create': {
                    'id': 744964398,
                    'name': 'bghffegacj',
                },
                'update': {
                    'name': 'bghffegacj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GenreUpdateManyMutationInput,
        where: types.GenreWhereInput,
    ) -> int:
        """Update multiple Genre records

        Parameters
        ----------
        data
            Genre data to update the selected Genre records to
        where
            Filter to select the Genre records to update

        Returns
        -------
        int
            The total number of Genre records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Genre records
        total = await Genre.prisma().update_many(
            data={
                'name': 'bjgjgibgbf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Genre records present in the database

        Parameters
        ----------
        select
            Select the Genre fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Genre filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GenreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Genre.prisma().count()

        # results: prisma.types.GenreCountAggregateOutput
        results = await Genre.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GenreCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
    ) -> types.GenreCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GenreCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
    ) -> Union[int, types.GenreCountAggregateOutput]:
        """Count the number of Genre records present in the database

        Parameters
        ----------
        select
            Select the Genre fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Genre filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GenreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Genre.prisma().count()

        # results: prisma.types.GenreCountAggregateOutput
        results = await Genre.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GenreCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GenreWhereInput] = None
    ) -> int:
        """Delete multiple Genre records.

        Parameters
        ----------
        where
            Optional Genre filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Genre records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Genre records
        total = await Genre.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GenreScalarFieldKeys'],
        *,
        where: Optional['types.GenreWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GenreAvgAggregateInput'] = None,
        sum: Optional['types.GenreSumAggregateInput'] = None,
        min: Optional['types.GenreMinAggregateInput'] = None,
        max: Optional['types.GenreMaxAggregateInput'] = None,
        having: Optional['types.GenreScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GenreCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GenreScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GenreScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GenreGroupByOutput']:
        """Group Genre records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Genre fields to group records by
        where
            Genre filter to select records
        take
            Limit the maximum number of Genre records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GenreGroupByOutput]
            A list of dictionaries representing the Genre record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Genre records by id values
        # and count how many records are in each group
        results = await Genre.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AgeCategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AgeCategory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AgeCategory.prisma().query_raw(
            'SELECT * FROM AgeCategory WHERE id = $1',
            1116175964,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AgeCategory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AgeCategory.prisma().query_first(
            'SELECT * FROM AgeCategory WHERE name = $1',
            'igbehcbab',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AgeCategoryCreateInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new AgeCategory record.

        Parameters
        ----------
        data
            AgeCategory record data
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The created AgeCategory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AgeCategory record from just the required fields
        agecategory = await AgeCategory.prisma().create(
            data={
                # data to create a AgeCategory record
                'name': 'bdadaadhag',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AgeCategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AgeCategory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AgeCategory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AgeCategory.prisma().create_many(
            data=[
                {
                    # data to create a AgeCategory record
                    'name': 'bgiggdidbf',
                },
                {
                    # data to create a AgeCategory record
                    'name': 'caaaedabfc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AgeCategory record.

        Parameters
        ----------
        where
            AgeCategory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The deleted AgeCategory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().delete(
            where={
                'id': 1868141281,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AgeCategory record.

        Parameters
        ----------
        where
            AgeCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The found AgeCategory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().find_unique(
            where={
                'id': 1860847622,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AgeCategory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AgeCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The found AgeCategory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().find_unique_or_raise(
            where={
                'id': 1448521415,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
        include: Optional[types.AgeCategoryInclude] = None,
        order: Optional[Union[types.AgeCategoryOrderByInput, List[types.AgeCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.AgeCategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AgeCategory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AgeCategory records returned
        skip
            Ignore the first N results
        where
            AgeCategory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgeCategory model
        order
            Order the returned AgeCategory records by any field
        distinct
            Filter AgeCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AgeCategory]
            The list of all AgeCategory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AgeCategory records
        agecategorys = await AgeCategory.prisma().find_many(take=10)

        # find the first 5 AgeCategory records ordered by the id field
        agecategorys = await AgeCategory.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
        include: Optional[types.AgeCategoryInclude] = None,
        order: Optional[Union[types.AgeCategoryOrderByInput, List[types.AgeCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.AgeCategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AgeCategory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AgeCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgeCategory model
        order
            Order the returned AgeCategory records by any field
        distinct
            Filter AgeCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AgeCategory
            The first AgeCategory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AgeCategory record ordered by the name field
        agecategory = await AgeCategory.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
        include: Optional[types.AgeCategoryInclude] = None,
        order: Optional[Union[types.AgeCategoryOrderByInput, List[types.AgeCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.AgeCategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AgeCategory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AgeCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgeCategory model
        order
            Order the returned AgeCategory records by any field
        distinct
            Filter AgeCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AgeCategory
            The first AgeCategory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AgeCategory record ordered by the id field
        agecategory = await AgeCategory.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AgeCategoryUpdateInput,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AgeCategory record.

        Parameters
        ----------
        data
            AgeCategory record data specifying what to update
        where
            AgeCategory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The updated AgeCategory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().update(
            where={
                'id': 1628650740,
            },
            data={
                # data to update the AgeCategory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        data: types.AgeCategoryUpsertInput,
        include: Optional[types.AgeCategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AgeCategory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The created or updated AgeCategory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().upsert(
            where={
                'id': 1249606685,
            },
            data={
                'create': {
                    'id': 1249606685,
                    'name': 'caaaedabfc',
                },
                'update': {
                    'name': 'caaaedabfc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AgeCategoryUpdateManyMutationInput,
        where: types.AgeCategoryWhereInput,
    ) -> int:
        """Update multiple AgeCategory records

        Parameters
        ----------
        data
            AgeCategory data to update the selected AgeCategory records to
        where
            Filter to select the AgeCategory records to update

        Returns
        -------
        int
            The total number of AgeCategory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AgeCategory records
        total = await AgeCategory.prisma().update_many(
            data={
                'name': 'idfjadbcc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AgeCategory records present in the database

        Parameters
        ----------
        select
            Select the AgeCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AgeCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgeCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AgeCategory.prisma().count()

        # results: prisma.types.AgeCategoryCountAggregateOutput
        results = await AgeCategory.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AgeCategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
    ) -> types.AgeCategoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AgeCategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
    ) -> Union[int, types.AgeCategoryCountAggregateOutput]:
        """Count the number of AgeCategory records present in the database

        Parameters
        ----------
        select
            Select the AgeCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AgeCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgeCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AgeCategory.prisma().count()

        # results: prisma.types.AgeCategoryCountAggregateOutput
        results = await AgeCategory.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AgeCategoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AgeCategoryWhereInput] = None
    ) -> int:
        """Delete multiple AgeCategory records.

        Parameters
        ----------
        where
            Optional AgeCategory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AgeCategory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AgeCategory records
        total = await AgeCategory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AgeCategoryScalarFieldKeys'],
        *,
        where: Optional['types.AgeCategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AgeCategoryAvgAggregateInput'] = None,
        sum: Optional['types.AgeCategorySumAggregateInput'] = None,
        min: Optional['types.AgeCategoryMinAggregateInput'] = None,
        max: Optional['types.AgeCategoryMaxAggregateInput'] = None,
        having: Optional['types.AgeCategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AgeCategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AgeCategoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AgeCategoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AgeCategoryGroupByOutput']:
        """Group AgeCategory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AgeCategory fields to group records by
        where
            AgeCategory filter to select records
        take
            Limit the maximum number of AgeCategory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AgeCategoryGroupByOutput]
            A list of dictionaries representing the AgeCategory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AgeCategory records by id values
        # and count how many records are in each group
        results = await AgeCategory.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BookActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Book]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Book.prisma().query_raw(
            'SELECT * FROM Book WHERE id = $1',
            763719779,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Book
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Book.prisma().query_first(
            'SELECT * FROM Book WHERE title = $1',
            'ecjjjfbae',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BookCreateInput,
        include: Optional[types.BookInclude] = None
    ) -> _PrismaModelT:
        """Create a new Book record.

        Parameters
        ----------
        data
            Book record data
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The created Book record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Book record from just the required fields
        book = await Book.prisma().create(
            data={
                # data to create a Book record
                'title': 'bhhfibbigf',
                'author': 'ijdbeffgg',
                'ageCategoryId': 995405759,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BookCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Book records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Book record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Book.prisma().create_many(
            data=[
                {
                    # data to create a Book record
                    'title': 'cbachdgfce',
                    'author': 'chbfcacbd',
                    'ageCategoryId': 456633834,
                },
                {
                    # data to create a Book record
                    'title': 'caficfigfb',
                    'author': 'bfidgijfjc',
                    'ageCategoryId': 878442065,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Book record.

        Parameters
        ----------
        where
            Book filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The deleted Book record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().delete(
            where={
                'id': 1675280054,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Book record.

        Parameters
        ----------
        where
            Book filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The found Book record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().find_unique(
            where={
                'id': 1627576247,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Book record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Book filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The found Book record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().find_unique_or_raise(
            where={
                'id': 2054802212,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
        include: Optional[types.BookInclude] = None,
        order: Optional[Union[types.BookOrderByInput, List[types.BookOrderByInput]]] = None,
        distinct: Optional[List[types.BookScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Book records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Book records returned
        skip
            Ignore the first N results
        where
            Book filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Book model
        order
            Order the returned Book records by any field
        distinct
            Filter Book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Book]
            The list of all Book records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Book records
        books = await Book.prisma().find_many(take=10)

        # find the first 5 Book records ordered by the author field
        books = await Book.prisma().find_many(
            take=5,
            order={
                'author': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
        include: Optional[types.BookInclude] = None,
        order: Optional[Union[types.BookOrderByInput, List[types.BookOrderByInput]]] = None,
        distinct: Optional[List[types.BookScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Book record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Book filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Book model
        order
            Order the returned Book records by any field
        distinct
            Filter Book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Book
            The first Book record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Book record ordered by the description field
        book = await Book.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
        include: Optional[types.BookInclude] = None,
        order: Optional[Union[types.BookOrderByInput, List[types.BookOrderByInput]]] = None,
        distinct: Optional[List[types.BookScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Book record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Book filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Book model
        order
            Order the returned Book records by any field
        distinct
            Filter Book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Book
            The first Book record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Book record ordered by the coverUrl field
        book = await Book.prisma().find_first_or_raise(
            skip=1,
            order={
                'coverUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BookUpdateInput,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Book record.

        Parameters
        ----------
        data
            Book record data specifying what to update
        where
            Book filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The updated Book record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        book = await Book.prisma().update(
            where={
                'id': 60335757,
            },
            data={
                # data to update the Book record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BookWhereUniqueInput,
        data: types.BookUpsertInput,
        include: Optional[types.BookInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Book filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The created or updated Book record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().upsert(
            where={
                'id': 684462146,
            },
            data={
                'create': {
                    'id': 684462146,
                    'title': 'caficfigfb',
                    'author': 'bfidgijfjc',
                    'ageCategoryId': 878442065,
                },
                'update': {
                    'title': 'caficfigfb',
                    'author': 'bfidgijfjc',
                    'ageCategoryId': 878442065,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BookUpdateManyMutationInput,
        where: types.BookWhereInput,
    ) -> int:
        """Update multiple Book records

        Parameters
        ----------
        data
            Book data to update the selected Book records to
        where
            Filter to select the Book records to update

        Returns
        -------
        int
            The total number of Book records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Book records
        total = await Book.prisma().update_many(
            data={
                'externalId': 'bgcffadich'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Book records present in the database

        Parameters
        ----------
        select
            Select the Book fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Book filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Book.prisma().count()

        # results: prisma.types.BookCountAggregateOutput
        results = await Book.prisma().count(
            select={
                '_all': True,
                'ageCategoryId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BookCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
    ) -> types.BookCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BookCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
    ) -> Union[int, types.BookCountAggregateOutput]:
        """Count the number of Book records present in the database

        Parameters
        ----------
        select
            Select the Book fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Book filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Book.prisma().count()

        # results: prisma.types.BookCountAggregateOutput
        results = await Book.prisma().count(
            select={
                '_all': True,
                'rating': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BookCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BookWhereInput] = None
    ) -> int:
        """Delete multiple Book records.

        Parameters
        ----------
        where
            Optional Book filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Book records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Book records
        total = await Book.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BookScalarFieldKeys'],
        *,
        where: Optional['types.BookWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BookAvgAggregateInput'] = None,
        sum: Optional['types.BookSumAggregateInput'] = None,
        min: Optional['types.BookMinAggregateInput'] = None,
        max: Optional['types.BookMaxAggregateInput'] = None,
        having: Optional['types.BookScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BookCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BookScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BookScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BookGroupByOutput']:
        """Group Book records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Book fields to group records by
        where
            Book filter to select records
        take
            Limit the maximum number of Book records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BookGroupByOutput]
            A list of dictionaries representing the Book record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Book records by rating_count values
        # and count how many records are in each group
        results = await Book.prisma().group_by(
            ['rating_count'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserBookActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserBook]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserBook.prisma().query_raw(
            'SELECT * FROM UserBook WHERE id = $1',
            521827728,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserBook
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserBook.prisma().query_first(
            'SELECT * FROM UserBook WHERE userId = $1',
            1266032265,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserBookCreateInput,
        include: Optional[types.UserBookInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserBook record.

        Parameters
        ----------
        data
            UserBook record data
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The created UserBook record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserBook record from just the required fields
        userbook = await UserBook.prisma().create(
            data={
                # data to create a UserBook record
                'userId': 93253262,
                'bookId': 2053047983,
                'status': 'gifdddbia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserBookCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserBook records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserBook record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserBook.prisma().create_many(
            data=[
                {
                    # data to create a UserBook record
                    'userId': 127474245,
                    'bookId': 948921754,
                    'status': 'bjgejjabff',
                },
                {
                    # data to create a UserBook record
                    'userId': 1228891816,
                    'bookId': 255202753,
                    'status': 'bccdfhdigc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserBook record.

        Parameters
        ----------
        where
            UserBook filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The deleted UserBook record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().delete(
            where={
                'id': 541269159,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserBook record.

        Parameters
        ----------
        where
            UserBook filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The found UserBook record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().find_unique(
            where={
                'id': 1064846676,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserBook record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserBook filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The found UserBook record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().find_unique_or_raise(
            where={
                'id': 508382461,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
        include: Optional[types.UserBookInclude] = None,
        order: Optional[Union[types.UserBookOrderByInput, List[types.UserBookOrderByInput]]] = None,
        distinct: Optional[List[types.UserBookScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserBook records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserBook records returned
        skip
            Ignore the first N results
        where
            UserBook filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBook model
        order
            Order the returned UserBook records by any field
        distinct
            Filter UserBook records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserBook]
            The list of all UserBook records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserBook records
        userbooks = await UserBook.prisma().find_many(take=10)

        # find the first 5 UserBook records ordered by the bookId field
        userbooks = await UserBook.prisma().find_many(
            take=5,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
        include: Optional[types.UserBookInclude] = None,
        order: Optional[Union[types.UserBookOrderByInput, List[types.UserBookOrderByInput]]] = None,
        distinct: Optional[List[types.UserBookScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserBook record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserBook filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBook model
        order
            Order the returned UserBook records by any field
        distinct
            Filter UserBook records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserBook
            The first UserBook record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserBook record ordered by the status field
        userbook = await UserBook.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
        include: Optional[types.UserBookInclude] = None,
        order: Optional[Union[types.UserBookOrderByInput, List[types.UserBookOrderByInput]]] = None,
        distinct: Optional[List[types.UserBookScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserBook record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserBook filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBook model
        order
            Order the returned UserBook records by any field
        distinct
            Filter UserBook records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserBook
            The first UserBook record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserBook record ordered by the rating field
        userbook = await UserBook.prisma().find_first_or_raise(
            skip=1,
            order={
                'rating': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserBookUpdateInput,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserBook record.

        Parameters
        ----------
        data
            UserBook record data specifying what to update
        where
            UserBook filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The updated UserBook record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userbook = await UserBook.prisma().update(
            where={
                'id': 1024265714,
            },
            data={
                # data to update the UserBook record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserBookWhereUniqueInput,
        data: types.UserBookUpsertInput,
        include: Optional[types.UserBookInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserBook filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The created or updated UserBook record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().upsert(
            where={
                'id': 872078403,
            },
            data={
                'create': {
                    'id': 872078403,
                    'userId': 1228891816,
                    'bookId': 255202753,
                    'status': 'bccdfhdigc',
                },
                'update': {
                    'userId': 1228891816,
                    'bookId': 255202753,
                    'status': 'bccdfhdigc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserBookUpdateManyMutationInput,
        where: types.UserBookWhereInput,
    ) -> int:
        """Update multiple UserBook records

        Parameters
        ----------
        data
            UserBook data to update the selected UserBook records to
        where
            Filter to select the UserBook records to update

        Returns
        -------
        int
            The total number of UserBook records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserBook records
        total = await UserBook.prisma().update_many(
            data={
                'addedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserBook records present in the database

        Parameters
        ----------
        select
            Select the UserBook fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserBook filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserBookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserBook.prisma().count()

        # results: prisma.types.UserBookCountAggregateOutput
        results = await UserBook.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserBookCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
    ) -> types.UserBookCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserBookCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
    ) -> Union[int, types.UserBookCountAggregateOutput]:
        """Count the number of UserBook records present in the database

        Parameters
        ----------
        select
            Select the UserBook fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserBook filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserBookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserBook.prisma().count()

        # results: prisma.types.UserBookCountAggregateOutput
        results = await UserBook.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserBookCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserBookWhereInput] = None
    ) -> int:
        """Delete multiple UserBook records.

        Parameters
        ----------
        where
            Optional UserBook filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserBook records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserBook records
        total = await UserBook.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserBookScalarFieldKeys'],
        *,
        where: Optional['types.UserBookWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserBookAvgAggregateInput'] = None,
        sum: Optional['types.UserBookSumAggregateInput'] = None,
        min: Optional['types.UserBookMinAggregateInput'] = None,
        max: Optional['types.UserBookMaxAggregateInput'] = None,
        having: Optional['types.UserBookScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserBookCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserBookScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserBookScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserBookGroupByOutput']:
        """Group UserBook records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserBook fields to group records by
        where
            UserBook filter to select records
        take
            Limit the maximum number of UserBook records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserBookGroupByOutput]
            A list of dictionaries representing the UserBook record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserBook records by id values
        # and count how many records are in each group
        results = await UserBook.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class VoteActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Vote]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Vote.prisma().query_raw(
            'SELECT * FROM Vote WHERE id = $1',
            1874748096,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Vote
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Vote.prisma().query_first(
            'SELECT * FROM Vote WHERE userId = $1',
            916896761,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.VoteCreateInput,
        include: Optional[types.VoteInclude] = None
    ) -> _PrismaModelT:
        """Create a new Vote record.

        Parameters
        ----------
        data
            Vote record data
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The created Vote record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Vote record from just the required fields
        vote = await Vote.prisma().create(
            data={
                # data to create a Vote record
                'userId': 769267518,
                'bookId': 820312479,
                'weekNumber': 92728044,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.VoteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Vote records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Vote record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Vote.prisma().create_many(
            data=[
                {
                    # data to create a Vote record
                    'userId': 344858293,
                    'bookId': 1121741130,
                    'weekNumber': 1495896251,
                },
                {
                    # data to create a Vote record
                    'userId': 208521688,
                    'bookId': 860811569,
                    'weekNumber': 1660932118,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Vote record.

        Parameters
        ----------
        where
            Vote filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The deleted Vote record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().delete(
            where={
                'id': 525761943,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Vote record.

        Parameters
        ----------
        where
            Vote filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The found Vote record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().find_unique(
            where={
                'id': 736209796,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Vote record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Vote filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The found Vote record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().find_unique_or_raise(
            where={
                'id': 493907821,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
        include: Optional[types.VoteInclude] = None,
        order: Optional[Union[types.VoteOrderByInput, List[types.VoteOrderByInput]]] = None,
        distinct: Optional[List[types.VoteScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Vote records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Vote records returned
        skip
            Ignore the first N results
        where
            Vote filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vote model
        order
            Order the returned Vote records by any field
        distinct
            Filter Vote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Vote]
            The list of all Vote records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Vote records
        votes = await Vote.prisma().find_many(take=10)

        # find the first 5 Vote records ordered by the bookId field
        votes = await Vote.prisma().find_many(
            take=5,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
        include: Optional[types.VoteInclude] = None,
        order: Optional[Union[types.VoteOrderByInput, List[types.VoteOrderByInput]]] = None,
        distinct: Optional[List[types.VoteScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Vote record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Vote filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vote model
        order
            Order the returned Vote records by any field
        distinct
            Filter Vote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Vote
            The first Vote record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Vote record ordered by the weekNumber field
        vote = await Vote.prisma().find_first(
            skip=1,
            order={
                'weekNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
        include: Optional[types.VoteInclude] = None,
        order: Optional[Union[types.VoteOrderByInput, List[types.VoteOrderByInput]]] = None,
        distinct: Optional[List[types.VoteScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Vote record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Vote filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vote model
        order
            Order the returned Vote records by any field
        distinct
            Filter Vote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Vote
            The first Vote record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Vote record ordered by the voteDate field
        vote = await Vote.prisma().find_first_or_raise(
            skip=1,
            order={
                'voteDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.VoteUpdateInput,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Vote record.

        Parameters
        ----------
        data
            Vote record data specifying what to update
        where
            Vote filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The updated Vote record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        vote = await Vote.prisma().update(
            where={
                'id': 639686562,
            },
            data={
                # data to update the Vote record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.VoteWhereUniqueInput,
        data: types.VoteUpsertInput,
        include: Optional[types.VoteInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Vote filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The created or updated Vote record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().upsert(
            where={
                'id': 654007347,
            },
            data={
                'create': {
                    'id': 654007347,
                    'userId': 208521688,
                    'bookId': 860811569,
                    'weekNumber': 1660932118,
                },
                'update': {
                    'userId': 208521688,
                    'bookId': 860811569,
                    'weekNumber': 1660932118,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.VoteUpdateManyMutationInput,
        where: types.VoteWhereInput,
    ) -> int:
        """Update multiple Vote records

        Parameters
        ----------
        data
            Vote data to update the selected Vote records to
        where
            Filter to select the Vote records to update

        Returns
        -------
        int
            The total number of Vote records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Vote records
        total = await Vote.prisma().update_many(
            data={
                'id': 1905261552
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Vote records present in the database

        Parameters
        ----------
        select
            Select the Vote fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Vote filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VoteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Vote.prisma().count()

        # results: prisma.types.VoteCountAggregateOutput
        results = await Vote.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.VoteCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
    ) -> types.VoteCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.VoteCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
    ) -> Union[int, types.VoteCountAggregateOutput]:
        """Count the number of Vote records present in the database

        Parameters
        ----------
        select
            Select the Vote fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Vote filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VoteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Vote.prisma().count()

        # results: prisma.types.VoteCountAggregateOutput
        results = await Vote.prisma().count(
            select={
                '_all': True,
                'bookId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.VoteCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.VoteWhereInput] = None
    ) -> int:
        """Delete multiple Vote records.

        Parameters
        ----------
        where
            Optional Vote filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Vote records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Vote records
        total = await Vote.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.VoteScalarFieldKeys'],
        *,
        where: Optional['types.VoteWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.VoteAvgAggregateInput'] = None,
        sum: Optional['types.VoteSumAggregateInput'] = None,
        min: Optional['types.VoteMinAggregateInput'] = None,
        max: Optional['types.VoteMaxAggregateInput'] = None,
        having: Optional['types.VoteScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.VoteCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.VoteScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.VoteScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.VoteGroupByOutput']:
        """Group Vote records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Vote fields to group records by
        where
            Vote filter to select records
        take
            Limit the maximum number of Vote records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.VoteGroupByOutput]
            A list of dictionaries representing the Vote record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Vote records by weekNumber values
        # and count how many records are in each group
        results = await Vote.prisma().group_by(
            ['weekNumber'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReadingProgressActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ReadingProgress]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ReadingProgress.prisma().query_raw(
            'SELECT * FROM ReadingProgress WHERE id = $1',
            78746985,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ReadingProgress
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ReadingProgress.prisma().query_first(
            'SELECT * FROM ReadingProgress WHERE userId = $1',
            1398328302,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReadingProgressCreateInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> _PrismaModelT:
        """Create a new ReadingProgress record.

        Parameters
        ----------
        data
            ReadingProgress record data
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The created ReadingProgress record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ReadingProgress record from just the required fields
        readingprogress = await ReadingProgress.prisma().create(
            data={
                # data to create a ReadingProgress record
                'userId': 856000655,
                'bookId': 1452336924,
                'weekNumber': 1573199653,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReadingProgressCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ReadingProgress records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ReadingProgress record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ReadingProgress.prisma().create_many(
            data=[
                {
                    # data to create a ReadingProgress record
                    'userId': 2013903098,
                    'bookId': 500965035,
                    'weekNumber': 1800624392,
                },
                {
                    # data to create a ReadingProgress record
                    'userId': 2077067425,
                    'bookId': 1672112838,
                    'weekNumber': 926677639,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ReadingProgress record.

        Parameters
        ----------
        where
            ReadingProgress filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The deleted ReadingProgress record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().delete(
            where={
                'id': 1447624116,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ReadingProgress record.

        Parameters
        ----------
        where
            ReadingProgress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The found ReadingProgress record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().find_unique(
            where={
                'id': 1738083805,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ReadingProgress record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ReadingProgress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The found ReadingProgress record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().find_unique_or_raise(
            where={
                'id': 340946258,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
        include: Optional[types.ReadingProgressInclude] = None,
        order: Optional[Union[types.ReadingProgressOrderByInput, List[types.ReadingProgressOrderByInput]]] = None,
        distinct: Optional[List[types.ReadingProgressScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ReadingProgress records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ReadingProgress records returned
        skip
            Ignore the first N results
        where
            ReadingProgress filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReadingProgress model
        order
            Order the returned ReadingProgress records by any field
        distinct
            Filter ReadingProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ReadingProgress]
            The list of all ReadingProgress records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ReadingProgress records
        readingprogress = await ReadingProgress.prisma().find_many(take=10)

        # find the first 5 ReadingProgress records ordered by the bookId field
        readingprogress = await ReadingProgress.prisma().find_many(
            take=5,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
        include: Optional[types.ReadingProgressInclude] = None,
        order: Optional[Union[types.ReadingProgressOrderByInput, List[types.ReadingProgressOrderByInput]]] = None,
        distinct: Optional[List[types.ReadingProgressScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ReadingProgress record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReadingProgress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReadingProgress model
        order
            Order the returned ReadingProgress records by any field
        distinct
            Filter ReadingProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReadingProgress
            The first ReadingProgress record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReadingProgress record ordered by the weekNumber field
        readingprogress = await ReadingProgress.prisma().find_first(
            skip=1,
            order={
                'weekNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
        include: Optional[types.ReadingProgressInclude] = None,
        order: Optional[Union[types.ReadingProgressOrderByInput, List[types.ReadingProgressOrderByInput]]] = None,
        distinct: Optional[List[types.ReadingProgressScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ReadingProgress record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReadingProgress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReadingProgress model
        order
            Order the returned ReadingProgress records by any field
        distinct
            Filter ReadingProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReadingProgress
            The first ReadingProgress record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReadingProgress record ordered by the marks field
        readingprogress = await ReadingProgress.prisma().find_first_or_raise(
            skip=1,
            order={
                'marks': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReadingProgressUpdateInput,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ReadingProgress record.

        Parameters
        ----------
        data
            ReadingProgress record data specifying what to update
        where
            ReadingProgress filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The updated ReadingProgress record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().update(
            where={
                'id': 601077795,
            },
            data={
                # data to update the ReadingProgress record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        data: types.ReadingProgressUpsertInput,
        include: Optional[types.ReadingProgressInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ReadingProgress filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The created or updated ReadingProgress record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().upsert(
            where={
                'id': 290603296,
            },
            data={
                'create': {
                    'id': 290603296,
                    'userId': 2077067425,
                    'bookId': 1672112838,
                    'weekNumber': 926677639,
                },
                'update': {
                    'userId': 2077067425,
                    'bookId': 1672112838,
                    'weekNumber': 926677639,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReadingProgressUpdateManyMutationInput,
        where: types.ReadingProgressWhereInput,
    ) -> int:
        """Update multiple ReadingProgress records

        Parameters
        ----------
        data
            ReadingProgress data to update the selected ReadingProgress records to
        where
            Filter to select the ReadingProgress records to update

        Returns
        -------
        int
            The total number of ReadingProgress records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ReadingProgress records
        total = await ReadingProgress.prisma().update_many(
            data={
                'progressDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ReadingProgress records present in the database

        Parameters
        ----------
        select
            Select the ReadingProgress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReadingProgress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReadingProgressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReadingProgress.prisma().count()

        # results: prisma.types.ReadingProgressCountAggregateOutput
        results = await ReadingProgress.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReadingProgressCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
    ) -> types.ReadingProgressCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReadingProgressCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
    ) -> Union[int, types.ReadingProgressCountAggregateOutput]:
        """Count the number of ReadingProgress records present in the database

        Parameters
        ----------
        select
            Select the ReadingProgress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReadingProgress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReadingProgressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReadingProgress.prisma().count()

        # results: prisma.types.ReadingProgressCountAggregateOutput
        results = await ReadingProgress.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReadingProgressCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReadingProgressWhereInput] = None
    ) -> int:
        """Delete multiple ReadingProgress records.

        Parameters
        ----------
        where
            Optional ReadingProgress filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ReadingProgress records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ReadingProgress records
        total = await ReadingProgress.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReadingProgressScalarFieldKeys'],
        *,
        where: Optional['types.ReadingProgressWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReadingProgressAvgAggregateInput'] = None,
        sum: Optional['types.ReadingProgressSumAggregateInput'] = None,
        min: Optional['types.ReadingProgressMinAggregateInput'] = None,
        max: Optional['types.ReadingProgressMaxAggregateInput'] = None,
        having: Optional['types.ReadingProgressScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReadingProgressCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReadingProgressScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ReadingProgressScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ReadingProgressGroupByOutput']:
        """Group ReadingProgress records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ReadingProgress fields to group records by
        where
            ReadingProgress filter to select records
        take
            Limit the maximum number of ReadingProgress records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReadingProgressGroupByOutput]
            A list of dictionaries representing the ReadingProgress record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ReadingProgress records by bookId values
        # and count how many records are in each group
        results = await ReadingProgress.prisma().group_by(
            ['bookId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WeeklyResultActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.WeeklyResult]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await WeeklyResult.prisma().query_raw(
            'SELECT * FROM WeeklyResult WHERE id = $1',
            1855826649,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.WeeklyResult
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await WeeklyResult.prisma().query_first(
            'SELECT * FROM WeeklyResult WHERE weekNumber = $1',
            1611009182,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WeeklyResultCreateInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> _PrismaModelT:
        """Create a new WeeklyResult record.

        Parameters
        ----------
        data
            WeeklyResult record data
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The created WeeklyResult record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a WeeklyResult record from just the required fields
        weeklyresult = await WeeklyResult.prisma().create(
            data={
                # data to create a WeeklyResult record
                'weekNumber': 446673791,
                'ageCategoryId': 300568396,
                'bookId': 632626069,
                'leaderUserId': 1724011690,
                'totalMarks': 470157467,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WeeklyResultCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple WeeklyResult records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of WeeklyResult record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await WeeklyResult.prisma().create_many(
            data=[
                {
                    # data to create a WeeklyResult record
                    'weekNumber': 1209209912,
                    'ageCategoryId': 1536744465,
                    'bookId': 424218998,
                    'leaderUserId': 2125632375,
                    'totalMarks': 536951780,
                },
                {
                    # data to create a WeeklyResult record
                    'weekNumber': 924723277,
                    'ageCategoryId': 1621937922,
                    'bookId': 1848832019,
                    'leaderUserId': 1921528400,
                    'totalMarks': 2100427849,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single WeeklyResult record.

        Parameters
        ----------
        where
            WeeklyResult filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The deleted WeeklyResult record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().delete(
            where={
                'id': 849140046,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique WeeklyResult record.

        Parameters
        ----------
        where
            WeeklyResult filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The found WeeklyResult record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().find_unique(
            where={
                'id': 928152175,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> _PrismaModelT:
        """Find a unique WeeklyResult record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            WeeklyResult filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The found WeeklyResult record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().find_unique_or_raise(
            where={
                'id': 273032060,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
        include: Optional[types.WeeklyResultInclude] = None,
        order: Optional[Union[types.WeeklyResultOrderByInput, List[types.WeeklyResultOrderByInput]]] = None,
        distinct: Optional[List[types.WeeklyResultScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple WeeklyResult records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of WeeklyResult records returned
        skip
            Ignore the first N results
        where
            WeeklyResult filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WeeklyResult model
        order
            Order the returned WeeklyResult records by any field
        distinct
            Filter WeeklyResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.WeeklyResult]
            The list of all WeeklyResult records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 WeeklyResult records
        weeklyresults = await WeeklyResult.prisma().find_many(take=10)

        # find the first 5 WeeklyResult records ordered by the ageCategoryId field
        weeklyresults = await WeeklyResult.prisma().find_many(
            take=5,
            order={
                'ageCategoryId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
        include: Optional[types.WeeklyResultInclude] = None,
        order: Optional[Union[types.WeeklyResultOrderByInput, List[types.WeeklyResultOrderByInput]]] = None,
        distinct: Optional[List[types.WeeklyResultScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single WeeklyResult record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WeeklyResult filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WeeklyResult model
        order
            Order the returned WeeklyResult records by any field
        distinct
            Filter WeeklyResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WeeklyResult
            The first WeeklyResult record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WeeklyResult record ordered by the bookId field
        weeklyresult = await WeeklyResult.prisma().find_first(
            skip=1,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
        include: Optional[types.WeeklyResultInclude] = None,
        order: Optional[Union[types.WeeklyResultOrderByInput, List[types.WeeklyResultOrderByInput]]] = None,
        distinct: Optional[List[types.WeeklyResultScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single WeeklyResult record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WeeklyResult filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WeeklyResult model
        order
            Order the returned WeeklyResult records by any field
        distinct
            Filter WeeklyResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WeeklyResult
            The first WeeklyResult record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WeeklyResult record ordered by the leaderUserId field
        weeklyresult = await WeeklyResult.prisma().find_first_or_raise(
            skip=1,
            order={
                'leaderUserId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WeeklyResultUpdateInput,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single WeeklyResult record.

        Parameters
        ----------
        data
            WeeklyResult record data specifying what to update
        where
            WeeklyResult filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The updated WeeklyResult record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().update(
            where={
                'id': 982848517,
            },
            data={
                # data to update the WeeklyResult record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        data: types.WeeklyResultUpsertInput,
        include: Optional[types.WeeklyResultInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            WeeklyResult filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The created or updated WeeklyResult record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().upsert(
            where={
                'id': 510737498,
            },
            data={
                'create': {
                    'id': 510737498,
                    'weekNumber': 924723277,
                    'ageCategoryId': 1621937922,
                    'bookId': 1848832019,
                    'leaderUserId': 1921528400,
                    'totalMarks': 2100427849,
                },
                'update': {
                    'weekNumber': 924723277,
                    'ageCategoryId': 1621937922,
                    'bookId': 1848832019,
                    'leaderUserId': 1921528400,
                    'totalMarks': 2100427849,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WeeklyResultUpdateManyMutationInput,
        where: types.WeeklyResultWhereInput,
    ) -> int:
        """Update multiple WeeklyResult records

        Parameters
        ----------
        data
            WeeklyResult data to update the selected WeeklyResult records to
        where
            Filter to select the WeeklyResult records to update

        Returns
        -------
        int
            The total number of WeeklyResult records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all WeeklyResult records
        total = await WeeklyResult.prisma().update_many(
            data={
                'totalMarks': 2117488267
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
    ) -> int:
        """Count the number of WeeklyResult records present in the database

        Parameters
        ----------
        select
            Select the WeeklyResult fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WeeklyResult filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WeeklyResultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WeeklyResult.prisma().count()

        # results: prisma.types.WeeklyResultCountAggregateOutput
        results = await WeeklyResult.prisma().count(
            select={
                '_all': True,
                'genreId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WeeklyResultCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
    ) -> types.WeeklyResultCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WeeklyResultCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
    ) -> Union[int, types.WeeklyResultCountAggregateOutput]:
        """Count the number of WeeklyResult records present in the database

        Parameters
        ----------
        select
            Select the WeeklyResult fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WeeklyResult filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WeeklyResultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WeeklyResult.prisma().count()

        # results: prisma.types.WeeklyResultCountAggregateOutput
        results = await WeeklyResult.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WeeklyResultCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WeeklyResultWhereInput] = None
    ) -> int:
        """Delete multiple WeeklyResult records.

        Parameters
        ----------
        where
            Optional WeeklyResult filter to find the records to be deleted

        Returns
        -------
        int
            The total number of WeeklyResult records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all WeeklyResult records
        total = await WeeklyResult.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WeeklyResultScalarFieldKeys'],
        *,
        where: Optional['types.WeeklyResultWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WeeklyResultAvgAggregateInput'] = None,
        sum: Optional['types.WeeklyResultSumAggregateInput'] = None,
        min: Optional['types.WeeklyResultMinAggregateInput'] = None,
        max: Optional['types.WeeklyResultMaxAggregateInput'] = None,
        having: Optional['types.WeeklyResultScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WeeklyResultCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WeeklyResultScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WeeklyResultScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WeeklyResultGroupByOutput']:
        """Group WeeklyResult records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar WeeklyResult fields to group records by
        where
            WeeklyResult filter to select records
        take
            Limit the maximum number of WeeklyResult records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WeeklyResultGroupByOutput]
            A list of dictionaries representing the WeeklyResult record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group WeeklyResult records by weekNumber values
        # and count how many records are in each group
        results = await WeeklyResult.prisma().group_by(
            ['weekNumber'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Notification]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Notification.prisma().query_raw(
            'SELECT * FROM Notification WHERE id = $1',
            1401944936,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Notification
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Notification.prisma().query_first(
            'SELECT * FROM Notification WHERE userId = $1',
            1297607553,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Notification record.

        Parameters
        ----------
        data
            Notification record data
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created Notification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Notification record from just the required fields
        notification = await Notification.prisma().create(
            data={
                # data to create a Notification record
                'userId': 519488550,
                'message': 'jhgidcgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Notification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Notification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Notification.prisma().create_many(
            data=[
                {
                    # data to create a Notification record
                    'userId': 1696425492,
                    'message': 'bgjcgchib',
                },
                {
                    # data to create a Notification record
                    'userId': 1023081650,
                    'message': 'dchgibach',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Notification record.

        Parameters
        ----------
        where
            Notification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The deleted Notification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().delete(
            where={
                'id': 527748992,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Notification record.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique(
            where={
                'id': 2029357497,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Notification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique_or_raise(
            where={
                'id': 1318597118,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Notification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N results
        where
            Notification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Notification]
            The list of all Notification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Notification records
        notifications = await Notification.prisma().find_many(take=10)

        # find the first 5 Notification records ordered by the message field
        notifications = await Notification.prisma().find_many(
            take=5,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Notification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the sentDate field
        notification = await Notification.prisma().find_first(
            skip=1,
            order={
                'sentDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Notification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the id field
        notification = await Notification.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Notification record.

        Parameters
        ----------
        data
            Notification record data specifying what to update
        where
            Notification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The updated Notification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notification = await Notification.prisma().update(
            where={
                'id': 2122112351,
            },
            data={
                # data to update the Notification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Notification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created or updated Notification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().upsert(
            where={
                'id': 1024943020,
            },
            data={
                'create': {
                    'id': 1024943020,
                    'userId': 1023081650,
                    'message': 'dchgibach',
                },
                'update': {
                    'userId': 1023081650,
                    'message': 'dchgibach',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> int:
        """Update multiple Notification records

        Parameters
        ----------
        data
            Notification data to update the selected Notification records to
        where
            Filter to select the Notification records to update

        Returns
        -------
        int
            The total number of Notification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Notification records
        total = await Notification.prisma().update_many(
            data={
                'userId': 1717307509
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'message': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> types.NotificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationCountAggregateOutput]:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'sentDate': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None
    ) -> int:
        """Delete multiple Notification records.

        Parameters
        ----------
        where
            Optional Notification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Notification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Notification records
        total = await Notification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationScalarFieldKeys'],
        *,
        where: Optional['types.NotificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationAvgAggregateInput'] = None,
        sum: Optional['types.NotificationSumAggregateInput'] = None,
        min: Optional['types.NotificationMinAggregateInput'] = None,
        max: Optional['types.NotificationMaxAggregateInput'] = None,
        having: Optional['types.NotificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationGroupByOutput']:
        """Group Notification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Notification fields to group records by
        where
            Notification filter to select records
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationGroupByOutput]
            A list of dictionaries representing the Notification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Notification records by id values
        # and count how many records are in each group
        results = await Notification.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AdvertisementActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Advertisement]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Advertisement.prisma().query_raw(
            'SELECT * FROM Advertisement WHERE id = $1',
            1598124042,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Advertisement
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Advertisement.prisma().query_first(
            'SELECT * FROM Advertisement WHERE content = $1',
            'ibhgcdbgd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AdvertisementCreateInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> _PrismaModelT:
        """Create a new Advertisement record.

        Parameters
        ----------
        data
            Advertisement record data
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The created Advertisement record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Advertisement record from just the required fields
        advertisement = await Advertisement.prisma().create(
            data={
                # data to create a Advertisement record
                'content': 'badaffhddg',
                'partnerId': 1131525873,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AdvertisementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Advertisement records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Advertisement record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Advertisement.prisma().create_many(
            data=[
                {
                    # data to create a Advertisement record
                    'content': 'cbagggbji',
                    'partnerId': 1276057943,
                },
                {
                    # data to create a Advertisement record
                    'content': 'heffgjdei',
                    'partnerId': 307876141,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Advertisement record.

        Parameters
        ----------
        where
            Advertisement filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The deleted Advertisement record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().delete(
            where={
                'id': 1674049122,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Advertisement record.

        Parameters
        ----------
        where
            Advertisement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The found Advertisement record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().find_unique(
            where={
                'id': 1526854643,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Advertisement record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Advertisement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The found Advertisement record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().find_unique_or_raise(
            where={
                'id': 958077104,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
        include: Optional[types.AdvertisementInclude] = None,
        order: Optional[Union[types.AdvertisementOrderByInput, List[types.AdvertisementOrderByInput]]] = None,
        distinct: Optional[List[types.AdvertisementScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Advertisement records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Advertisement records returned
        skip
            Ignore the first N results
        where
            Advertisement filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Advertisement model
        order
            Order the returned Advertisement records by any field
        distinct
            Filter Advertisement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Advertisement]
            The list of all Advertisement records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Advertisement records
        advertisements = await Advertisement.prisma().find_many(take=10)

        # find the first 5 Advertisement records ordered by the partnerId field
        advertisements = await Advertisement.prisma().find_many(
            take=5,
            order={
                'partnerId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
        include: Optional[types.AdvertisementInclude] = None,
        order: Optional[Union[types.AdvertisementOrderByInput, List[types.AdvertisementOrderByInput]]] = None,
        distinct: Optional[List[types.AdvertisementScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Advertisement record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Advertisement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Advertisement model
        order
            Order the returned Advertisement records by any field
        distinct
            Filter Advertisement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Advertisement
            The first Advertisement record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Advertisement record ordered by the isActive field
        advertisement = await Advertisement.prisma().find_first(
            skip=1,
            order={
                'isActive': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
        include: Optional[types.AdvertisementInclude] = None,
        order: Optional[Union[types.AdvertisementOrderByInput, List[types.AdvertisementOrderByInput]]] = None,
        distinct: Optional[List[types.AdvertisementScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Advertisement record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Advertisement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Advertisement model
        order
            Order the returned Advertisement records by any field
        distinct
            Filter Advertisement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Advertisement
            The first Advertisement record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Advertisement record ordered by the id field
        advertisement = await Advertisement.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AdvertisementUpdateInput,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Advertisement record.

        Parameters
        ----------
        data
            Advertisement record data specifying what to update
        where
            Advertisement filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The updated Advertisement record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().update(
            where={
                'id': 1513050921,
            },
            data={
                # data to update the Advertisement record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AdvertisementWhereUniqueInput,
        data: types.AdvertisementUpsertInput,
        include: Optional[types.AdvertisementInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Advertisement filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The created or updated Advertisement record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().upsert(
            where={
                'id': 204674734,
            },
            data={
                'create': {
                    'id': 204674734,
                    'content': 'heffgjdei',
                    'partnerId': 307876141,
                },
                'update': {
                    'content': 'heffgjdei',
                    'partnerId': 307876141,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AdvertisementUpdateManyMutationInput,
        where: types.AdvertisementWhereInput,
    ) -> int:
        """Update multiple Advertisement records

        Parameters
        ----------
        data
            Advertisement data to update the selected Advertisement records to
        where
            Filter to select the Advertisement records to update

        Returns
        -------
        int
            The total number of Advertisement records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Advertisement records
        total = await Advertisement.prisma().update_many(
            data={
                'content': 'caghgfbggd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Advertisement records present in the database

        Parameters
        ----------
        select
            Select the Advertisement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Advertisement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdvertisementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Advertisement.prisma().count()

        # results: prisma.types.AdvertisementCountAggregateOutput
        results = await Advertisement.prisma().count(
            select={
                '_all': True,
                'partnerId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AdvertisementCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
    ) -> types.AdvertisementCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AdvertisementCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
    ) -> Union[int, types.AdvertisementCountAggregateOutput]:
        """Count the number of Advertisement records present in the database

        Parameters
        ----------
        select
            Select the Advertisement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Advertisement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdvertisementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Advertisement.prisma().count()

        # results: prisma.types.AdvertisementCountAggregateOutput
        results = await Advertisement.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AdvertisementCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AdvertisementWhereInput] = None
    ) -> int:
        """Delete multiple Advertisement records.

        Parameters
        ----------
        where
            Optional Advertisement filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Advertisement records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Advertisement records
        total = await Advertisement.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AdvertisementScalarFieldKeys'],
        *,
        where: Optional['types.AdvertisementWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AdvertisementAvgAggregateInput'] = None,
        sum: Optional['types.AdvertisementSumAggregateInput'] = None,
        min: Optional['types.AdvertisementMinAggregateInput'] = None,
        max: Optional['types.AdvertisementMaxAggregateInput'] = None,
        having: Optional['types.AdvertisementScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AdvertisementCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AdvertisementScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AdvertisementScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AdvertisementGroupByOutput']:
        """Group Advertisement records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Advertisement fields to group records by
        where
            Advertisement filter to select records
        take
            Limit the maximum number of Advertisement records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AdvertisementGroupByOutput]
            A list of dictionaries representing the Advertisement record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Advertisement records by id values
        # and count how many records are in each group
        results = await Advertisement.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PartnerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Partner]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Partner.prisma().query_raw(
            'SELECT * FROM Partner WHERE id = $1',
            1183911900,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Partner
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Partner.prisma().query_first(
            'SELECT * FROM Partner WHERE name = $1',
            'bfijhaejdd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PartnerCreateInput,
        include: Optional[types.PartnerInclude] = None
    ) -> _PrismaModelT:
        """Create a new Partner record.

        Parameters
        ----------
        data
            Partner record data
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The created Partner record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Partner record from just the required fields
        partner = await Partner.prisma().create(
            data={
                # data to create a Partner record
                'name': 'bcedehfiji',
                'contactInfo': 'bdgjicijhb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PartnerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Partner records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Partner record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Partner.prisma().create_many(
            data=[
                {
                    # data to create a Partner record
                    'name': 'bghifjdeia',
                    'contactInfo': 'eadfcbbcb',
                },
                {
                    # data to create a Partner record
                    'name': 'geihgahba',
                    'contactInfo': 'gahdcdhbj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Partner record.

        Parameters
        ----------
        where
            Partner filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The deleted Partner record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().delete(
            where={
                'id': 1468890740,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Partner record.

        Parameters
        ----------
        where
            Partner filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The found Partner record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().find_unique(
            where={
                'id': 629039005,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Partner record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Partner filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The found Partner record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().find_unique_or_raise(
            where={
                'id': 1214168082,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
        include: Optional[types.PartnerInclude] = None,
        order: Optional[Union[types.PartnerOrderByInput, List[types.PartnerOrderByInput]]] = None,
        distinct: Optional[List[types.PartnerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Partner records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Partner records returned
        skip
            Ignore the first N results
        where
            Partner filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Partner model
        order
            Order the returned Partner records by any field
        distinct
            Filter Partner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Partner]
            The list of all Partner records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Partner records
        partners = await Partner.prisma().find_many(take=10)

        # find the first 5 Partner records ordered by the contactInfo field
        partners = await Partner.prisma().find_many(
            take=5,
            order={
                'contactInfo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
        include: Optional[types.PartnerInclude] = None,
        order: Optional[Union[types.PartnerOrderByInput, List[types.PartnerOrderByInput]]] = None,
        distinct: Optional[List[types.PartnerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Partner record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Partner filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Partner model
        order
            Order the returned Partner records by any field
        distinct
            Filter Partner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Partner
            The first Partner record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Partner record ordered by the id field
        partner = await Partner.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
        include: Optional[types.PartnerInclude] = None,
        order: Optional[Union[types.PartnerOrderByInput, List[types.PartnerOrderByInput]]] = None,
        distinct: Optional[List[types.PartnerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Partner record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Partner filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Partner model
        order
            Order the returned Partner records by any field
        distinct
            Filter Partner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Partner
            The first Partner record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Partner record ordered by the name field
        partner = await Partner.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PartnerUpdateInput,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Partner record.

        Parameters
        ----------
        data
            Partner record data specifying what to update
        where
            Partner filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The updated Partner record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        partner = await Partner.prisma().update(
            where={
                'id': 898613219,
            },
            data={
                # data to update the Partner record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PartnerWhereUniqueInput,
        data: types.PartnerUpsertInput,
        include: Optional[types.PartnerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Partner filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The created or updated Partner record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().upsert(
            where={
                'id': 658378208,
            },
            data={
                'create': {
                    'id': 658378208,
                    'name': 'geihgahba',
                    'contactInfo': 'gahdcdhbj',
                },
                'update': {
                    'name': 'geihgahba',
                    'contactInfo': 'gahdcdhbj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PartnerUpdateManyMutationInput,
        where: types.PartnerWhereInput,
    ) -> int:
        """Update multiple Partner records

        Parameters
        ----------
        data
            Partner data to update the selected Partner records to
        where
            Filter to select the Partner records to update

        Returns
        -------
        int
            The total number of Partner records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Partner records
        total = await Partner.prisma().update_many(
            data={
                'contactInfo': 'jfegcaafh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Partner records present in the database

        Parameters
        ----------
        select
            Select the Partner fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Partner filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PartnerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Partner.prisma().count()

        # results: prisma.types.PartnerCountAggregateOutput
        results = await Partner.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PartnerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
    ) -> types.PartnerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PartnerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
    ) -> Union[int, types.PartnerCountAggregateOutput]:
        """Count the number of Partner records present in the database

        Parameters
        ----------
        select
            Select the Partner fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Partner filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PartnerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Partner.prisma().count()

        # results: prisma.types.PartnerCountAggregateOutput
        results = await Partner.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PartnerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PartnerWhereInput] = None
    ) -> int:
        """Delete multiple Partner records.

        Parameters
        ----------
        where
            Optional Partner filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Partner records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Partner records
        total = await Partner.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PartnerScalarFieldKeys'],
        *,
        where: Optional['types.PartnerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PartnerAvgAggregateInput'] = None,
        sum: Optional['types.PartnerSumAggregateInput'] = None,
        min: Optional['types.PartnerMinAggregateInput'] = None,
        max: Optional['types.PartnerMaxAggregateInput'] = None,
        having: Optional['types.PartnerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PartnerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PartnerScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PartnerScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PartnerGroupByOutput']:
        """Group Partner records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Partner fields to group records by
        where
            Partner filter to select records
        take
            Limit the maximum number of Partner records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PartnerGroupByOutput]
            A list of dictionaries representing the Partner record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Partner records by contactInfo values
        # and count how many records are in each group
        results = await Partner.prisma().group_by(
            ['contactInfo'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AchievementActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Achievement]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Achievement.prisma().query_raw(
            'SELECT * FROM Achievement WHERE id = $1',
            1214809950,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Achievement
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Achievement.prisma().query_first(
            'SELECT * FROM Achievement WHERE name = $1',
            'baehicaajf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AchievementCreateInput,
        include: Optional[types.AchievementInclude] = None
    ) -> _PrismaModelT:
        """Create a new Achievement record.

        Parameters
        ----------
        data
            Achievement record data
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The created Achievement record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Achievement record from just the required fields
        achievement = await Achievement.prisma().create(
            data={
                # data to create a Achievement record
                'name': 'bdachdeiga',
                'description': 'ijdafccef',
                'type': 'ciaaiddag',
                'criteria': Json({'fejggijff': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AchievementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Achievement records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Achievement record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Achievement.prisma().create_many(
            data=[
                {
                    # data to create a Achievement record
                    'name': 'hghjaaai',
                    'description': 'cajicjjdef',
                    'type': 'cefjaadec',
                    'criteria': Json({'ibbigdigd': True}),
                },
                {
                    # data to create a Achievement record
                    'name': 'bdiiiabbii',
                    'description': 'hfcfhhadh',
                    'type': 'bbihggdcji',
                    'criteria': Json({'hgjgibdgd': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Achievement record.

        Parameters
        ----------
        where
            Achievement filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The deleted Achievement record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().delete(
            where={
                'id': 1214295824,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Achievement record.

        Parameters
        ----------
        where
            Achievement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The found Achievement record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().find_unique(
            where={
                'id': 1021417993,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Achievement record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Achievement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The found Achievement record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().find_unique_or_raise(
            where={
                'id': 351503374,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
        include: Optional[types.AchievementInclude] = None,
        order: Optional[Union[types.AchievementOrderByInput, List[types.AchievementOrderByInput]]] = None,
        distinct: Optional[List[types.AchievementScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Achievement records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Achievement records returned
        skip
            Ignore the first N results
        where
            Achievement filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Achievement model
        order
            Order the returned Achievement records by any field
        distinct
            Filter Achievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Achievement]
            The list of all Achievement records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Achievement records
        achievements = await Achievement.prisma().find_many(take=10)

        # find the first 5 Achievement records ordered by the description field
        achievements = await Achievement.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
        include: Optional[types.AchievementInclude] = None,
        order: Optional[Union[types.AchievementOrderByInput, List[types.AchievementOrderByInput]]] = None,
        distinct: Optional[List[types.AchievementScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Achievement record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Achievement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Achievement model
        order
            Order the returned Achievement records by any field
        distinct
            Filter Achievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Achievement
            The first Achievement record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Achievement record ordered by the type field
        achievement = await Achievement.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
        include: Optional[types.AchievementInclude] = None,
        order: Optional[Union[types.AchievementOrderByInput, List[types.AchievementOrderByInput]]] = None,
        distinct: Optional[List[types.AchievementScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Achievement record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Achievement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Achievement model
        order
            Order the returned Achievement records by any field
        distinct
            Filter Achievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Achievement
            The first Achievement record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Achievement record ordered by the criteria field
        achievement = await Achievement.prisma().find_first_or_raise(
            skip=1,
            order={
                'criteria': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AchievementUpdateInput,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Achievement record.

        Parameters
        ----------
        data
            Achievement record data specifying what to update
        where
            Achievement filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The updated Achievement record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        achievement = await Achievement.prisma().update(
            where={
                'id': 1321184815,
            },
            data={
                # data to update the Achievement record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AchievementWhereUniqueInput,
        data: types.AchievementUpsertInput,
        include: Optional[types.AchievementInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Achievement filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The created or updated Achievement record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().upsert(
            where={
                'id': 369732668,
            },
            data={
                'create': {
                    'id': 369732668,
                    'name': 'bdiiiabbii',
                    'description': 'hfcfhhadh',
                    'type': 'bbihggdcji',
                    'criteria': Json({'hgjgibdgd': True}),
                },
                'update': {
                    'name': 'bdiiiabbii',
                    'description': 'hfcfhhadh',
                    'type': 'bbihggdcji',
                    'criteria': Json({'hgjgibdgd': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AchievementUpdateManyMutationInput,
        where: types.AchievementWhereInput,
    ) -> int:
        """Update multiple Achievement records

        Parameters
        ----------
        data
            Achievement data to update the selected Achievement records to
        where
            Filter to select the Achievement records to update

        Returns
        -------
        int
            The total number of Achievement records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Achievement records
        total = await Achievement.prisma().update_many(
            data={
                'reward': 1191235013
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Achievement records present in the database

        Parameters
        ----------
        select
            Select the Achievement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Achievement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AchievementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Achievement.prisma().count()

        # results: prisma.types.AchievementCountAggregateOutput
        results = await Achievement.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AchievementCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
    ) -> types.AchievementCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AchievementCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
    ) -> Union[int, types.AchievementCountAggregateOutput]:
        """Count the number of Achievement records present in the database

        Parameters
        ----------
        select
            Select the Achievement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Achievement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AchievementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Achievement.prisma().count()

        # results: prisma.types.AchievementCountAggregateOutput
        results = await Achievement.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AchievementCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AchievementWhereInput] = None
    ) -> int:
        """Delete multiple Achievement records.

        Parameters
        ----------
        where
            Optional Achievement filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Achievement records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Achievement records
        total = await Achievement.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AchievementScalarFieldKeys'],
        *,
        where: Optional['types.AchievementWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AchievementAvgAggregateInput'] = None,
        sum: Optional['types.AchievementSumAggregateInput'] = None,
        min: Optional['types.AchievementMinAggregateInput'] = None,
        max: Optional['types.AchievementMaxAggregateInput'] = None,
        having: Optional['types.AchievementScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AchievementCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AchievementScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AchievementScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AchievementGroupByOutput']:
        """Group Achievement records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Achievement fields to group records by
        where
            Achievement filter to select records
        take
            Limit the maximum number of Achievement records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AchievementGroupByOutput]
            A list of dictionaries representing the Achievement record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Achievement records by id values
        # and count how many records are in each group
        results = await Achievement.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserAchievementActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserAchievement]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserAchievement.prisma().query_raw(
            'SELECT * FROM UserAchievement WHERE id = $1',
            627561242,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserAchievement
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserAchievement.prisma().query_first(
            'SELECT * FROM UserAchievement WHERE userId = $1',
            1872952907,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserAchievementCreateInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserAchievement record.

        Parameters
        ----------
        data
            UserAchievement record data
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The created UserAchievement record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserAchievement record from just the required fields
        userachievement = await UserAchievement.prisma().create(
            data={
                # data to create a UserAchievement record
                'userId': 1793282088,
                'achievementId': 1814397249,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserAchievementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserAchievement records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserAchievement record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserAchievement.prisma().create_many(
            data=[
                {
                    # data to create a UserAchievement record
                    'userId': 1923090150,
                    'achievementId': 1277244455,
                },
                {
                    # data to create a UserAchievement record
                    'userId': 1160857300,
                    'achievementId': 361230461,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserAchievementWhereUniqueInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserAchievement record.

        Parameters
        ----------
        where
            UserAchievement filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The deleted UserAchievement record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userachievement = await UserAchievement.prisma().delete(
            where={
                'id': 1406511986,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserAchievementWhereUniqueInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserAchievement record.

        Parameters
        ----------
        where
            UserAchievement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The found UserAchievement record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userachievement = await UserAchievement.prisma().find_unique(
            where={
                'id': 1482877891,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserAchievementWhereUniqueInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserAchievement record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserAchievement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The found UserAchievement record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userachievement = await UserAchievement.prisma().find_unique_or_raise(
            where={
                'id': 566623296,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
        include: Optional[types.UserAchievementInclude] = None,
        order: Optional[Union[types.UserAchievementOrderByInput, List[types.UserAchievementOrderByInput]]] = None,
        distinct: Optional[List[types.UserAchievementScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserAchievement records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserAchievement records returned
        skip
            Ignore the first N results
        where
            UserAchievement filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAchievement model
        order
            Order the returned UserAchievement records by any field
        distinct
            Filter UserAchievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserAchievement]
            The list of all UserAchievement records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserAchievement records
        userachievements = await UserAchievement.prisma().find_many(take=10)

        # find the first 5 UserAchievement records ordered by the achievementId field
        userachievements = await UserAchievement.prisma().find_many(
            take=5,
            order={
                'achievementId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
        include: Optional[types.UserAchievementInclude] = None,
        order: Optional[Union[types.UserAchievementOrderByInput, List[types.UserAchievementOrderByInput]]] = None,
        distinct: Optional[List[types.UserAchievementScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserAchievement record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserAchievement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAchievement model
        order
            Order the returned UserAchievement records by any field
        distinct
            Filter UserAchievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserAchievement
            The first UserAchievement record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserAchievement record ordered by the achievedAt field
        userachievement = await UserAchievement.prisma().find_first(
            skip=1,
            order={
                'achievedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
        include: Optional[types.UserAchievementInclude] = None,
        order: Optional[Union[types.UserAchievementOrderByInput, List[types.UserAchievementOrderByInput]]] = None,
        distinct: Optional[List[types.UserAchievementScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserAchievement record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserAchievement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAchievement model
        order
            Order the returned UserAchievement records by any field
        distinct
            Filter UserAchievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserAchievement
            The first UserAchievement record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserAchievement record ordered by the id field
        userachievement = await UserAchievement.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserAchievementUpdateInput,
        where: types.UserAchievementWhereUniqueInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserAchievement record.

        Parameters
        ----------
        data
            UserAchievement record data specifying what to update
        where
            UserAchievement filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The updated UserAchievement record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userachievement = await UserAchievement.prisma().update(
            where={
                'id': 229119865,
            },
            data={
                # data to update the UserAchievement record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserAchievementWhereUniqueInput,
        data: types.UserAchievementUpsertInput,
        include: Optional[types.UserAchievementInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserAchievement filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The created or updated UserAchievement record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userachievement = await UserAchievement.prisma().upsert(
            where={
                'id': 1750011070,
            },
            data={
                'create': {
                    'id': 1750011070,
                    'userId': 1160857300,
                    'achievementId': 361230461,
                },
                'update': {
                    'userId': 1160857300,
                    'achievementId': 361230461,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserAchievementUpdateManyMutationInput,
        where: types.UserAchievementWhereInput,
    ) -> int:
        """Update multiple UserAchievement records

        Parameters
        ----------
        data
            UserAchievement data to update the selected UserAchievement records to
        where
            Filter to select the UserAchievement records to update

        Returns
        -------
        int
            The total number of UserAchievement records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserAchievement records
        total = await UserAchievement.prisma().update_many(
            data={
                'userId': 410943775
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserAchievement records present in the database

        Parameters
        ----------
        select
            Select the UserAchievement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserAchievement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserAchievementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserAchievement.prisma().count()

        # results: prisma.types.UserAchievementCountAggregateOutput
        results = await UserAchievement.prisma().count(
            select={
                '_all': True,
                'achievementId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserAchievementCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
    ) -> types.UserAchievementCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserAchievementCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
    ) -> Union[int, types.UserAchievementCountAggregateOutput]:
        """Count the number of UserAchievement records present in the database

        Parameters
        ----------
        select
            Select the UserAchievement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserAchievement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserAchievementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserAchievement.prisma().count()

        # results: prisma.types.UserAchievementCountAggregateOutput
        results = await UserAchievement.prisma().count(
            select={
                '_all': True,
                'achievedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserAchievementCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserAchievementWhereInput] = None
    ) -> int:
        """Delete multiple UserAchievement records.

        Parameters
        ----------
        where
            Optional UserAchievement filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserAchievement records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserAchievement records
        total = await UserAchievement.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserAchievementScalarFieldKeys'],
        *,
        where: Optional['types.UserAchievementWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAchievementAvgAggregateInput'] = None,
        sum: Optional['types.UserAchievementSumAggregateInput'] = None,
        min: Optional['types.UserAchievementMinAggregateInput'] = None,
        max: Optional['types.UserAchievementMaxAggregateInput'] = None,
        having: Optional['types.UserAchievementScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserAchievementCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserAchievementScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserAchievementScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserAchievementGroupByOutput']:
        """Group UserAchievement records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserAchievement fields to group records by
        where
            UserAchievement filter to select records
        take
            Limit the maximum number of UserAchievement records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserAchievementGroupByOutput]
            A list of dictionaries representing the UserAchievement record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserAchievement records by id values
        # and count how many records are in each group
        results = await UserAchievement.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class auth_groupActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.auth_group]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await auth_group.prisma().query_raw(
            'SELECT * FROM auth_group WHERE id = $1',
            909024364,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.auth_group
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await auth_group.prisma().query_first(
            'SELECT * FROM auth_group WHERE name = $1',
            'hffgbabgf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.auth_groupCreateInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> _PrismaModelT:
        """Create a new auth_group record.

        Parameters
        ----------
        data
            auth_group record data
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The created auth_group record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a auth_group record from just the required fields
        auth_group = await auth_group.prisma().create(
            data={
                # data to create a auth_group record
                'name': 'biacbiieja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.auth_groupCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple auth_group records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of auth_group record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await auth_group.prisma().create_many(
            data=[
                {
                    # data to create a auth_group record
                    'name': 'cjejbgbff',
                },
                {
                    # data to create a auth_group record
                    'name': 'fgeahddae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.auth_groupWhereUniqueInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single auth_group record.

        Parameters
        ----------
        where
            auth_group filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The deleted auth_group record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group = await auth_group.prisma().delete(
            where={
                'id': 380648625,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.auth_groupWhereUniqueInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique auth_group record.

        Parameters
        ----------
        where
            auth_group filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The found auth_group record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group = await auth_group.prisma().find_unique(
            where={
                'id': 1030616470,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.auth_groupWhereUniqueInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> _PrismaModelT:
        """Find a unique auth_group record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            auth_group filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The found auth_group record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group = await auth_group.prisma().find_unique_or_raise(
            where={
                'id': 816411927,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
        include: Optional[types.auth_groupInclude] = None,
        order: Optional[Union[types.auth_groupOrderByInput, List[types.auth_groupOrderByInput]]] = None,
        distinct: Optional[List[types.auth_groupScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple auth_group records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of auth_group records returned
        skip
            Ignore the first N results
        where
            auth_group filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group model
        order
            Order the returned auth_group records by any field
        distinct
            Filter auth_group records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.auth_group]
            The list of all auth_group records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 auth_group records
        auth_groups = await auth_group.prisma().find_many(take=10)

        # find the first 5 auth_group records ordered by the id field
        auth_groups = await auth_group.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
        include: Optional[types.auth_groupInclude] = None,
        order: Optional[Union[types.auth_groupOrderByInput, List[types.auth_groupOrderByInput]]] = None,
        distinct: Optional[List[types.auth_groupScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single auth_group record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_group filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group model
        order
            Order the returned auth_group records by any field
        distinct
            Filter auth_group records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_group
            The first auth_group record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_group record ordered by the name field
        auth_group = await auth_group.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
        include: Optional[types.auth_groupInclude] = None,
        order: Optional[Union[types.auth_groupOrderByInput, List[types.auth_groupOrderByInput]]] = None,
        distinct: Optional[List[types.auth_groupScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single auth_group record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_group filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group model
        order
            Order the returned auth_group records by any field
        distinct
            Filter auth_group records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_group
            The first auth_group record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_group record ordered by the id field
        auth_group = await auth_group.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.auth_groupUpdateInput,
        where: types.auth_groupWhereUniqueInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single auth_group record.

        Parameters
        ----------
        data
            auth_group record data specifying what to update
        where
            auth_group filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The updated auth_group record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auth_group = await auth_group.prisma().update(
            where={
                'id': 1084099844,
            },
            data={
                # data to update the auth_group record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.auth_groupWhereUniqueInput,
        data: types.auth_groupUpsertInput,
        include: Optional[types.auth_groupInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            auth_group filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The created or updated auth_group record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group = await auth_group.prisma().upsert(
            where={
                'id': 1079702253,
            },
            data={
                'create': {
                    'id': 1079702253,
                    'name': 'fgeahddae',
                },
                'update': {
                    'name': 'fgeahddae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.auth_groupUpdateManyMutationInput,
        where: types.auth_groupWhereInput,
    ) -> int:
        """Update multiple auth_group records

        Parameters
        ----------
        data
            auth_group data to update the selected auth_group records to
        where
            Filter to select the auth_group records to update

        Returns
        -------
        int
            The total number of auth_group records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all auth_group records
        total = await auth_group.prisma().update_many(
            data={
                'name': 'hffhfabhi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
    ) -> int:
        """Count the number of auth_group records present in the database

        Parameters
        ----------
        select
            Select the auth_group fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_group filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_groupCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_group.prisma().count()

        # results: prisma.types.auth_groupCountAggregateOutput
        results = await auth_group.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.auth_groupCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
    ) -> types.auth_groupCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.auth_groupCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
    ) -> Union[int, types.auth_groupCountAggregateOutput]:
        """Count the number of auth_group records present in the database

        Parameters
        ----------
        select
            Select the auth_group fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_group filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_groupCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_group.prisma().count()

        # results: prisma.types.auth_groupCountAggregateOutput
        results = await auth_group.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.auth_groupCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.auth_groupWhereInput] = None
    ) -> int:
        """Delete multiple auth_group records.

        Parameters
        ----------
        where
            Optional auth_group filter to find the records to be deleted

        Returns
        -------
        int
            The total number of auth_group records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all auth_group records
        total = await auth_group.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.auth_groupScalarFieldKeys'],
        *,
        where: Optional['types.auth_groupWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.auth_groupAvgAggregateInput'] = None,
        sum: Optional['types.auth_groupSumAggregateInput'] = None,
        min: Optional['types.auth_groupMinAggregateInput'] = None,
        max: Optional['types.auth_groupMaxAggregateInput'] = None,
        having: Optional['types.auth_groupScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.auth_groupCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.auth_groupScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.auth_groupScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.auth_groupGroupByOutput']:
        """Group auth_group records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar auth_group fields to group records by
        where
            auth_group filter to select records
        take
            Limit the maximum number of auth_group records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.auth_groupGroupByOutput]
            A list of dictionaries representing the auth_group record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group auth_group records by id values
        # and count how many records are in each group
        results = await auth_group.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class auth_group_permissionsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.auth_group_permissions]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await auth_group_permissions.prisma().query_raw(
            'SELECT * FROM auth_group_permissions WHERE id = $1',
            13544164452,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.auth_group_permissions
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await auth_group_permissions.prisma().query_first(
            'SELECT * FROM auth_group_permissions WHERE group_id = $1',
            259061104,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.auth_group_permissionsCreateInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> _PrismaModelT:
        """Create a new auth_group_permissions record.

        Parameters
        ----------
        data
            auth_group_permissions record data
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The created auth_group_permissions record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a auth_group_permissions record from just the required fields
        auth_group_permissions = await auth_group_permissions.prisma().create(
            data={
                # data to create a auth_group_permissions record
                'group_id': 1115738345,
                'permission_id': 1303781742,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.auth_group_permissionsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple auth_group_permissions records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of auth_group_permissions record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await auth_group_permissions.prisma().create_many(
            data=[
                {
                    # data to create a auth_group_permissions record
                    'group_id': 1573908495,
                    'permission_id': 1195899036,
                },
                {
                    # data to create a auth_group_permissions record
                    'group_id': 739021477,
                    'permission_id': 1722214010,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.auth_group_permissionsWhereUniqueInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single auth_group_permissions record.

        Parameters
        ----------
        where
            auth_group_permissions filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The deleted auth_group_permissions record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group_permissions = await auth_group_permissions.prisma().delete(
            where={
                'id': 15229643268,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.auth_group_permissionsWhereUniqueInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique auth_group_permissions record.

        Parameters
        ----------
        where
            auth_group_permissions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The found auth_group_permissions record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group_permissions = await auth_group_permissions.prisma().find_unique(
            where={
                'id': 6878142048,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.auth_group_permissionsWhereUniqueInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique auth_group_permissions record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            auth_group_permissions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The found auth_group_permissions record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group_permissions = await auth_group_permissions.prisma().find_unique_or_raise(
            where={
                'id': 17283182988,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
        include: Optional[types.auth_group_permissionsInclude] = None,
        order: Optional[Union[types.auth_group_permissionsOrderByInput, List[types.auth_group_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.auth_group_permissionsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple auth_group_permissions records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of auth_group_permissions records returned
        skip
            Ignore the first N results
        where
            auth_group_permissions filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model
        order
            Order the returned auth_group_permissions records by any field
        distinct
            Filter auth_group_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.auth_group_permissions]
            The list of all auth_group_permissions records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 auth_group_permissions records
        auth_group_permissions = await auth_group_permissions.prisma().find_many(take=10)

        # find the first 5 auth_group_permissions records ordered by the permission_id field
        auth_group_permissions = await auth_group_permissions.prisma().find_many(
            take=5,
            order={
                'permission_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
        include: Optional[types.auth_group_permissionsInclude] = None,
        order: Optional[Union[types.auth_group_permissionsOrderByInput, List[types.auth_group_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.auth_group_permissionsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single auth_group_permissions record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_group_permissions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model
        order
            Order the returned auth_group_permissions records by any field
        distinct
            Filter auth_group_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_group_permissions
            The first auth_group_permissions record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_group_permissions record ordered by the id field
        auth_group_permissions = await auth_group_permissions.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
        include: Optional[types.auth_group_permissionsInclude] = None,
        order: Optional[Union[types.auth_group_permissionsOrderByInput, List[types.auth_group_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.auth_group_permissionsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single auth_group_permissions record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_group_permissions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model
        order
            Order the returned auth_group_permissions records by any field
        distinct
            Filter auth_group_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_group_permissions
            The first auth_group_permissions record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_group_permissions record ordered by the group_id field
        auth_group_permissions = await auth_group_permissions.prisma().find_first_or_raise(
            skip=1,
            order={
                'group_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.auth_group_permissionsUpdateInput,
        where: types.auth_group_permissionsWhereUniqueInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single auth_group_permissions record.

        Parameters
        ----------
        data
            auth_group_permissions record data specifying what to update
        where
            auth_group_permissions filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The updated auth_group_permissions record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auth_group_permissions = await auth_group_permissions.prisma().update(
            where={
                'id': 14228865864,
            },
            data={
                # data to update the auth_group_permissions record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.auth_group_permissionsWhereUniqueInput,
        data: types.auth_group_permissionsUpsertInput,
        include: Optional[types.auth_group_permissionsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            auth_group_permissions filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The created or updated auth_group_permissions record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group_permissions = await auth_group_permissions.prisma().upsert(
            where={
                'id': 20330698836,
            },
            data={
                'create': {
                    'id': 20330698836,
                    'group_id': 739021477,
                    'permission_id': 1722214010,
                },
                'update': {
                    'group_id': 739021477,
                    'permission_id': 1722214010,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.auth_group_permissionsUpdateManyMutationInput,
        where: types.auth_group_permissionsWhereInput,
    ) -> int:
        """Update multiple auth_group_permissions records

        Parameters
        ----------
        data
            auth_group_permissions data to update the selected auth_group_permissions records to
        where
            Filter to select the auth_group_permissions records to update

        Returns
        -------
        int
            The total number of auth_group_permissions records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all auth_group_permissions records
        total = await auth_group_permissions.prisma().update_many(
            data={
                'permission_id': 1906360116
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of auth_group_permissions records present in the database

        Parameters
        ----------
        select
            Select the auth_group_permissions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_group_permissions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_group_permissionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_group_permissions.prisma().count()

        # results: prisma.types.auth_group_permissionsCountAggregateOutput
        results = await auth_group_permissions.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.auth_group_permissionsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
    ) -> types.auth_group_permissionsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.auth_group_permissionsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
    ) -> Union[int, types.auth_group_permissionsCountAggregateOutput]:
        """Count the number of auth_group_permissions records present in the database

        Parameters
        ----------
        select
            Select the auth_group_permissions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_group_permissions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_group_permissionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_group_permissions.prisma().count()

        # results: prisma.types.auth_group_permissionsCountAggregateOutput
        results = await auth_group_permissions.prisma().count(
            select={
                '_all': True,
                'group_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.auth_group_permissionsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.auth_group_permissionsWhereInput] = None
    ) -> int:
        """Delete multiple auth_group_permissions records.

        Parameters
        ----------
        where
            Optional auth_group_permissions filter to find the records to be deleted

        Returns
        -------
        int
            The total number of auth_group_permissions records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all auth_group_permissions records
        total = await auth_group_permissions.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.auth_group_permissionsScalarFieldKeys'],
        *,
        where: Optional['types.auth_group_permissionsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.auth_group_permissionsAvgAggregateInput'] = None,
        sum: Optional['types.auth_group_permissionsSumAggregateInput'] = None,
        min: Optional['types.auth_group_permissionsMinAggregateInput'] = None,
        max: Optional['types.auth_group_permissionsMaxAggregateInput'] = None,
        having: Optional['types.auth_group_permissionsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.auth_group_permissionsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.auth_group_permissionsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.auth_group_permissionsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.auth_group_permissionsGroupByOutput']:
        """Group auth_group_permissions records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar auth_group_permissions fields to group records by
        where
            auth_group_permissions filter to select records
        take
            Limit the maximum number of auth_group_permissions records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.auth_group_permissionsGroupByOutput]
            A list of dictionaries representing the auth_group_permissions record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group auth_group_permissions records by permission_id values
        # and count how many records are in each group
        results = await auth_group_permissions.prisma().group_by(
            ['permission_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class auth_permissionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.auth_permission]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await auth_permission.prisma().query_raw(
            'SELECT * FROM auth_permission WHERE id = $1',
            1911255389,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.auth_permission
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await auth_permission.prisma().query_first(
            'SELECT * FROM auth_permission WHERE name = $1',
            'begcgchdi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.auth_permissionCreateInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> _PrismaModelT:
        """Create a new auth_permission record.

        Parameters
        ----------
        data
            auth_permission record data
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The created auth_permission record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a auth_permission record from just the required fields
        auth_permission = await auth_permission.prisma().create(
            data={
                # data to create a auth_permission record
                'name': 'bhbjceagbb',
                'content_type_id': 1948555936,
                'codename': 'bdidcfdfjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.auth_permissionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple auth_permission records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of auth_permission record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await auth_permission.prisma().create_many(
            data=[
                {
                    # data to create a auth_permission record
                    'name': 'dfeggejja',
                    'content_type_id': 647166719,
                    'codename': 'dfhaijeie',
                },
                {
                    # data to create a auth_permission record
                    'name': 'gbcdjgicb',
                    'content_type_id': 1808130602,
                    'codename': 'bbfbheibcd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.auth_permissionWhereUniqueInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single auth_permission record.

        Parameters
        ----------
        where
            auth_permission filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The deleted auth_permission record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_permission = await auth_permission.prisma().delete(
            where={
                'id': 78060984,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.auth_permissionWhereUniqueInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique auth_permission record.

        Parameters
        ----------
        where
            auth_permission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The found auth_permission record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_permission = await auth_permission.prisma().find_unique(
            where={
                'id': 444983185,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.auth_permissionWhereUniqueInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique auth_permission record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            auth_permission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The found auth_permission record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_permission = await auth_permission.prisma().find_unique_or_raise(
            where={
                'id': 45610742,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
        include: Optional[types.auth_permissionInclude] = None,
        order: Optional[Union[types.auth_permissionOrderByInput, List[types.auth_permissionOrderByInput]]] = None,
        distinct: Optional[List[types.auth_permissionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple auth_permission records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of auth_permission records returned
        skip
            Ignore the first N results
        where
            auth_permission filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_permission model
        order
            Order the returned auth_permission records by any field
        distinct
            Filter auth_permission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.auth_permission]
            The list of all auth_permission records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 auth_permission records
        auth_permissions = await auth_permission.prisma().find_many(take=10)

        # find the first 5 auth_permission records ordered by the content_type_id field
        auth_permissions = await auth_permission.prisma().find_many(
            take=5,
            order={
                'content_type_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
        include: Optional[types.auth_permissionInclude] = None,
        order: Optional[Union[types.auth_permissionOrderByInput, List[types.auth_permissionOrderByInput]]] = None,
        distinct: Optional[List[types.auth_permissionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single auth_permission record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_permission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_permission model
        order
            Order the returned auth_permission records by any field
        distinct
            Filter auth_permission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_permission
            The first auth_permission record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_permission record ordered by the codename field
        auth_permission = await auth_permission.prisma().find_first(
            skip=1,
            order={
                'codename': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
        include: Optional[types.auth_permissionInclude] = None,
        order: Optional[Union[types.auth_permissionOrderByInput, List[types.auth_permissionOrderByInput]]] = None,
        distinct: Optional[List[types.auth_permissionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single auth_permission record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_permission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_permission model
        order
            Order the returned auth_permission records by any field
        distinct
            Filter auth_permission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_permission
            The first auth_permission record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_permission record ordered by the id field
        auth_permission = await auth_permission.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.auth_permissionUpdateInput,
        where: types.auth_permissionWhereUniqueInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single auth_permission record.

        Parameters
        ----------
        data
            auth_permission record data specifying what to update
        where
            auth_permission filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The updated auth_permission record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auth_permission = await auth_permission.prisma().update(
            where={
                'id': 769084151,
            },
            data={
                # data to update the auth_permission record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.auth_permissionWhereUniqueInput,
        data: types.auth_permissionUpsertInput,
        include: Optional[types.auth_permissionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            auth_permission filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The created or updated auth_permission record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_permission = await auth_permission.prisma().upsert(
            where={
                'id': 1334599012,
            },
            data={
                'create': {
                    'id': 1334599012,
                    'name': 'gbcdjgicb',
                    'content_type_id': 1808130602,
                    'codename': 'bbfbheibcd',
                },
                'update': {
                    'name': 'gbcdjgicb',
                    'content_type_id': 1808130602,
                    'codename': 'bbfbheibcd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.auth_permissionUpdateManyMutationInput,
        where: types.auth_permissionWhereInput,
    ) -> int:
        """Update multiple auth_permission records

        Parameters
        ----------
        data
            auth_permission data to update the selected auth_permission records to
        where
            Filter to select the auth_permission records to update

        Returns
        -------
        int
            The total number of auth_permission records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all auth_permission records
        total = await auth_permission.prisma().update_many(
            data={
                'name': 'bbbghgbadh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of auth_permission records present in the database

        Parameters
        ----------
        select
            Select the auth_permission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_permission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_permissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_permission.prisma().count()

        # results: prisma.types.auth_permissionCountAggregateOutput
        results = await auth_permission.prisma().count(
            select={
                '_all': True,
                'content_type_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.auth_permissionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
    ) -> types.auth_permissionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.auth_permissionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
    ) -> Union[int, types.auth_permissionCountAggregateOutput]:
        """Count the number of auth_permission records present in the database

        Parameters
        ----------
        select
            Select the auth_permission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_permission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_permissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_permission.prisma().count()

        # results: prisma.types.auth_permissionCountAggregateOutput
        results = await auth_permission.prisma().count(
            select={
                '_all': True,
                'codename': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.auth_permissionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.auth_permissionWhereInput] = None
    ) -> int:
        """Delete multiple auth_permission records.

        Parameters
        ----------
        where
            Optional auth_permission filter to find the records to be deleted

        Returns
        -------
        int
            The total number of auth_permission records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all auth_permission records
        total = await auth_permission.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.auth_permissionScalarFieldKeys'],
        *,
        where: Optional['types.auth_permissionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.auth_permissionAvgAggregateInput'] = None,
        sum: Optional['types.auth_permissionSumAggregateInput'] = None,
        min: Optional['types.auth_permissionMinAggregateInput'] = None,
        max: Optional['types.auth_permissionMaxAggregateInput'] = None,
        having: Optional['types.auth_permissionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.auth_permissionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.auth_permissionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.auth_permissionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.auth_permissionGroupByOutput']:
        """Group auth_permission records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar auth_permission fields to group records by
        where
            auth_permission filter to select records
        take
            Limit the maximum number of auth_permission records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.auth_permissionGroupByOutput]
            A list of dictionaries representing the auth_permission record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group auth_permission records by id values
        # and count how many records are in each group
        results = await auth_permission.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class authtoken_tokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.authtoken_token]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await authtoken_token.prisma().query_raw(
            'SELECT * FROM authtoken_token WHERE key = $1',
            'bbhcgagaic',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.authtoken_token
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await authtoken_token.prisma().query_first(
            'SELECT * FROM authtoken_token WHERE created = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.authtoken_tokenCreateInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new authtoken_token record.

        Parameters
        ----------
        data
            authtoken_token record data
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The created authtoken_token record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a authtoken_token record from just the required fields
        authtoken_token = await authtoken_token.prisma().create(
            data={
                # data to create a authtoken_token record
                'key': 'ddaabegbb',
                'created': datetime.datetime.utcnow(),
                'user_id': 21217873344,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.authtoken_tokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple authtoken_token records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of authtoken_token record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await authtoken_token.prisma().create_many(
            data=[
                {
                    # data to create a authtoken_token record
                    'key': 'hbgcihef',
                    'created': datetime.datetime.utcnow(),
                    'user_id': 669200808,
                },
                {
                    # data to create a authtoken_token record
                    'key': 'ibcadcejf',
                    'created': datetime.datetime.utcnow(),
                    'user_id': 15882746832,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.authtoken_tokenWhereUniqueInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single authtoken_token record.

        Parameters
        ----------
        where
            authtoken_token filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The deleted authtoken_token record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken_token = await authtoken_token.prisma().delete(
            where={
                'key': 'edhjgdfh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.authtoken_tokenWhereUniqueInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique authtoken_token record.

        Parameters
        ----------
        where
            authtoken_token filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The found authtoken_token record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken_token = await authtoken_token.prisma().find_unique(
            where={
                'key': 'bdeffdadda',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.authtoken_tokenWhereUniqueInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique authtoken_token record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            authtoken_token filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The found authtoken_token record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken_token = await authtoken_token.prisma().find_unique_or_raise(
            where={
                'key': 'bjgfdihchf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
        include: Optional[types.authtoken_tokenInclude] = None,
        order: Optional[Union[types.authtoken_tokenOrderByInput, List[types.authtoken_tokenOrderByInput]]] = None,
        distinct: Optional[List[types.authtoken_tokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple authtoken_token records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of authtoken_token records returned
        skip
            Ignore the first N results
        where
            authtoken_token filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned authtoken_token model
        order
            Order the returned authtoken_token records by any field
        distinct
            Filter authtoken_token records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.authtoken_token]
            The list of all authtoken_token records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 authtoken_token records
        authtoken_tokens = await authtoken_token.prisma().find_many(take=10)

        # find the first 5 authtoken_token records ordered by the user_id field
        authtoken_tokens = await authtoken_token.prisma().find_many(
            take=5,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
        include: Optional[types.authtoken_tokenInclude] = None,
        order: Optional[Union[types.authtoken_tokenOrderByInput, List[types.authtoken_tokenOrderByInput]]] = None,
        distinct: Optional[List[types.authtoken_tokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single authtoken_token record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            authtoken_token filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned authtoken_token model
        order
            Order the returned authtoken_token records by any field
        distinct
            Filter authtoken_token records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.authtoken_token
            The first authtoken_token record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second authtoken_token record ordered by the key field
        authtoken_token = await authtoken_token.prisma().find_first(
            skip=1,
            order={
                'key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
        include: Optional[types.authtoken_tokenInclude] = None,
        order: Optional[Union[types.authtoken_tokenOrderByInput, List[types.authtoken_tokenOrderByInput]]] = None,
        distinct: Optional[List[types.authtoken_tokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single authtoken_token record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            authtoken_token filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned authtoken_token model
        order
            Order the returned authtoken_token records by any field
        distinct
            Filter authtoken_token records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.authtoken_token
            The first authtoken_token record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second authtoken_token record ordered by the created field
        authtoken_token = await authtoken_token.prisma().find_first_or_raise(
            skip=1,
            order={
                'created': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.authtoken_tokenUpdateInput,
        where: types.authtoken_tokenWhereUniqueInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single authtoken_token record.

        Parameters
        ----------
        data
            authtoken_token record data specifying what to update
        where
            authtoken_token filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The updated authtoken_token record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        authtoken_token = await authtoken_token.prisma().update(
            where={
                'key': 'iaeihdeei',
            },
            data={
                # data to update the authtoken_token record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.authtoken_tokenWhereUniqueInput,
        data: types.authtoken_tokenUpsertInput,
        include: Optional[types.authtoken_tokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            authtoken_token filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The created or updated authtoken_token record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken_token = await authtoken_token.prisma().upsert(
            where={
                'key': 'bfggejgfbd',
            },
            data={
                'create': {
                    'key': 'bfggejgfbd',
                    'created': datetime.datetime.utcnow(),
                    'user_id': 15882746832,
                },
                'update': {
                    'created': datetime.datetime.utcnow(),
                    'user_id': 15882746832,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.authtoken_tokenUpdateManyMutationInput,
        where: types.authtoken_tokenWhereInput,
    ) -> int:
        """Update multiple authtoken_token records

        Parameters
        ----------
        data
            authtoken_token data to update the selected authtoken_token records to
        where
            Filter to select the authtoken_token records to update

        Returns
        -------
        int
            The total number of authtoken_token records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all authtoken_token records
        total = await authtoken_token.prisma().update_many(
            data={
                'user_id': 10200052680
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of authtoken_token records present in the database

        Parameters
        ----------
        select
            Select the authtoken_token fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            authtoken_token filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.authtoken_tokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await authtoken_token.prisma().count()

        # results: prisma.types.authtoken_tokenCountAggregateOutput
        results = await authtoken_token.prisma().count(
            select={
                '_all': True,
                'key': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.authtoken_tokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
    ) -> types.authtoken_tokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.authtoken_tokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
    ) -> Union[int, types.authtoken_tokenCountAggregateOutput]:
        """Count the number of authtoken_token records present in the database

        Parameters
        ----------
        select
            Select the authtoken_token fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            authtoken_token filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.authtoken_tokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await authtoken_token.prisma().count()

        # results: prisma.types.authtoken_tokenCountAggregateOutput
        results = await authtoken_token.prisma().count(
            select={
                '_all': True,
                'created': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.authtoken_tokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.authtoken_tokenWhereInput] = None
    ) -> int:
        """Delete multiple authtoken_token records.

        Parameters
        ----------
        where
            Optional authtoken_token filter to find the records to be deleted

        Returns
        -------
        int
            The total number of authtoken_token records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all authtoken_token records
        total = await authtoken_token.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.authtoken_tokenScalarFieldKeys'],
        *,
        where: Optional['types.authtoken_tokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.authtoken_tokenAvgAggregateInput'] = None,
        sum: Optional['types.authtoken_tokenSumAggregateInput'] = None,
        min: Optional['types.authtoken_tokenMinAggregateInput'] = None,
        max: Optional['types.authtoken_tokenMaxAggregateInput'] = None,
        having: Optional['types.authtoken_tokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.authtoken_tokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.authtoken_tokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.authtoken_tokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.authtoken_tokenGroupByOutput']:
        """Group authtoken_token records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar authtoken_token fields to group records by
        where
            authtoken_token filter to select records
        take
            Limit the maximum number of authtoken_token records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.authtoken_tokenGroupByOutput]
            A list of dictionaries representing the authtoken_token record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group authtoken_token records by user_id values
        # and count how many records are in each group
        results = await authtoken_token.prisma().group_by(
            ['user_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class books_agecategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.books_agecategory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await books_agecategory.prisma().query_raw(
            'SELECT * FROM books_agecategory WHERE id = $1',
            25312788180,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.books_agecategory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await books_agecategory.prisma().query_first(
            'SELECT * FROM books_agecategory WHERE name = $1',
            'bcicggedea',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.books_agecategoryCreateInput,
        include: Optional[types.books_agecategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new books_agecategory record.

        Parameters
        ----------
        data
            books_agecategory record data
        include
            Specifies which relations should be loaded on the returned books_agecategory model

        Returns
        -------
        prisma.models.books_agecategory
            The created books_agecategory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a books_agecategory record from just the required fields
        books_agecategory = await books_agecategory.prisma().create(
            data={
                # data to create a books_agecategory record
                'name': 'cebcdadjh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.books_agecategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple books_agecategory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of books_agecategory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await books_agecategory.prisma().create_many(
            data=[
                {
                    # data to create a books_agecategory record
                    'name': 'ehfigdgac',
                },
                {
                    # data to create a books_agecategory record
                    'name': 'bhbgccijjf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.books_agecategoryWhereUniqueInput,
        include: Optional[types.books_agecategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single books_agecategory record.

        Parameters
        ----------
        where
            books_agecategory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned books_agecategory model

        Returns
        -------
        prisma.models.books_agecategory
            The deleted books_agecategory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_agecategory = await books_agecategory.prisma().delete(
            where={
                'id': 22436834304,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.books_agecategoryWhereUniqueInput,
        include: Optional[types.books_agecategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique books_agecategory record.

        Parameters
        ----------
        where
            books_agecategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned books_agecategory model

        Returns
        -------
        prisma.models.books_agecategory
            The found books_agecategory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_agecategory = await books_agecategory.prisma().find_unique(
            where={
                'id': 19024101036,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.books_agecategoryWhereUniqueInput,
        include: Optional[types.books_agecategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique books_agecategory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            books_agecategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned books_agecategory model

        Returns
        -------
        prisma.models.books_agecategory
            The found books_agecategory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_agecategory = await books_agecategory.prisma().find_unique_or_raise(
            where={
                'id': 351263208,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_agecategoryWhereInput] = None,
        cursor: Optional[types.books_agecategoryWhereUniqueInput] = None,
        include: Optional[types.books_agecategoryInclude] = None,
        order: Optional[Union[types.books_agecategoryOrderByInput, List[types.books_agecategoryOrderByInput]]] = None,
        distinct: Optional[List[types.books_agecategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple books_agecategory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of books_agecategory records returned
        skip
            Ignore the first N results
        where
            books_agecategory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned books_agecategory model
        order
            Order the returned books_agecategory records by any field
        distinct
            Filter books_agecategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.books_agecategory]
            The list of all books_agecategory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 books_agecategory records
        books_agecategorys = await books_agecategory.prisma().find_many(take=10)

        # find the first 5 books_agecategory records ordered by the id field
        books_agecategorys = await books_agecategory.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.books_agecategoryWhereInput] = None,
        cursor: Optional[types.books_agecategoryWhereUniqueInput] = None,
        include: Optional[types.books_agecategoryInclude] = None,
        order: Optional[Union[types.books_agecategoryOrderByInput, List[types.books_agecategoryOrderByInput]]] = None,
        distinct: Optional[List[types.books_agecategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single books_agecategory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            books_agecategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned books_agecategory model
        order
            Order the returned books_agecategory records by any field
        distinct
            Filter books_agecategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.books_agecategory
            The first books_agecategory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second books_agecategory record ordered by the name field
        books_agecategory = await books_agecategory.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.books_agecategoryWhereInput] = None,
        cursor: Optional[types.books_agecategoryWhereUniqueInput] = None,
        include: Optional[types.books_agecategoryInclude] = None,
        order: Optional[Union[types.books_agecategoryOrderByInput, List[types.books_agecategoryOrderByInput]]] = None,
        distinct: Optional[List[types.books_agecategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single books_agecategory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            books_agecategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned books_agecategory model
        order
            Order the returned books_agecategory records by any field
        distinct
            Filter books_agecategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.books_agecategory
            The first books_agecategory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second books_agecategory record ordered by the id field
        books_agecategory = await books_agecategory.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.books_agecategoryUpdateInput,
        where: types.books_agecategoryWhereUniqueInput,
        include: Optional[types.books_agecategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single books_agecategory record.

        Parameters
        ----------
        data
            books_agecategory record data specifying what to update
        where
            books_agecategory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned books_agecategory model

        Returns
        -------
        prisma.models.books_agecategory
            The updated books_agecategory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        books_agecategory = await books_agecategory.prisma().update(
            where={
                'id': 19058309748,
            },
            data={
                # data to update the books_agecategory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.books_agecategoryWhereUniqueInput,
        data: types.books_agecategoryUpsertInput,
        include: Optional[types.books_agecategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            books_agecategory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned books_agecategory model

        Returns
        -------
        prisma.models.books_agecategory
            The created or updated books_agecategory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_agecategory = await books_agecategory.prisma().upsert(
            where={
                'id': 10780868112,
            },
            data={
                'create': {
                    'id': 10780868112,
                    'name': 'bhbgccijjf',
                },
                'update': {
                    'name': 'bhbgccijjf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.books_agecategoryUpdateManyMutationInput,
        where: types.books_agecategoryWhereInput,
    ) -> int:
        """Update multiple books_agecategory records

        Parameters
        ----------
        data
            books_agecategory data to update the selected books_agecategory records to
        where
            Filter to select the books_agecategory records to update

        Returns
        -------
        int
            The total number of books_agecategory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all books_agecategory records
        total = await books_agecategory.prisma().update_many(
            data={
                'name': 'hhhegahcf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_agecategoryWhereInput] = None,
        cursor: Optional[types.books_agecategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of books_agecategory records present in the database

        Parameters
        ----------
        select
            Select the books_agecategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            books_agecategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.books_agecategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await books_agecategory.prisma().count()

        # results: prisma.types.books_agecategoryCountAggregateOutput
        results = await books_agecategory.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.books_agecategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_agecategoryWhereInput] = None,
        cursor: Optional[types.books_agecategoryWhereUniqueInput] = None,
    ) -> types.books_agecategoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.books_agecategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_agecategoryWhereInput] = None,
        cursor: Optional[types.books_agecategoryWhereUniqueInput] = None,
    ) -> Union[int, types.books_agecategoryCountAggregateOutput]:
        """Count the number of books_agecategory records present in the database

        Parameters
        ----------
        select
            Select the books_agecategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            books_agecategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.books_agecategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await books_agecategory.prisma().count()

        # results: prisma.types.books_agecategoryCountAggregateOutput
        results = await books_agecategory.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.books_agecategoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.books_agecategoryWhereInput] = None
    ) -> int:
        """Delete multiple books_agecategory records.

        Parameters
        ----------
        where
            Optional books_agecategory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of books_agecategory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all books_agecategory records
        total = await books_agecategory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.books_agecategoryScalarFieldKeys'],
        *,
        where: Optional['types.books_agecategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.books_agecategoryAvgAggregateInput'] = None,
        sum: Optional['types.books_agecategorySumAggregateInput'] = None,
        min: Optional['types.books_agecategoryMinAggregateInput'] = None,
        max: Optional['types.books_agecategoryMaxAggregateInput'] = None,
        having: Optional['types.books_agecategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.books_agecategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.books_agecategoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.books_agecategoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.books_agecategoryGroupByOutput']:
        """Group books_agecategory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar books_agecategory fields to group records by
        where
            books_agecategory filter to select records
        take
            Limit the maximum number of books_agecategory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.books_agecategoryGroupByOutput]
            A list of dictionaries representing the books_agecategory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group books_agecategory records by id values
        # and count how many records are in each group
        results = await books_agecategory.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class books_bookActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.books_book]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await books_book.prisma().query_raw(
            'SELECT * FROM books_book WHERE id = $1',
            5254734456,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.books_book
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await books_book.prisma().query_first(
            'SELECT * FROM books_book WHERE title = $1',
            'djddecjhb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.books_bookCreateInput,
        include: Optional[types.books_bookInclude] = None
    ) -> _PrismaModelT:
        """Create a new books_book record.

        Parameters
        ----------
        data
            books_book record data
        include
            Specifies which relations should be loaded on the returned books_book model

        Returns
        -------
        prisma.models.books_book
            The created books_book record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a books_book record from just the required fields
        books_book = await books_book.prisma().create(
            data={
                # data to create a books_book record
                'title': 'bgdicjhie',
                'author': 'ceibfcgij',
                'cover': 'debhbfada',
                'description': 'bgjchggecd',
                'is_premium': True,
                'rating': 1697895597.128637,
                'series': 'igefhgdhb',
                'translator': 'ejbiifbae',
                'created_at': datetime.datetime.utcnow(),
                'updated_at': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.books_bookCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple books_book records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of books_book record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await books_book.prisma().create_many(
            data=[
                {
                    # data to create a books_book record
                    'title': 'djcfgedjd',
                    'author': 'bdbjcdegag',
                    'cover': 'hbchfebch',
                    'description': 'bcjjffegfc',
                    'is_premium': False,
                    'rating': 811900218.39602,
                    'series': 'geeeegace',
                    'translator': 'bbgdigchd',
                    'created_at': datetime.datetime.utcnow(),
                    'updated_at': datetime.datetime.utcnow(),
                },
                {
                    # data to create a books_book record
                    'title': 'dajcifgdi',
                    'author': 'ccedhdbj',
                    'cover': 'bjaabjjjce',
                    'description': 'cafhdcdcjd',
                    'is_premium': True,
                    'rating': 2052132707.135514,
                    'series': 'ieahjgeb',
                    'translator': 'hfeeddceg',
                    'created_at': datetime.datetime.utcnow(),
                    'updated_at': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.books_bookWhereUniqueInput,
        include: Optional[types.books_bookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single books_book record.

        Parameters
        ----------
        where
            books_book filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned books_book model

        Returns
        -------
        prisma.models.books_book
            The deleted books_book record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_book = await books_book.prisma().delete(
            where={
                'id': 3771134196,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.books_bookWhereUniqueInput,
        include: Optional[types.books_bookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique books_book record.

        Parameters
        ----------
        where
            books_book filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned books_book model

        Returns
        -------
        prisma.models.books_book
            The found books_book record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_book = await books_book.prisma().find_unique(
            where={
                'id': 2732143248,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.books_bookWhereUniqueInput,
        include: Optional[types.books_bookInclude] = None
    ) -> _PrismaModelT:
        """Find a unique books_book record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            books_book filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned books_book model

        Returns
        -------
        prisma.models.books_book
            The found books_book record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_book = await books_book.prisma().find_unique_or_raise(
            where={
                'id': 5087996412,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_bookWhereInput] = None,
        cursor: Optional[types.books_bookWhereUniqueInput] = None,
        include: Optional[types.books_bookInclude] = None,
        order: Optional[Union[types.books_bookOrderByInput, List[types.books_bookOrderByInput]]] = None,
        distinct: Optional[List[types.books_bookScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple books_book records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of books_book records returned
        skip
            Ignore the first N results
        where
            books_book filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned books_book model
        order
            Order the returned books_book records by any field
        distinct
            Filter books_book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.books_book]
            The list of all books_book records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 books_book records
        books_books = await books_book.prisma().find_many(take=10)

        # find the first 5 books_book records ordered by the author field
        books_books = await books_book.prisma().find_many(
            take=5,
            order={
                'author': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.books_bookWhereInput] = None,
        cursor: Optional[types.books_bookWhereUniqueInput] = None,
        include: Optional[types.books_bookInclude] = None,
        order: Optional[Union[types.books_bookOrderByInput, List[types.books_bookOrderByInput]]] = None,
        distinct: Optional[List[types.books_bookScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single books_book record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            books_book filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned books_book model
        order
            Order the returned books_book records by any field
        distinct
            Filter books_book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.books_book
            The first books_book record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second books_book record ordered by the cover field
        books_book = await books_book.prisma().find_first(
            skip=1,
            order={
                'cover': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.books_bookWhereInput] = None,
        cursor: Optional[types.books_bookWhereUniqueInput] = None,
        include: Optional[types.books_bookInclude] = None,
        order: Optional[Union[types.books_bookOrderByInput, List[types.books_bookOrderByInput]]] = None,
        distinct: Optional[List[types.books_bookScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single books_book record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            books_book filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned books_book model
        order
            Order the returned books_book records by any field
        distinct
            Filter books_book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.books_book
            The first books_book record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second books_book record ordered by the description field
        books_book = await books_book.prisma().find_first_or_raise(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.books_bookUpdateInput,
        where: types.books_bookWhereUniqueInput,
        include: Optional[types.books_bookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single books_book record.

        Parameters
        ----------
        data
            books_book record data specifying what to update
        where
            books_book filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned books_book model

        Returns
        -------
        prisma.models.books_book
            The updated books_book record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        books_book = await books_book.prisma().update(
            where={
                'id': 2163305208,
            },
            data={
                # data to update the books_book record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.books_bookWhereUniqueInput,
        data: types.books_bookUpsertInput,
        include: Optional[types.books_bookInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            books_book filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned books_book model

        Returns
        -------
        prisma.models.books_book
            The created or updated books_book record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_book = await books_book.prisma().upsert(
            where={
                'id': 691297860,
            },
            data={
                'create': {
                    'id': 691297860,
                    'title': 'dajcifgdi',
                    'author': 'ccedhdbj',
                    'cover': 'bjaabjjjce',
                    'description': 'cafhdcdcjd',
                    'is_premium': True,
                    'rating': 2052132707.135514,
                    'series': 'ieahjgeb',
                    'translator': 'hfeeddceg',
                    'created_at': datetime.datetime.utcnow(),
                    'updated_at': datetime.datetime.utcnow(),
                },
                'update': {
                    'title': 'dajcifgdi',
                    'author': 'ccedhdbj',
                    'cover': 'bjaabjjjce',
                    'description': 'cafhdcdcjd',
                    'is_premium': True,
                    'rating': 2052132707.135514,
                    'series': 'ieahjgeb',
                    'translator': 'hfeeddceg',
                    'created_at': datetime.datetime.utcnow(),
                    'updated_at': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.books_bookUpdateManyMutationInput,
        where: types.books_bookWhereInput,
    ) -> int:
        """Update multiple books_book records

        Parameters
        ----------
        data
            books_book data to update the selected books_book records to
        where
            Filter to select the books_book records to update

        Returns
        -------
        int
            The total number of books_book records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all books_book records
        total = await books_book.prisma().update_many(
            data={
                'is_premium': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_bookWhereInput] = None,
        cursor: Optional[types.books_bookWhereUniqueInput] = None,
    ) -> int:
        """Count the number of books_book records present in the database

        Parameters
        ----------
        select
            Select the books_book fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            books_book filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.books_bookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await books_book.prisma().count()

        # results: prisma.types.books_bookCountAggregateOutput
        results = await books_book.prisma().count(
            select={
                '_all': True,
                'rating': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.books_bookCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_bookWhereInput] = None,
        cursor: Optional[types.books_bookWhereUniqueInput] = None,
    ) -> types.books_bookCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.books_bookCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_bookWhereInput] = None,
        cursor: Optional[types.books_bookWhereUniqueInput] = None,
    ) -> Union[int, types.books_bookCountAggregateOutput]:
        """Count the number of books_book records present in the database

        Parameters
        ----------
        select
            Select the books_book fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            books_book filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.books_bookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await books_book.prisma().count()

        # results: prisma.types.books_bookCountAggregateOutput
        results = await books_book.prisma().count(
            select={
                '_all': True,
                'litres_rating': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.books_bookCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.books_bookWhereInput] = None
    ) -> int:
        """Delete multiple books_book records.

        Parameters
        ----------
        where
            Optional books_book filter to find the records to be deleted

        Returns
        -------
        int
            The total number of books_book records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all books_book records
        total = await books_book.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.books_bookScalarFieldKeys'],
        *,
        where: Optional['types.books_bookWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.books_bookAvgAggregateInput'] = None,
        sum: Optional['types.books_bookSumAggregateInput'] = None,
        min: Optional['types.books_bookMinAggregateInput'] = None,
        max: Optional['types.books_bookMaxAggregateInput'] = None,
        having: Optional['types.books_bookScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.books_bookCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.books_bookScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.books_bookScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.books_bookGroupByOutput']:
        """Group books_book records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar books_book fields to group records by
        where
            books_book filter to select records
        take
            Limit the maximum number of books_book records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.books_bookGroupByOutput]
            A list of dictionaries representing the books_book record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group books_book records by series values
        # and count how many records are in each group
        results = await books_book.prisma().group_by(
            ['series'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class books_genreActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.books_genre]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await books_genre.prisma().query_raw(
            'SELECT * FROM books_genre WHERE id = $1',
            23698382796,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.books_genre
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await books_genre.prisma().query_first(
            'SELECT * FROM books_genre WHERE name = $1',
            'bjejigcdcg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.books_genreCreateInput,
        include: Optional[types.books_genreInclude] = None
    ) -> _PrismaModelT:
        """Create a new books_genre record.

        Parameters
        ----------
        data
            books_genre record data
        include
            Specifies which relations should be loaded on the returned books_genre model

        Returns
        -------
        prisma.models.books_genre
            The created books_genre record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a books_genre record from just the required fields
        books_genre = await books_genre.prisma().create(
            data={
                # data to create a books_genre record
                'name': 'bifiiibcah',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.books_genreCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple books_genre records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of books_genre record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await books_genre.prisma().create_many(
            data=[
                {
                    # data to create a books_genre record
                    'name': 'dbjibjdaa',
                },
                {
                    # data to create a books_genre record
                    'name': 'dgijbdiaf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.books_genreWhereUniqueInput,
        include: Optional[types.books_genreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single books_genre record.

        Parameters
        ----------
        where
            books_genre filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned books_genre model

        Returns
        -------
        prisma.models.books_genre
            The deleted books_genre record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_genre = await books_genre.prisma().delete(
            where={
                'id': 1758103320,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.books_genreWhereUniqueInput,
        include: Optional[types.books_genreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique books_genre record.

        Parameters
        ----------
        where
            books_genre filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned books_genre model

        Returns
        -------
        prisma.models.books_genre
            The found books_genre record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_genre = await books_genre.prisma().find_unique(
            where={
                'id': 16776632292,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.books_genreWhereUniqueInput,
        include: Optional[types.books_genreInclude] = None
    ) -> _PrismaModelT:
        """Find a unique books_genre record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            books_genre filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned books_genre model

        Returns
        -------
        prisma.models.books_genre
            The found books_genre record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_genre = await books_genre.prisma().find_unique_or_raise(
            where={
                'id': 18989115072,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_genreWhereInput] = None,
        cursor: Optional[types.books_genreWhereUniqueInput] = None,
        include: Optional[types.books_genreInclude] = None,
        order: Optional[Union[types.books_genreOrderByInput, List[types.books_genreOrderByInput]]] = None,
        distinct: Optional[List[types.books_genreScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple books_genre records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of books_genre records returned
        skip
            Ignore the first N results
        where
            books_genre filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned books_genre model
        order
            Order the returned books_genre records by any field
        distinct
            Filter books_genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.books_genre]
            The list of all books_genre records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 books_genre records
        books_genres = await books_genre.prisma().find_many(take=10)

        # find the first 5 books_genre records ordered by the id field
        books_genres = await books_genre.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.books_genreWhereInput] = None,
        cursor: Optional[types.books_genreWhereUniqueInput] = None,
        include: Optional[types.books_genreInclude] = None,
        order: Optional[Union[types.books_genreOrderByInput, List[types.books_genreOrderByInput]]] = None,
        distinct: Optional[List[types.books_genreScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single books_genre record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            books_genre filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned books_genre model
        order
            Order the returned books_genre records by any field
        distinct
            Filter books_genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.books_genre
            The first books_genre record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second books_genre record ordered by the name field
        books_genre = await books_genre.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.books_genreWhereInput] = None,
        cursor: Optional[types.books_genreWhereUniqueInput] = None,
        include: Optional[types.books_genreInclude] = None,
        order: Optional[Union[types.books_genreOrderByInput, List[types.books_genreOrderByInput]]] = None,
        distinct: Optional[List[types.books_genreScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single books_genre record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            books_genre filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned books_genre model
        order
            Order the returned books_genre records by any field
        distinct
            Filter books_genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.books_genre
            The first books_genre record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second books_genre record ordered by the id field
        books_genre = await books_genre.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.books_genreUpdateInput,
        where: types.books_genreWhereUniqueInput,
        include: Optional[types.books_genreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single books_genre record.

        Parameters
        ----------
        data
            books_genre record data specifying what to update
        where
            books_genre filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned books_genre model

        Returns
        -------
        prisma.models.books_genre
            The updated books_genre record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        books_genre = await books_genre.prisma().update(
            where={
                'id': 2639331948,
            },
            data={
                # data to update the books_genre record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.books_genreWhereUniqueInput,
        data: types.books_genreUpsertInput,
        include: Optional[types.books_genreInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            books_genre filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned books_genre model

        Returns
        -------
        prisma.models.books_genre
            The created or updated books_genre record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        books_genre = await books_genre.prisma().upsert(
            where={
                'id': 4123341480,
            },
            data={
                'create': {
                    'id': 4123341480,
                    'name': 'dgijbdiaf',
                },
                'update': {
                    'name': 'dgijbdiaf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.books_genreUpdateManyMutationInput,
        where: types.books_genreWhereInput,
    ) -> int:
        """Update multiple books_genre records

        Parameters
        ----------
        data
            books_genre data to update the selected books_genre records to
        where
            Filter to select the books_genre records to update

        Returns
        -------
        int
            The total number of books_genre records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all books_genre records
        total = await books_genre.prisma().update_many(
            data={
                'name': 'cabiahchj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_genreWhereInput] = None,
        cursor: Optional[types.books_genreWhereUniqueInput] = None,
    ) -> int:
        """Count the number of books_genre records present in the database

        Parameters
        ----------
        select
            Select the books_genre fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            books_genre filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.books_genreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await books_genre.prisma().count()

        # results: prisma.types.books_genreCountAggregateOutput
        results = await books_genre.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.books_genreCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_genreWhereInput] = None,
        cursor: Optional[types.books_genreWhereUniqueInput] = None,
    ) -> types.books_genreCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.books_genreCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.books_genreWhereInput] = None,
        cursor: Optional[types.books_genreWhereUniqueInput] = None,
    ) -> Union[int, types.books_genreCountAggregateOutput]:
        """Count the number of books_genre records present in the database

        Parameters
        ----------
        select
            Select the books_genre fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            books_genre filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.books_genreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await books_genre.prisma().count()

        # results: prisma.types.books_genreCountAggregateOutput
        results = await books_genre.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.books_genreCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.books_genreWhereInput] = None
    ) -> int:
        """Delete multiple books_genre records.

        Parameters
        ----------
        where
            Optional books_genre filter to find the records to be deleted

        Returns
        -------
        int
            The total number of books_genre records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all books_genre records
        total = await books_genre.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.books_genreScalarFieldKeys'],
        *,
        where: Optional['types.books_genreWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.books_genreAvgAggregateInput'] = None,
        sum: Optional['types.books_genreSumAggregateInput'] = None,
        min: Optional['types.books_genreMinAggregateInput'] = None,
        max: Optional['types.books_genreMaxAggregateInput'] = None,
        having: Optional['types.books_genreScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.books_genreCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.books_genreScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.books_genreScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.books_genreGroupByOutput']:
        """Group books_genre records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar books_genre fields to group records by
        where
            books_genre filter to select records
        take
            Limit the maximum number of books_genre records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.books_genreGroupByOutput]
            A list of dictionaries representing the books_genre record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group books_genre records by id values
        # and count how many records are in each group
        results = await books_genre.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class django_admin_logActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.django_admin_log]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await django_admin_log.prisma().query_raw(
            'SELECT * FROM django_admin_log WHERE id = $1',
            261422524,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.django_admin_log
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await django_admin_log.prisma().query_first(
            'SELECT * FROM django_admin_log WHERE action_time = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.django_admin_logCreateInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> _PrismaModelT:
        """Create a new django_admin_log record.

        Parameters
        ----------
        data
            django_admin_log record data
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The created django_admin_log record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a django_admin_log record from just the required fields
        django_admin_log = await django_admin_log.prisma().create(
            data={
                # data to create a django_admin_log record
                'action_time': datetime.datetime.utcnow(),
                'object_repr': 'fcjcagef',
                'action_flag': 1637040282,
                'change_message': 'caffafcheh',
                'user_id': 718975968,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.django_admin_logCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple django_admin_log records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of django_admin_log record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await django_admin_log.prisma().create_many(
            data=[
                {
                    # data to create a django_admin_log record
                    'action_time': datetime.datetime.utcnow(),
                    'object_repr': 'bdiifhbieb',
                    'action_flag': 232049766,
                    'change_message': 'jbijgfbfj',
                    'user_id': 7981720560,
                },
                {
                    # data to create a django_admin_log record
                    'action_time': datetime.datetime.utcnow(),
                    'object_repr': 'djjejdaj',
                    'action_flag': 1901152498,
                    'change_message': 'bgchfbjibb',
                    'user_id': 13130728704,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.django_admin_logWhereUniqueInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single django_admin_log record.

        Parameters
        ----------
        where
            django_admin_log filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The deleted django_admin_log record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_admin_log = await django_admin_log.prisma().delete(
            where={
                'id': 356020985,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.django_admin_logWhereUniqueInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique django_admin_log record.

        Parameters
        ----------
        where
            django_admin_log filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The found django_admin_log record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_admin_log = await django_admin_log.prisma().find_unique(
            where={
                'id': 1638335038,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.django_admin_logWhereUniqueInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> _PrismaModelT:
        """Find a unique django_admin_log record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            django_admin_log filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The found django_admin_log record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_admin_log = await django_admin_log.prisma().find_unique_or_raise(
            where={
                'id': 1891567775,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
        include: Optional[types.django_admin_logInclude] = None,
        order: Optional[Union[types.django_admin_logOrderByInput, List[types.django_admin_logOrderByInput]]] = None,
        distinct: Optional[List[types.django_admin_logScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple django_admin_log records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of django_admin_log records returned
        skip
            Ignore the first N results
        where
            django_admin_log filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_admin_log model
        order
            Order the returned django_admin_log records by any field
        distinct
            Filter django_admin_log records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.django_admin_log]
            The list of all django_admin_log records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 django_admin_log records
        django_admin_logs = await django_admin_log.prisma().find_many(take=10)

        # find the first 5 django_admin_log records ordered by the object_id field
        django_admin_logs = await django_admin_log.prisma().find_many(
            take=5,
            order={
                'object_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
        include: Optional[types.django_admin_logInclude] = None,
        order: Optional[Union[types.django_admin_logOrderByInput, List[types.django_admin_logOrderByInput]]] = None,
        distinct: Optional[List[types.django_admin_logScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single django_admin_log record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_admin_log filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_admin_log model
        order
            Order the returned django_admin_log records by any field
        distinct
            Filter django_admin_log records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_admin_log
            The first django_admin_log record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_admin_log record ordered by the object_repr field
        django_admin_log = await django_admin_log.prisma().find_first(
            skip=1,
            order={
                'object_repr': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
        include: Optional[types.django_admin_logInclude] = None,
        order: Optional[Union[types.django_admin_logOrderByInput, List[types.django_admin_logOrderByInput]]] = None,
        distinct: Optional[List[types.django_admin_logScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single django_admin_log record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_admin_log filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_admin_log model
        order
            Order the returned django_admin_log records by any field
        distinct
            Filter django_admin_log records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_admin_log
            The first django_admin_log record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_admin_log record ordered by the action_flag field
        django_admin_log = await django_admin_log.prisma().find_first_or_raise(
            skip=1,
            order={
                'action_flag': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.django_admin_logUpdateInput,
        where: types.django_admin_logWhereUniqueInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single django_admin_log record.

        Parameters
        ----------
        data
            django_admin_log record data specifying what to update
        where
            django_admin_log filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The updated django_admin_log record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        django_admin_log = await django_admin_log.prisma().update(
            where={
                'id': 1072778732,
            },
            data={
                # data to update the django_admin_log record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.django_admin_logWhereUniqueInput,
        data: types.django_admin_logUpsertInput,
        include: Optional[types.django_admin_logInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            django_admin_log filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The created or updated django_admin_log record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_admin_log = await django_admin_log.prisma().upsert(
            where={
                'id': 1879328181,
            },
            data={
                'create': {
                    'id': 1879328181,
                    'action_time': datetime.datetime.utcnow(),
                    'object_repr': 'djjejdaj',
                    'action_flag': 1901152498,
                    'change_message': 'bgchfbjibb',
                    'user_id': 13130728704,
                },
                'update': {
                    'action_time': datetime.datetime.utcnow(),
                    'object_repr': 'djjejdaj',
                    'action_flag': 1901152498,
                    'change_message': 'bgchfbjibb',
                    'user_id': 13130728704,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.django_admin_logUpdateManyMutationInput,
        where: types.django_admin_logWhereInput,
    ) -> int:
        """Update multiple django_admin_log records

        Parameters
        ----------
        data
            django_admin_log data to update the selected django_admin_log records to
        where
            Filter to select the django_admin_log records to update

        Returns
        -------
        int
            The total number of django_admin_log records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all django_admin_log records
        total = await django_admin_log.prisma().update_many(
            data={
                'change_message': 'bfhhjbbdha'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
    ) -> int:
        """Count the number of django_admin_log records present in the database

        Parameters
        ----------
        select
            Select the django_admin_log fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_admin_log filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_admin_logCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_admin_log.prisma().count()

        # results: prisma.types.django_admin_logCountAggregateOutput
        results = await django_admin_log.prisma().count(
            select={
                '_all': True,
                'content_type_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.django_admin_logCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
    ) -> types.django_admin_logCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.django_admin_logCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
    ) -> Union[int, types.django_admin_logCountAggregateOutput]:
        """Count the number of django_admin_log records present in the database

        Parameters
        ----------
        select
            Select the django_admin_log fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_admin_log filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_admin_logCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_admin_log.prisma().count()

        # results: prisma.types.django_admin_logCountAggregateOutput
        results = await django_admin_log.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.django_admin_logCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.django_admin_logWhereInput] = None
    ) -> int:
        """Delete multiple django_admin_log records.

        Parameters
        ----------
        where
            Optional django_admin_log filter to find the records to be deleted

        Returns
        -------
        int
            The total number of django_admin_log records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all django_admin_log records
        total = await django_admin_log.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.django_admin_logScalarFieldKeys'],
        *,
        where: Optional['types.django_admin_logWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.django_admin_logAvgAggregateInput'] = None,
        sum: Optional['types.django_admin_logSumAggregateInput'] = None,
        min: Optional['types.django_admin_logMinAggregateInput'] = None,
        max: Optional['types.django_admin_logMaxAggregateInput'] = None,
        having: Optional['types.django_admin_logScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.django_admin_logCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.django_admin_logScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.django_admin_logScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.django_admin_logGroupByOutput']:
        """Group django_admin_log records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar django_admin_log fields to group records by
        where
            django_admin_log filter to select records
        take
            Limit the maximum number of django_admin_log records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.django_admin_logGroupByOutput]
            A list of dictionaries representing the django_admin_log record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group django_admin_log records by id values
        # and count how many records are in each group
        results = await django_admin_log.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class django_content_typeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.django_content_type]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await django_content_type.prisma().query_raw(
            'SELECT * FROM django_content_type WHERE id = $1',
            504729531,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.django_content_type
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await django_content_type.prisma().query_first(
            'SELECT * FROM django_content_type WHERE app_label = $1',
            'bbaiefbee',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.django_content_typeCreateInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> _PrismaModelT:
        """Create a new django_content_type record.

        Parameters
        ----------
        data
            django_content_type record data
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The created django_content_type record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a django_content_type record from just the required fields
        django_content_type = await django_content_type.prisma().create(
            data={
                # data to create a django_content_type record
                'app_label': 'bdaacgjbaf',
                'model': 'biibaighec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.django_content_typeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple django_content_type records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of django_content_type record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await django_content_type.prisma().create_many(
            data=[
                {
                    # data to create a django_content_type record
                    'app_label': 'baicdfeidj',
                    'model': 'befgiciadg',
                },
                {
                    # data to create a django_content_type record
                    'app_label': 'cbcehahedh',
                    'model': 'bcjihiaide',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.django_content_typeWhereUniqueInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single django_content_type record.

        Parameters
        ----------
        where
            django_content_type filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The deleted django_content_type record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_content_type = await django_content_type.prisma().delete(
            where={
                'id': 1065892659,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.django_content_typeWhereUniqueInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique django_content_type record.

        Parameters
        ----------
        where
            django_content_type filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The found django_content_type record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_content_type = await django_content_type.prisma().find_unique(
            where={
                'id': 1266478832,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.django_content_typeWhereUniqueInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique django_content_type record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            django_content_type filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The found django_content_type record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_content_type = await django_content_type.prisma().find_unique_or_raise(
            where={
                'id': 1923026025,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
        include: Optional[types.django_content_typeInclude] = None,
        order: Optional[Union[types.django_content_typeOrderByInput, List[types.django_content_typeOrderByInput]]] = None,
        distinct: Optional[List[types.django_content_typeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple django_content_type records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of django_content_type records returned
        skip
            Ignore the first N results
        where
            django_content_type filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_content_type model
        order
            Order the returned django_content_type records by any field
        distinct
            Filter django_content_type records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.django_content_type]
            The list of all django_content_type records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 django_content_type records
        django_content_types = await django_content_type.prisma().find_many(take=10)

        # find the first 5 django_content_type records ordered by the model field
        django_content_types = await django_content_type.prisma().find_many(
            take=5,
            order={
                'model': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
        include: Optional[types.django_content_typeInclude] = None,
        order: Optional[Union[types.django_content_typeOrderByInput, List[types.django_content_typeOrderByInput]]] = None,
        distinct: Optional[List[types.django_content_typeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single django_content_type record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_content_type filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_content_type model
        order
            Order the returned django_content_type records by any field
        distinct
            Filter django_content_type records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_content_type
            The first django_content_type record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_content_type record ordered by the id field
        django_content_type = await django_content_type.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
        include: Optional[types.django_content_typeInclude] = None,
        order: Optional[Union[types.django_content_typeOrderByInput, List[types.django_content_typeOrderByInput]]] = None,
        distinct: Optional[List[types.django_content_typeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single django_content_type record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_content_type filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_content_type model
        order
            Order the returned django_content_type records by any field
        distinct
            Filter django_content_type records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_content_type
            The first django_content_type record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_content_type record ordered by the app_label field
        django_content_type = await django_content_type.prisma().find_first_or_raise(
            skip=1,
            order={
                'app_label': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.django_content_typeUpdateInput,
        where: types.django_content_typeWhereUniqueInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single django_content_type record.

        Parameters
        ----------
        data
            django_content_type record data specifying what to update
        where
            django_content_type filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The updated django_content_type record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        django_content_type = await django_content_type.prisma().update(
            where={
                'id': 95844078,
            },
            data={
                # data to update the django_content_type record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.django_content_typeWhereUniqueInput,
        data: types.django_content_typeUpsertInput,
        include: Optional[types.django_content_typeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            django_content_type filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The created or updated django_content_type record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_content_type = await django_content_type.prisma().upsert(
            where={
                'id': 1895913359,
            },
            data={
                'create': {
                    'id': 1895913359,
                    'app_label': 'cbcehahedh',
                    'model': 'bcjihiaide',
                },
                'update': {
                    'app_label': 'cbcehahedh',
                    'model': 'bcjihiaide',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.django_content_typeUpdateManyMutationInput,
        where: types.django_content_typeWhereInput,
    ) -> int:
        """Update multiple django_content_type records

        Parameters
        ----------
        data
            django_content_type data to update the selected django_content_type records to
        where
            Filter to select the django_content_type records to update

        Returns
        -------
        int
            The total number of django_content_type records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all django_content_type records
        total = await django_content_type.prisma().update_many(
            data={
                'model': 'cdcdjdcee'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of django_content_type records present in the database

        Parameters
        ----------
        select
            Select the django_content_type fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_content_type filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_content_typeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_content_type.prisma().count()

        # results: prisma.types.django_content_typeCountAggregateOutput
        results = await django_content_type.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.django_content_typeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
    ) -> types.django_content_typeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.django_content_typeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
    ) -> Union[int, types.django_content_typeCountAggregateOutput]:
        """Count the number of django_content_type records present in the database

        Parameters
        ----------
        select
            Select the django_content_type fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_content_type filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_content_typeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_content_type.prisma().count()

        # results: prisma.types.django_content_typeCountAggregateOutput
        results = await django_content_type.prisma().count(
            select={
                '_all': True,
                'app_label': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.django_content_typeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.django_content_typeWhereInput] = None
    ) -> int:
        """Delete multiple django_content_type records.

        Parameters
        ----------
        where
            Optional django_content_type filter to find the records to be deleted

        Returns
        -------
        int
            The total number of django_content_type records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all django_content_type records
        total = await django_content_type.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.django_content_typeScalarFieldKeys'],
        *,
        where: Optional['types.django_content_typeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.django_content_typeAvgAggregateInput'] = None,
        sum: Optional['types.django_content_typeSumAggregateInput'] = None,
        min: Optional['types.django_content_typeMinAggregateInput'] = None,
        max: Optional['types.django_content_typeMaxAggregateInput'] = None,
        having: Optional['types.django_content_typeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.django_content_typeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.django_content_typeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.django_content_typeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.django_content_typeGroupByOutput']:
        """Group django_content_type records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar django_content_type fields to group records by
        where
            django_content_type filter to select records
        take
            Limit the maximum number of django_content_type records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.django_content_typeGroupByOutput]
            A list of dictionaries representing the django_content_type record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group django_content_type records by model values
        # and count how many records are in each group
        results = await django_content_type.prisma().group_by(
            ['model'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class django_migrationsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.django_migrations]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await django_migrations.prisma().query_raw(
            'SELECT * FROM django_migrations WHERE id = $1',
            13403179452,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.django_migrations
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await django_migrations.prisma().query_first(
            'SELECT * FROM django_migrations WHERE app = $1',
            'bcedacgecg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.django_migrationsCreateInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> _PrismaModelT:
        """Create a new django_migrations record.

        Parameters
        ----------
        data
            django_migrations record data
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The created django_migrations record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a django_migrations record from just the required fields
        django_migrations = await django_migrations.prisma().create(
            data={
                # data to create a django_migrations record
                'app': 'cbdffjeh',
                'name': 'idbcdhbci',
                'applied': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.django_migrationsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple django_migrations records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of django_migrations record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await django_migrations.prisma().create_many(
            data=[
                {
                    # data to create a django_migrations record
                    'app': 'bacegehahd',
                    'name': 'ebedeihec',
                    'applied': datetime.datetime.utcnow(),
                },
                {
                    # data to create a django_migrations record
                    'app': 'bajagjdfbb',
                    'name': 'bggedbjggi',
                    'applied': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.django_migrationsWhereUniqueInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single django_migrations record.

        Parameters
        ----------
        where
            django_migrations filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The deleted django_migrations record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_migrations = await django_migrations.prisma().delete(
            where={
                'id': 9132702300,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.django_migrationsWhereUniqueInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique django_migrations record.

        Parameters
        ----------
        where
            django_migrations filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The found django_migrations record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_migrations = await django_migrations.prisma().find_unique(
            where={
                'id': 17981105112,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.django_migrationsWhereUniqueInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique django_migrations record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            django_migrations filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The found django_migrations record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_migrations = await django_migrations.prisma().find_unique_or_raise(
            where={
                'id': 23522448804,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
        include: Optional[types.django_migrationsInclude] = None,
        order: Optional[Union[types.django_migrationsOrderByInput, List[types.django_migrationsOrderByInput]]] = None,
        distinct: Optional[List[types.django_migrationsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple django_migrations records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of django_migrations records returned
        skip
            Ignore the first N results
        where
            django_migrations filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_migrations model
        order
            Order the returned django_migrations records by any field
        distinct
            Filter django_migrations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.django_migrations]
            The list of all django_migrations records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 django_migrations records
        django_migrations = await django_migrations.prisma().find_many(take=10)

        # find the first 5 django_migrations records ordered by the name field
        django_migrations = await django_migrations.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
        include: Optional[types.django_migrationsInclude] = None,
        order: Optional[Union[types.django_migrationsOrderByInput, List[types.django_migrationsOrderByInput]]] = None,
        distinct: Optional[List[types.django_migrationsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single django_migrations record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_migrations filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_migrations model
        order
            Order the returned django_migrations records by any field
        distinct
            Filter django_migrations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_migrations
            The first django_migrations record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_migrations record ordered by the applied field
        django_migrations = await django_migrations.prisma().find_first(
            skip=1,
            order={
                'applied': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
        include: Optional[types.django_migrationsInclude] = None,
        order: Optional[Union[types.django_migrationsOrderByInput, List[types.django_migrationsOrderByInput]]] = None,
        distinct: Optional[List[types.django_migrationsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single django_migrations record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_migrations filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_migrations model
        order
            Order the returned django_migrations records by any field
        distinct
            Filter django_migrations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_migrations
            The first django_migrations record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_migrations record ordered by the id field
        django_migrations = await django_migrations.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.django_migrationsUpdateInput,
        where: types.django_migrationsWhereUniqueInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single django_migrations record.

        Parameters
        ----------
        data
            django_migrations record data specifying what to update
        where
            django_migrations filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The updated django_migrations record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        django_migrations = await django_migrations.prisma().update(
            where={
                'id': 17290457472,
            },
            data={
                # data to update the django_migrations record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.django_migrationsWhereUniqueInput,
        data: types.django_migrationsUpsertInput,
        include: Optional[types.django_migrationsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            django_migrations filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The created or updated django_migrations record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_migrations = await django_migrations.prisma().upsert(
            where={
                'id': 18187720236,
            },
            data={
                'create': {
                    'id': 18187720236,
                    'app': 'bajagjdfbb',
                    'name': 'bggedbjggi',
                    'applied': datetime.datetime.utcnow(),
                },
                'update': {
                    'app': 'bajagjdfbb',
                    'name': 'bggedbjggi',
                    'applied': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.django_migrationsUpdateManyMutationInput,
        where: types.django_migrationsWhereInput,
    ) -> int:
        """Update multiple django_migrations records

        Parameters
        ----------
        data
            django_migrations data to update the selected django_migrations records to
        where
            Filter to select the django_migrations records to update

        Returns
        -------
        int
            The total number of django_migrations records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all django_migrations records
        total = await django_migrations.prisma().update_many(
            data={
                'app': 'jbgheibja'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of django_migrations records present in the database

        Parameters
        ----------
        select
            Select the django_migrations fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_migrations filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_migrationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_migrations.prisma().count()

        # results: prisma.types.django_migrationsCountAggregateOutput
        results = await django_migrations.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.django_migrationsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
    ) -> types.django_migrationsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.django_migrationsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
    ) -> Union[int, types.django_migrationsCountAggregateOutput]:
        """Count the number of django_migrations records present in the database

        Parameters
        ----------
        select
            Select the django_migrations fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_migrations filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_migrationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_migrations.prisma().count()

        # results: prisma.types.django_migrationsCountAggregateOutput
        results = await django_migrations.prisma().count(
            select={
                '_all': True,
                'applied': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.django_migrationsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.django_migrationsWhereInput] = None
    ) -> int:
        """Delete multiple django_migrations records.

        Parameters
        ----------
        where
            Optional django_migrations filter to find the records to be deleted

        Returns
        -------
        int
            The total number of django_migrations records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all django_migrations records
        total = await django_migrations.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.django_migrationsScalarFieldKeys'],
        *,
        where: Optional['types.django_migrationsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.django_migrationsAvgAggregateInput'] = None,
        sum: Optional['types.django_migrationsSumAggregateInput'] = None,
        min: Optional['types.django_migrationsMinAggregateInput'] = None,
        max: Optional['types.django_migrationsMaxAggregateInput'] = None,
        having: Optional['types.django_migrationsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.django_migrationsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.django_migrationsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.django_migrationsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.django_migrationsGroupByOutput']:
        """Group django_migrations records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar django_migrations fields to group records by
        where
            django_migrations filter to select records
        take
            Limit the maximum number of django_migrations records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.django_migrationsGroupByOutput]
            A list of dictionaries representing the django_migrations record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group django_migrations records by id values
        # and count how many records are in each group
        results = await django_migrations.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class django_sessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.django_session]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await django_session.prisma().query_raw(
            'SELECT * FROM django_session WHERE session_key = $1',
            'eejajbid',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.django_session
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await django_session.prisma().query_first(
            'SELECT * FROM django_session WHERE session_data = $1',
            'efhdcdaie',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.django_sessionCreateInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new django_session record.

        Parameters
        ----------
        data
            django_session record data
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The created django_session record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a django_session record from just the required fields
        django_session = await django_session.prisma().create(
            data={
                # data to create a django_session record
                'session_key': 'cadejecgbd',
                'session_data': 'bahjhjjhcc',
                'expire_date': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.django_sessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple django_session records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of django_session record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await django_session.prisma().create_many(
            data=[
                {
                    # data to create a django_session record
                    'session_key': 'ebhbhbdff',
                    'session_data': 'bdiefcdfhg',
                    'expire_date': datetime.datetime.utcnow(),
                },
                {
                    # data to create a django_session record
                    'session_key': 'cheifeghd',
                    'session_data': 'fgijheefe',
                    'expire_date': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.django_sessionWhereUniqueInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single django_session record.

        Parameters
        ----------
        where
            django_session filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The deleted django_session record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_session = await django_session.prisma().delete(
            where={
                'session_key': 'hcbgbhfch',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.django_sessionWhereUniqueInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique django_session record.

        Parameters
        ----------
        where
            django_session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The found django_session record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_session = await django_session.prisma().find_unique(
            where={
                'session_key': 'bfbbbgbfhc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.django_sessionWhereUniqueInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique django_session record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            django_session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The found django_session record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_session = await django_session.prisma().find_unique_or_raise(
            where={
                'session_key': 'ibijjdeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
        include: Optional[types.django_sessionInclude] = None,
        order: Optional[Union[types.django_sessionOrderByInput, List[types.django_sessionOrderByInput]]] = None,
        distinct: Optional[List[types.django_sessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple django_session records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of django_session records returned
        skip
            Ignore the first N results
        where
            django_session filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_session model
        order
            Order the returned django_session records by any field
        distinct
            Filter django_session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.django_session]
            The list of all django_session records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 django_session records
        django_sessions = await django_session.prisma().find_many(take=10)

        # find the first 5 django_session records ordered by the expire_date field
        django_sessions = await django_session.prisma().find_many(
            take=5,
            order={
                'expire_date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
        include: Optional[types.django_sessionInclude] = None,
        order: Optional[Union[types.django_sessionOrderByInput, List[types.django_sessionOrderByInput]]] = None,
        distinct: Optional[List[types.django_sessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single django_session record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_session model
        order
            Order the returned django_session records by any field
        distinct
            Filter django_session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_session
            The first django_session record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_session record ordered by the session_key field
        django_session = await django_session.prisma().find_first(
            skip=1,
            order={
                'session_key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
        include: Optional[types.django_sessionInclude] = None,
        order: Optional[Union[types.django_sessionOrderByInput, List[types.django_sessionOrderByInput]]] = None,
        distinct: Optional[List[types.django_sessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single django_session record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_session model
        order
            Order the returned django_session records by any field
        distinct
            Filter django_session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_session
            The first django_session record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_session record ordered by the session_data field
        django_session = await django_session.prisma().find_first_or_raise(
            skip=1,
            order={
                'session_data': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.django_sessionUpdateInput,
        where: types.django_sessionWhereUniqueInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single django_session record.

        Parameters
        ----------
        data
            django_session record data specifying what to update
        where
            django_session filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The updated django_session record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        django_session = await django_session.prisma().update(
            where={
                'session_key': 'caehiccddi',
            },
            data={
                # data to update the django_session record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.django_sessionWhereUniqueInput,
        data: types.django_sessionUpsertInput,
        include: Optional[types.django_sessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            django_session filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The created or updated django_session record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_session = await django_session.prisma().upsert(
            where={
                'session_key': 'bgcahjbafj',
            },
            data={
                'create': {
                    'session_key': 'bgcahjbafj',
                    'session_data': 'fgijheefe',
                    'expire_date': datetime.datetime.utcnow(),
                },
                'update': {
                    'session_data': 'fgijheefe',
                    'expire_date': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.django_sessionUpdateManyMutationInput,
        where: types.django_sessionWhereInput,
    ) -> int:
        """Update multiple django_session records

        Parameters
        ----------
        data
            django_session data to update the selected django_session records to
        where
            Filter to select the django_session records to update

        Returns
        -------
        int
            The total number of django_session records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all django_session records
        total = await django_session.prisma().update_many(
            data={
                'expire_date': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of django_session records present in the database

        Parameters
        ----------
        select
            Select the django_session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_sessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_session.prisma().count()

        # results: prisma.types.django_sessionCountAggregateOutput
        results = await django_session.prisma().count(
            select={
                '_all': True,
                'session_key': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.django_sessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
    ) -> types.django_sessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.django_sessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
    ) -> Union[int, types.django_sessionCountAggregateOutput]:
        """Count the number of django_session records present in the database

        Parameters
        ----------
        select
            Select the django_session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_sessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_session.prisma().count()

        # results: prisma.types.django_sessionCountAggregateOutput
        results = await django_session.prisma().count(
            select={
                '_all': True,
                'session_data': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.django_sessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.django_sessionWhereInput] = None
    ) -> int:
        """Delete multiple django_session records.

        Parameters
        ----------
        where
            Optional django_session filter to find the records to be deleted

        Returns
        -------
        int
            The total number of django_session records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all django_session records
        total = await django_session.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.django_sessionScalarFieldKeys'],
        *,
        where: Optional['types.django_sessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.django_sessionAvgAggregateInput'] = None,
        sum: Optional['types.django_sessionSumAggregateInput'] = None,
        min: Optional['types.django_sessionMinAggregateInput'] = None,
        max: Optional['types.django_sessionMaxAggregateInput'] = None,
        having: Optional['types.django_sessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.django_sessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.django_sessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.django_sessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.django_sessionGroupByOutput']:
        """Group django_session records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar django_session fields to group records by
        where
            django_session filter to select records
        take
            Limit the maximum number of django_session records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.django_sessionGroupByOutput]
            A list of dictionaries representing the django_session record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group django_session records by expire_date values
        # and count how many records are in each group
        results = await django_session.prisma().group_by(
            ['expire_date'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class token_blacklist_blacklistedtokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.token_blacklist_blacklistedtoken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await token_blacklist_blacklistedtoken.prisma().query_raw(
            'SELECT * FROM token_blacklist_blacklistedtoken WHERE id = $1',
            22531784640,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await token_blacklist_blacklistedtoken.prisma().query_first(
            'SELECT * FROM token_blacklist_blacklistedtoken WHERE blacklisted_at = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.token_blacklist_blacklistedtokenCreateInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new token_blacklist_blacklistedtoken record.

        Parameters
        ----------
        data
            token_blacklist_blacklistedtoken record data
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The created token_blacklist_blacklistedtoken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a token_blacklist_blacklistedtoken record from just the required fields
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().create(
            data={
                # data to create a token_blacklist_blacklistedtoken record
                'blacklisted_at': datetime.datetime.utcnow(),
                'token_id': 16338085740,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.token_blacklist_blacklistedtokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple token_blacklist_blacklistedtoken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of token_blacklist_blacklistedtoken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await token_blacklist_blacklistedtoken.prisma().create_many(
            data=[
                {
                    # data to create a token_blacklist_blacklistedtoken record
                    'blacklisted_at': datetime.datetime.utcnow(),
                    'token_id': 6275740584,
                },
                {
                    # data to create a token_blacklist_blacklistedtoken record
                    'blacklisted_at': datetime.datetime.utcnow(),
                    'token_id': 16384356660,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single token_blacklist_blacklistedtoken record.

        Parameters
        ----------
        where
            token_blacklist_blacklistedtoken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The deleted token_blacklist_blacklistedtoken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().delete(
            where={
                'id': 21916896720,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique token_blacklist_blacklistedtoken record.

        Parameters
        ----------
        where
            token_blacklist_blacklistedtoken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The found token_blacklist_blacklistedtoken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().find_unique(
            where={
                'id': 6117246012,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique token_blacklist_blacklistedtoken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            token_blacklist_blacklistedtoken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The found token_blacklist_blacklistedtoken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().find_unique_or_raise(
            where={
                'id': 18578741304,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_blacklistedtokenOrderByInput, List[types.token_blacklist_blacklistedtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_blacklistedtokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple token_blacklist_blacklistedtoken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of token_blacklist_blacklistedtoken records returned
        skip
            Ignore the first N results
        where
            token_blacklist_blacklistedtoken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model
        order
            Order the returned token_blacklist_blacklistedtoken records by any field
        distinct
            Filter token_blacklist_blacklistedtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.token_blacklist_blacklistedtoken]
            The list of all token_blacklist_blacklistedtoken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 token_blacklist_blacklistedtoken records
        token_blacklist_blacklistedtokens = await token_blacklist_blacklistedtoken.prisma().find_many(take=10)

        # find the first 5 token_blacklist_blacklistedtoken records ordered by the token_id field
        token_blacklist_blacklistedtokens = await token_blacklist_blacklistedtoken.prisma().find_many(
            take=5,
            order={
                'token_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_blacklistedtokenOrderByInput, List[types.token_blacklist_blacklistedtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_blacklistedtokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single token_blacklist_blacklistedtoken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            token_blacklist_blacklistedtoken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model
        order
            Order the returned token_blacklist_blacklistedtoken records by any field
        distinct
            Filter token_blacklist_blacklistedtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The first token_blacklist_blacklistedtoken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second token_blacklist_blacklistedtoken record ordered by the id field
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_blacklistedtokenOrderByInput, List[types.token_blacklist_blacklistedtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_blacklistedtokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single token_blacklist_blacklistedtoken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            token_blacklist_blacklistedtoken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model
        order
            Order the returned token_blacklist_blacklistedtoken records by any field
        distinct
            Filter token_blacklist_blacklistedtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The first token_blacklist_blacklistedtoken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second token_blacklist_blacklistedtoken record ordered by the blacklisted_at field
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().find_first_or_raise(
            skip=1,
            order={
                'blacklisted_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.token_blacklist_blacklistedtokenUpdateInput,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single token_blacklist_blacklistedtoken record.

        Parameters
        ----------
        data
            token_blacklist_blacklistedtoken record data specifying what to update
        where
            token_blacklist_blacklistedtoken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The updated token_blacklist_blacklistedtoken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().update(
            where={
                'id': 8741626500,
            },
            data={
                # data to update the token_blacklist_blacklistedtoken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        data: types.token_blacklist_blacklistedtokenUpsertInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            token_blacklist_blacklistedtoken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The created or updated token_blacklist_blacklistedtoken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().upsert(
            where={
                'id': 1294314720,
            },
            data={
                'create': {
                    'id': 1294314720,
                    'blacklisted_at': datetime.datetime.utcnow(),
                    'token_id': 16384356660,
                },
                'update': {
                    'blacklisted_at': datetime.datetime.utcnow(),
                    'token_id': 16384356660,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.token_blacklist_blacklistedtokenUpdateManyMutationInput,
        where: types.token_blacklist_blacklistedtokenWhereInput,
    ) -> int:
        """Update multiple token_blacklist_blacklistedtoken records

        Parameters
        ----------
        data
            token_blacklist_blacklistedtoken data to update the selected token_blacklist_blacklistedtoken records to
        where
            Filter to select the token_blacklist_blacklistedtoken records to update

        Returns
        -------
        int
            The total number of token_blacklist_blacklistedtoken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all token_blacklist_blacklistedtoken records
        total = await token_blacklist_blacklistedtoken.prisma().update_many(
            data={
                'token_id': 12498574860
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of token_blacklist_blacklistedtoken records present in the database

        Parameters
        ----------
        select
            Select the token_blacklist_blacklistedtoken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            token_blacklist_blacklistedtoken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.token_blacklist_blacklistedtokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await token_blacklist_blacklistedtoken.prisma().count()

        # results: prisma.types.token_blacklist_blacklistedtokenCountAggregateOutput
        results = await token_blacklist_blacklistedtoken.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.token_blacklist_blacklistedtokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
    ) -> types.token_blacklist_blacklistedtokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.token_blacklist_blacklistedtokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
    ) -> Union[int, types.token_blacklist_blacklistedtokenCountAggregateOutput]:
        """Count the number of token_blacklist_blacklistedtoken records present in the database

        Parameters
        ----------
        select
            Select the token_blacklist_blacklistedtoken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            token_blacklist_blacklistedtoken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.token_blacklist_blacklistedtokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await token_blacklist_blacklistedtoken.prisma().count()

        # results: prisma.types.token_blacklist_blacklistedtokenCountAggregateOutput
        results = await token_blacklist_blacklistedtoken.prisma().count(
            select={
                '_all': True,
                'blacklisted_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.token_blacklist_blacklistedtokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None
    ) -> int:
        """Delete multiple token_blacklist_blacklistedtoken records.

        Parameters
        ----------
        where
            Optional token_blacklist_blacklistedtoken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of token_blacklist_blacklistedtoken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all token_blacklist_blacklistedtoken records
        total = await token_blacklist_blacklistedtoken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.token_blacklist_blacklistedtokenScalarFieldKeys'],
        *,
        where: Optional['types.token_blacklist_blacklistedtokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.token_blacklist_blacklistedtokenAvgAggregateInput'] = None,
        sum: Optional['types.token_blacklist_blacklistedtokenSumAggregateInput'] = None,
        min: Optional['types.token_blacklist_blacklistedtokenMinAggregateInput'] = None,
        max: Optional['types.token_blacklist_blacklistedtokenMaxAggregateInput'] = None,
        having: Optional['types.token_blacklist_blacklistedtokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.token_blacklist_blacklistedtokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.token_blacklist_blacklistedtokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.token_blacklist_blacklistedtokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.token_blacklist_blacklistedtokenGroupByOutput']:
        """Group token_blacklist_blacklistedtoken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar token_blacklist_blacklistedtoken fields to group records by
        where
            token_blacklist_blacklistedtoken filter to select records
        take
            Limit the maximum number of token_blacklist_blacklistedtoken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.token_blacklist_blacklistedtokenGroupByOutput]
            A list of dictionaries representing the token_blacklist_blacklistedtoken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group token_blacklist_blacklistedtoken records by token_id values
        # and count how many records are in each group
        results = await token_blacklist_blacklistedtoken.prisma().group_by(
            ['token_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class token_blacklist_outstandingtokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.token_blacklist_outstandingtoken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await token_blacklist_outstandingtoken.prisma().query_raw(
            'SELECT * FROM token_blacklist_outstandingtoken WHERE id = $1',
            23127635400,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await token_blacklist_outstandingtoken.prisma().query_first(
            'SELECT * FROM token_blacklist_outstandingtoken WHERE token = $1',
            'fcadcaihb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.token_blacklist_outstandingtokenCreateInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new token_blacklist_outstandingtoken record.

        Parameters
        ----------
        data
            token_blacklist_outstandingtoken record data
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The created token_blacklist_outstandingtoken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a token_blacklist_outstandingtoken record from just the required fields
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().create(
            data={
                # data to create a token_blacklist_outstandingtoken record
                'token': 'bbdcibggga',
                'expires_at': datetime.datetime.utcnow(),
                'jti': 'bagbibfheb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.token_blacklist_outstandingtokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple token_blacklist_outstandingtoken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of token_blacklist_outstandingtoken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await token_blacklist_outstandingtoken.prisma().create_many(
            data=[
                {
                    # data to create a token_blacklist_outstandingtoken record
                    'token': 'bidgcabjag',
                    'expires_at': datetime.datetime.utcnow(),
                    'jti': 'hechjdjih',
                },
                {
                    # data to create a token_blacklist_outstandingtoken record
                    'token': 'cgfjefhci',
                    'expires_at': datetime.datetime.utcnow(),
                    'jti': 'egcidbiab',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single token_blacklist_outstandingtoken record.

        Parameters
        ----------
        where
            token_blacklist_outstandingtoken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The deleted token_blacklist_outstandingtoken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().delete(
            where={
                'id': 2975947752,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique token_blacklist_outstandingtoken record.

        Parameters
        ----------
        where
            token_blacklist_outstandingtoken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The found token_blacklist_outstandingtoken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().find_unique(
            where={
                'id': 9360053364,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique token_blacklist_outstandingtoken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            token_blacklist_outstandingtoken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The found token_blacklist_outstandingtoken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().find_unique_or_raise(
            where={
                'id': 5257121808,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_outstandingtokenOrderByInput, List[types.token_blacklist_outstandingtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_outstandingtokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple token_blacklist_outstandingtoken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of token_blacklist_outstandingtoken records returned
        skip
            Ignore the first N results
        where
            token_blacklist_outstandingtoken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model
        order
            Order the returned token_blacklist_outstandingtoken records by any field
        distinct
            Filter token_blacklist_outstandingtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.token_blacklist_outstandingtoken]
            The list of all token_blacklist_outstandingtoken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 token_blacklist_outstandingtoken records
        token_blacklist_outstandingtokens = await token_blacklist_outstandingtoken.prisma().find_many(take=10)

        # find the first 5 token_blacklist_outstandingtoken records ordered by the created_at field
        token_blacklist_outstandingtokens = await token_blacklist_outstandingtoken.prisma().find_many(
            take=5,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_outstandingtokenOrderByInput, List[types.token_blacklist_outstandingtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_outstandingtokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single token_blacklist_outstandingtoken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            token_blacklist_outstandingtoken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model
        order
            Order the returned token_blacklist_outstandingtoken records by any field
        distinct
            Filter token_blacklist_outstandingtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The first token_blacklist_outstandingtoken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second token_blacklist_outstandingtoken record ordered by the expires_at field
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().find_first(
            skip=1,
            order={
                'expires_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_outstandingtokenOrderByInput, List[types.token_blacklist_outstandingtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_outstandingtokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single token_blacklist_outstandingtoken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            token_blacklist_outstandingtoken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model
        order
            Order the returned token_blacklist_outstandingtoken records by any field
        distinct
            Filter token_blacklist_outstandingtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The first token_blacklist_outstandingtoken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second token_blacklist_outstandingtoken record ordered by the user_id field
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.token_blacklist_outstandingtokenUpdateInput,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single token_blacklist_outstandingtoken record.

        Parameters
        ----------
        data
            token_blacklist_outstandingtoken record data specifying what to update
        where
            token_blacklist_outstandingtoken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The updated token_blacklist_outstandingtoken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().update(
            where={
                'id': 11237472636,
            },
            data={
                # data to update the token_blacklist_outstandingtoken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        data: types.token_blacklist_outstandingtokenUpsertInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            token_blacklist_outstandingtoken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The created or updated token_blacklist_outstandingtoken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().upsert(
            where={
                'id': 21344584824,
            },
            data={
                'create': {
                    'id': 21344584824,
                    'token': 'cgfjefhci',
                    'expires_at': datetime.datetime.utcnow(),
                    'jti': 'egcidbiab',
                },
                'update': {
                    'token': 'cgfjefhci',
                    'expires_at': datetime.datetime.utcnow(),
                    'jti': 'egcidbiab',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.token_blacklist_outstandingtokenUpdateManyMutationInput,
        where: types.token_blacklist_outstandingtokenWhereInput,
    ) -> int:
        """Update multiple token_blacklist_outstandingtoken records

        Parameters
        ----------
        data
            token_blacklist_outstandingtoken data to update the selected token_blacklist_outstandingtoken records to
        where
            Filter to select the token_blacklist_outstandingtoken records to update

        Returns
        -------
        int
            The total number of token_blacklist_outstandingtoken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all token_blacklist_outstandingtoken records
        total = await token_blacklist_outstandingtoken.prisma().update_many(
            data={
                'jti': 'bajegedfhj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of token_blacklist_outstandingtoken records present in the database

        Parameters
        ----------
        select
            Select the token_blacklist_outstandingtoken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            token_blacklist_outstandingtoken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.token_blacklist_outstandingtokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await token_blacklist_outstandingtoken.prisma().count()

        # results: prisma.types.token_blacklist_outstandingtokenCountAggregateOutput
        results = await token_blacklist_outstandingtoken.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.token_blacklist_outstandingtokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
    ) -> types.token_blacklist_outstandingtokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.token_blacklist_outstandingtokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
    ) -> Union[int, types.token_blacklist_outstandingtokenCountAggregateOutput]:
        """Count the number of token_blacklist_outstandingtoken records present in the database

        Parameters
        ----------
        select
            Select the token_blacklist_outstandingtoken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            token_blacklist_outstandingtoken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.token_blacklist_outstandingtokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await token_blacklist_outstandingtoken.prisma().count()

        # results: prisma.types.token_blacklist_outstandingtokenCountAggregateOutput
        results = await token_blacklist_outstandingtoken.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.token_blacklist_outstandingtokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None
    ) -> int:
        """Delete multiple token_blacklist_outstandingtoken records.

        Parameters
        ----------
        where
            Optional token_blacklist_outstandingtoken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of token_blacklist_outstandingtoken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all token_blacklist_outstandingtoken records
        total = await token_blacklist_outstandingtoken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.token_blacklist_outstandingtokenScalarFieldKeys'],
        *,
        where: Optional['types.token_blacklist_outstandingtokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.token_blacklist_outstandingtokenAvgAggregateInput'] = None,
        sum: Optional['types.token_blacklist_outstandingtokenSumAggregateInput'] = None,
        min: Optional['types.token_blacklist_outstandingtokenMinAggregateInput'] = None,
        max: Optional['types.token_blacklist_outstandingtokenMaxAggregateInput'] = None,
        having: Optional['types.token_blacklist_outstandingtokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.token_blacklist_outstandingtokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.token_blacklist_outstandingtokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.token_blacklist_outstandingtokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.token_blacklist_outstandingtokenGroupByOutput']:
        """Group token_blacklist_outstandingtoken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar token_blacklist_outstandingtoken fields to group records by
        where
            token_blacklist_outstandingtoken filter to select records
        take
            Limit the maximum number of token_blacklist_outstandingtoken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.token_blacklist_outstandingtokenGroupByOutput]
            A list of dictionaries representing the token_blacklist_outstandingtoken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group token_blacklist_outstandingtoken records by created_at values
        # and count how many records are in each group
        results = await token_blacklist_outstandingtoken.prisma().group_by(
            ['created_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class users_userActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.users_user]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users_user.prisma().query_raw(
            'SELECT * FROM users_user WHERE id = $1',
            21118554912,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.users_user
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await users_user.prisma().query_first(
            'SELECT * FROM users_user WHERE password = $1',
            'iicaadeeb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.users_userCreateInput,
        include: Optional[types.users_userInclude] = None
    ) -> _PrismaModelT:
        """Create a new users_user record.

        Parameters
        ----------
        data
            users_user record data
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The created users_user record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a users_user record from just the required fields
        users_user = await users_user.prisma().create(
            data={
                # data to create a users_user record
                'password': 'bigjggdhac',
                'is_superuser': False,
                'username': 'bdibjhdici',
                'first_name': 'bceigehcbd',
                'last_name': 'caehahihfe',
                'is_staff': False,
                'is_active': True,
                'date_joined': datetime.datetime.utcnow(),
                'email': 'hhaechedd',
                'is_premium': True,
                'hide_ads': False,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.users_userCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple users_user records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of users_user record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await users_user.prisma().create_many(
            data=[
                {
                    # data to create a users_user record
                    'password': 'cbaagdieci',
                    'is_superuser': False,
                    'username': 'dhhdhfebi',
                    'first_name': 'decchddih',
                    'last_name': 'bbegbdehci',
                    'is_staff': False,
                    'is_active': True,
                    'date_joined': datetime.datetime.utcnow(),
                    'email': 'hdeaejgah',
                    'is_premium': True,
                    'hide_ads': False,
                },
                {
                    # data to create a users_user record
                    'password': 'fcbbahcbi',
                    'is_superuser': False,
                    'username': 'bfehccdcge',
                    'first_name': 'ehcibdegf',
                    'last_name': 'ebhjifbbi',
                    'is_staff': False,
                    'is_active': True,
                    'date_joined': datetime.datetime.utcnow(),
                    'email': 'bhidfjibgf',
                    'is_premium': True,
                    'hide_ads': False,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.users_userWhereUniqueInput,
        include: Optional[types.users_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single users_user record.

        Parameters
        ----------
        where
            users_user filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The deleted users_user record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user = await users_user.prisma().delete(
            where={
                'id': 13251219360,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.users_userWhereUniqueInput,
        include: Optional[types.users_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique users_user record.

        Parameters
        ----------
        where
            users_user filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The found users_user record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user = await users_user.prisma().find_unique(
            where={
                'id': 8916249036,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.users_userWhereUniqueInput,
        include: Optional[types.users_userInclude] = None
    ) -> _PrismaModelT:
        """Find a unique users_user record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            users_user filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The found users_user record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user = await users_user.prisma().find_unique_or_raise(
            where={
                'id': 2123314824,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
        include: Optional[types.users_userInclude] = None,
        order: Optional[Union[types.users_userOrderByInput, List[types.users_userOrderByInput]]] = None,
        distinct: Optional[List[types.users_userScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple users_user records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of users_user records returned
        skip
            Ignore the first N results
        where
            users_user filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user model
        order
            Order the returned users_user records by any field
        distinct
            Filter users_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.users_user]
            The list of all users_user records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 users_user records
        users_users = await users_user.prisma().find_many(take=10)

        # find the first 5 users_user records ordered by the last_login field
        users_users = await users_user.prisma().find_many(
            take=5,
            order={
                'last_login': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
        include: Optional[types.users_userInclude] = None,
        order: Optional[Union[types.users_userOrderByInput, List[types.users_userOrderByInput]]] = None,
        distinct: Optional[List[types.users_userScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single users_user record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user model
        order
            Order the returned users_user records by any field
        distinct
            Filter users_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user
            The first users_user record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user record ordered by the is_superuser field
        users_user = await users_user.prisma().find_first(
            skip=1,
            order={
                'is_superuser': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
        include: Optional[types.users_userInclude] = None,
        order: Optional[Union[types.users_userOrderByInput, List[types.users_userOrderByInput]]] = None,
        distinct: Optional[List[types.users_userScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single users_user record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user model
        order
            Order the returned users_user records by any field
        distinct
            Filter users_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user
            The first users_user record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user record ordered by the username field
        users_user = await users_user.prisma().find_first_or_raise(
            skip=1,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.users_userUpdateInput,
        where: types.users_userWhereUniqueInput,
        include: Optional[types.users_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single users_user record.

        Parameters
        ----------
        data
            users_user record data specifying what to update
        where
            users_user filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The updated users_user record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users_user = await users_user.prisma().update(
            where={
                'id': 18166180500,
            },
            data={
                # data to update the users_user record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.users_userWhereUniqueInput,
        data: types.users_userUpsertInput,
        include: Optional[types.users_userInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            users_user filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The created or updated users_user record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user = await users_user.prisma().upsert(
            where={
                'id': 6709590960,
            },
            data={
                'create': {
                    'id': 6709590960,
                    'password': 'fcbbahcbi',
                    'is_superuser': False,
                    'username': 'bfehccdcge',
                    'first_name': 'ehcibdegf',
                    'last_name': 'ebhjifbbi',
                    'is_staff': False,
                    'is_active': True,
                    'date_joined': datetime.datetime.utcnow(),
                    'email': 'bhidfjibgf',
                    'is_premium': True,
                    'hide_ads': False,
                },
                'update': {
                    'password': 'fcbbahcbi',
                    'is_superuser': False,
                    'username': 'bfehccdcge',
                    'first_name': 'ehcibdegf',
                    'last_name': 'ebhjifbbi',
                    'is_staff': False,
                    'is_active': True,
                    'date_joined': datetime.datetime.utcnow(),
                    'email': 'bhidfjibgf',
                    'is_premium': True,
                    'hide_ads': False,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.users_userUpdateManyMutationInput,
        where: types.users_userWhereInput,
    ) -> int:
        """Update multiple users_user records

        Parameters
        ----------
        data
            users_user data to update the selected users_user records to
        where
            Filter to select the users_user records to update

        Returns
        -------
        int
            The total number of users_user records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all users_user records
        total = await users_user.prisma().update_many(
            data={
                'first_name': 'hfeidjicb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
    ) -> int:
        """Count the number of users_user records present in the database

        Parameters
        ----------
        select
            Select the users_user fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_userCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user.prisma().count()

        # results: prisma.types.users_userCountAggregateOutput
        results = await users_user.prisma().count(
            select={
                '_all': True,
                'last_name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.users_userCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
    ) -> types.users_userCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.users_userCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
    ) -> Union[int, types.users_userCountAggregateOutput]:
        """Count the number of users_user records present in the database

        Parameters
        ----------
        select
            Select the users_user fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_userCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user.prisma().count()

        # results: prisma.types.users_userCountAggregateOutput
        results = await users_user.prisma().count(
            select={
                '_all': True,
                'is_staff': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.users_userCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.users_userWhereInput] = None
    ) -> int:
        """Delete multiple users_user records.

        Parameters
        ----------
        where
            Optional users_user filter to find the records to be deleted

        Returns
        -------
        int
            The total number of users_user records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all users_user records
        total = await users_user.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.users_userScalarFieldKeys'],
        *,
        where: Optional['types.users_userWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.users_userAvgAggregateInput'] = None,
        sum: Optional['types.users_userSumAggregateInput'] = None,
        min: Optional['types.users_userMinAggregateInput'] = None,
        max: Optional['types.users_userMaxAggregateInput'] = None,
        having: Optional['types.users_userScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.users_userCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.users_userScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.users_userScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.users_userGroupByOutput']:
        """Group users_user records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar users_user fields to group records by
        where
            users_user filter to select records
        take
            Limit the maximum number of users_user records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.users_userGroupByOutput]
            A list of dictionaries representing the users_user record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group users_user records by is_active values
        # and count how many records are in each group
        results = await users_user.prisma().group_by(
            ['is_active'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class users_user_groupsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.users_user_groups]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users_user_groups.prisma().query_raw(
            'SELECT * FROM users_user_groups WHERE id = $1',
            13815867672,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.users_user_groups
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await users_user_groups.prisma().query_first(
            'SELECT * FROM users_user_groups WHERE user_id = $1',
            22397407716,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.users_user_groupsCreateInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> _PrismaModelT:
        """Create a new users_user_groups record.

        Parameters
        ----------
        data
            users_user_groups record data
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The created users_user_groups record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a users_user_groups record from just the required fields
        users_user_groups = await users_user_groups.prisma().create(
            data={
                # data to create a users_user_groups record
                'user_id': 7837685952,
                'group_id': 170234121,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.users_user_groupsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple users_user_groups records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of users_user_groups record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await users_user_groups.prisma().create_many(
            data=[
                {
                    # data to create a users_user_groups record
                    'user_id': 11706578088,
                    'group_id': 808844591,
                },
                {
                    # data to create a users_user_groups record
                    'user_id': 11975243472,
                    'group_id': 1779250373,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.users_user_groupsWhereUniqueInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single users_user_groups record.

        Parameters
        ----------
        where
            users_user_groups filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The deleted users_user_groups record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_groups = await users_user_groups.prisma().delete(
            where={
                'id': 617883960,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.users_user_groupsWhereUniqueInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique users_user_groups record.

        Parameters
        ----------
        where
            users_user_groups filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The found users_user_groups record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_groups = await users_user_groups.prisma().find_unique(
            where={
                'id': 23290371972,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.users_user_groupsWhereUniqueInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique users_user_groups record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            users_user_groups filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The found users_user_groups record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_groups = await users_user_groups.prisma().find_unique_or_raise(
            where={
                'id': 5093041632,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
        include: Optional[types.users_user_groupsInclude] = None,
        order: Optional[Union[types.users_user_groupsOrderByInput, List[types.users_user_groupsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_groupsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple users_user_groups records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of users_user_groups records returned
        skip
            Ignore the first N results
        where
            users_user_groups filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_groups model
        order
            Order the returned users_user_groups records by any field
        distinct
            Filter users_user_groups records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.users_user_groups]
            The list of all users_user_groups records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 users_user_groups records
        users_user_groups = await users_user_groups.prisma().find_many(take=10)

        # find the first 5 users_user_groups records ordered by the group_id field
        users_user_groups = await users_user_groups.prisma().find_many(
            take=5,
            order={
                'group_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
        include: Optional[types.users_user_groupsInclude] = None,
        order: Optional[Union[types.users_user_groupsOrderByInput, List[types.users_user_groupsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_groupsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single users_user_groups record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user_groups filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_groups model
        order
            Order the returned users_user_groups records by any field
        distinct
            Filter users_user_groups records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user_groups
            The first users_user_groups record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user_groups record ordered by the id field
        users_user_groups = await users_user_groups.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
        include: Optional[types.users_user_groupsInclude] = None,
        order: Optional[Union[types.users_user_groupsOrderByInput, List[types.users_user_groupsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_groupsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single users_user_groups record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user_groups filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_groups model
        order
            Order the returned users_user_groups records by any field
        distinct
            Filter users_user_groups records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user_groups
            The first users_user_groups record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user_groups record ordered by the user_id field
        users_user_groups = await users_user_groups.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.users_user_groupsUpdateInput,
        where: types.users_user_groupsWhereUniqueInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single users_user_groups record.

        Parameters
        ----------
        data
            users_user_groups record data specifying what to update
        where
            users_user_groups filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The updated users_user_groups record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users_user_groups = await users_user_groups.prisma().update(
            where={
                'id': 16321094412,
            },
            data={
                # data to update the users_user_groups record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.users_user_groupsWhereUniqueInput,
        data: types.users_user_groupsUpsertInput,
        include: Optional[types.users_user_groupsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            users_user_groups filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The created or updated users_user_groups record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_groups = await users_user_groups.prisma().upsert(
            where={
                'id': 3331774152,
            },
            data={
                'create': {
                    'id': 3331774152,
                    'user_id': 11975243472,
                    'group_id': 1779250373,
                },
                'update': {
                    'user_id': 11975243472,
                    'group_id': 1779250373,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.users_user_groupsUpdateManyMutationInput,
        where: types.users_user_groupsWhereInput,
    ) -> int:
        """Update multiple users_user_groups records

        Parameters
        ----------
        data
            users_user_groups data to update the selected users_user_groups records to
        where
            Filter to select the users_user_groups records to update

        Returns
        -------
        int
            The total number of users_user_groups records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all users_user_groups records
        total = await users_user_groups.prisma().update_many(
            data={
                'group_id': 506618663
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of users_user_groups records present in the database

        Parameters
        ----------
        select
            Select the users_user_groups fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user_groups filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_user_groupsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user_groups.prisma().count()

        # results: prisma.types.users_user_groupsCountAggregateOutput
        results = await users_user_groups.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.users_user_groupsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
    ) -> types.users_user_groupsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.users_user_groupsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
    ) -> Union[int, types.users_user_groupsCountAggregateOutput]:
        """Count the number of users_user_groups records present in the database

        Parameters
        ----------
        select
            Select the users_user_groups fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user_groups filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_user_groupsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user_groups.prisma().count()

        # results: prisma.types.users_user_groupsCountAggregateOutput
        results = await users_user_groups.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.users_user_groupsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.users_user_groupsWhereInput] = None
    ) -> int:
        """Delete multiple users_user_groups records.

        Parameters
        ----------
        where
            Optional users_user_groups filter to find the records to be deleted

        Returns
        -------
        int
            The total number of users_user_groups records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all users_user_groups records
        total = await users_user_groups.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.users_user_groupsScalarFieldKeys'],
        *,
        where: Optional['types.users_user_groupsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.users_user_groupsAvgAggregateInput'] = None,
        sum: Optional['types.users_user_groupsSumAggregateInput'] = None,
        min: Optional['types.users_user_groupsMinAggregateInput'] = None,
        max: Optional['types.users_user_groupsMaxAggregateInput'] = None,
        having: Optional['types.users_user_groupsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.users_user_groupsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.users_user_groupsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.users_user_groupsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.users_user_groupsGroupByOutput']:
        """Group users_user_groups records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar users_user_groups fields to group records by
        where
            users_user_groups filter to select records
        take
            Limit the maximum number of users_user_groups records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.users_user_groupsGroupByOutput]
            A list of dictionaries representing the users_user_groups record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group users_user_groups records by group_id values
        # and count how many records are in each group
        results = await users_user_groups.prisma().group_by(
            ['group_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class users_user_user_permissionsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.users_user_user_permissions]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users_user_user_permissions.prisma().query_raw(
            'SELECT * FROM users_user_user_permissions WHERE id = $1',
            15467771376,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.users_user_user_permissions
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await users_user_user_permissions.prisma().query_first(
            'SELECT * FROM users_user_user_permissions WHERE user_id = $1',
            16680393180,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.users_user_user_permissionsCreateInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> _PrismaModelT:
        """Create a new users_user_user_permissions record.

        Parameters
        ----------
        data
            users_user_user_permissions record data
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The created users_user_user_permissions record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a users_user_user_permissions record from just the required fields
        users_user_user_permissions = await users_user_user_permissions.prisma().create(
            data={
                # data to create a users_user_user_permissions record
                'user_id': 21642530136,
                'permission_id': 1809320643,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.users_user_user_permissionsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple users_user_user_permissions records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of users_user_user_permissions record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await users_user_user_permissions.prisma().create_many(
            data=[
                {
                    # data to create a users_user_user_permissions record
                    'user_id': 4043978496,
                    'permission_id': 458739321,
                },
                {
                    # data to create a users_user_user_permissions record
                    'user_id': 16082509032,
                    'permission_id': 933662751,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.users_user_user_permissionsWhereUniqueInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single users_user_user_permissions record.

        Parameters
        ----------
        where
            users_user_user_permissions filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The deleted users_user_user_permissions record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_user_permissions = await users_user_user_permissions.prisma().delete(
            where={
                'id': 14658304272,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.users_user_user_permissionsWhereUniqueInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique users_user_user_permissions record.

        Parameters
        ----------
        where
            users_user_user_permissions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The found users_user_user_permissions record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_user_permissions = await users_user_user_permissions.prisma().find_unique(
            where={
                'id': 2313563772,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.users_user_user_permissionsWhereUniqueInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique users_user_user_permissions record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            users_user_user_permissions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The found users_user_user_permissions record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_user_permissions = await users_user_user_permissions.prisma().find_unique_or_raise(
            where={
                'id': 9816102264,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
        include: Optional[types.users_user_user_permissionsInclude] = None,
        order: Optional[Union[types.users_user_user_permissionsOrderByInput, List[types.users_user_user_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_user_permissionsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple users_user_user_permissions records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of users_user_user_permissions records returned
        skip
            Ignore the first N results
        where
            users_user_user_permissions filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model
        order
            Order the returned users_user_user_permissions records by any field
        distinct
            Filter users_user_user_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.users_user_user_permissions]
            The list of all users_user_user_permissions records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 users_user_user_permissions records
        users_user_user_permissions = await users_user_user_permissions.prisma().find_many(take=10)

        # find the first 5 users_user_user_permissions records ordered by the permission_id field
        users_user_user_permissions = await users_user_user_permissions.prisma().find_many(
            take=5,
            order={
                'permission_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
        include: Optional[types.users_user_user_permissionsInclude] = None,
        order: Optional[Union[types.users_user_user_permissionsOrderByInput, List[types.users_user_user_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_user_permissionsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single users_user_user_permissions record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user_user_permissions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model
        order
            Order the returned users_user_user_permissions records by any field
        distinct
            Filter users_user_user_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user_user_permissions
            The first users_user_user_permissions record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user_user_permissions record ordered by the id field
        users_user_user_permissions = await users_user_user_permissions.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
        include: Optional[types.users_user_user_permissionsInclude] = None,
        order: Optional[Union[types.users_user_user_permissionsOrderByInput, List[types.users_user_user_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_user_permissionsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single users_user_user_permissions record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user_user_permissions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model
        order
            Order the returned users_user_user_permissions records by any field
        distinct
            Filter users_user_user_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user_user_permissions
            The first users_user_user_permissions record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user_user_permissions record ordered by the user_id field
        users_user_user_permissions = await users_user_user_permissions.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.users_user_user_permissionsUpdateInput,
        where: types.users_user_user_permissionsWhereUniqueInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single users_user_user_permissions record.

        Parameters
        ----------
        data
            users_user_user_permissions record data specifying what to update
        where
            users_user_user_permissions filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The updated users_user_user_permissions record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users_user_user_permissions = await users_user_user_permissions.prisma().update(
            where={
                'id': 18658932420,
            },
            data={
                # data to update the users_user_user_permissions record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.users_user_user_permissionsWhereUniqueInput,
        data: types.users_user_user_permissionsUpsertInput,
        include: Optional[types.users_user_user_permissionsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            users_user_user_permissions filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The created or updated users_user_user_permissions record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_user_permissions = await users_user_user_permissions.prisma().upsert(
            where={
                'id': 13163809824,
            },
            data={
                'create': {
                    'id': 13163809824,
                    'user_id': 16082509032,
                    'permission_id': 933662751,
                },
                'update': {
                    'user_id': 16082509032,
                    'permission_id': 933662751,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.users_user_user_permissionsUpdateManyMutationInput,
        where: types.users_user_user_permissionsWhereInput,
    ) -> int:
        """Update multiple users_user_user_permissions records

        Parameters
        ----------
        data
            users_user_user_permissions data to update the selected users_user_user_permissions records to
        where
            Filter to select the users_user_user_permissions records to update

        Returns
        -------
        int
            The total number of users_user_user_permissions records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all users_user_user_permissions records
        total = await users_user_user_permissions.prisma().update_many(
            data={
                'permission_id': 1707070385
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of users_user_user_permissions records present in the database

        Parameters
        ----------
        select
            Select the users_user_user_permissions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user_user_permissions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_user_user_permissionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user_user_permissions.prisma().count()

        # results: prisma.types.users_user_user_permissionsCountAggregateOutput
        results = await users_user_user_permissions.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.users_user_user_permissionsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
    ) -> types.users_user_user_permissionsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.users_user_user_permissionsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
    ) -> Union[int, types.users_user_user_permissionsCountAggregateOutput]:
        """Count the number of users_user_user_permissions records present in the database

        Parameters
        ----------
        select
            Select the users_user_user_permissions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user_user_permissions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_user_user_permissionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user_user_permissions.prisma().count()

        # results: prisma.types.users_user_user_permissionsCountAggregateOutput
        results = await users_user_user_permissions.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.users_user_user_permissionsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.users_user_user_permissionsWhereInput] = None
    ) -> int:
        """Delete multiple users_user_user_permissions records.

        Parameters
        ----------
        where
            Optional users_user_user_permissions filter to find the records to be deleted

        Returns
        -------
        int
            The total number of users_user_user_permissions records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all users_user_user_permissions records
        total = await users_user_user_permissions.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.users_user_user_permissionsScalarFieldKeys'],
        *,
        where: Optional['types.users_user_user_permissionsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.users_user_user_permissionsAvgAggregateInput'] = None,
        sum: Optional['types.users_user_user_permissionsSumAggregateInput'] = None,
        min: Optional['types.users_user_user_permissionsMinAggregateInput'] = None,
        max: Optional['types.users_user_user_permissionsMaxAggregateInput'] = None,
        having: Optional['types.users_user_user_permissionsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.users_user_user_permissionsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.users_user_user_permissionsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.users_user_user_permissionsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.users_user_user_permissionsGroupByOutput']:
        """Group users_user_user_permissions records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar users_user_user_permissions fields to group records by
        where
            users_user_user_permissions filter to select records
        take
            Limit the maximum number of users_user_user_permissions records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.users_user_user_permissionsGroupByOutput]
            A list of dictionaries representing the users_user_user_permissions record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group users_user_user_permissions records by permission_id values
        # and count how many records are in each group
        results = await users_user_user_permissions.prisma().group_by(
            ['permission_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models