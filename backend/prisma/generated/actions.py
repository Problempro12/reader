# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
                'username': 'bbehjachib',
                'passwordHash': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'dgiiaaijj',
                    'username': 'bfaiacjjfc',
                    'passwordHash': 'eigcfgbif',
                },
                {
                    # data to create a User record
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'passwordHash': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 836760821,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 595337866,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 790425851,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the username field
        users = await User.prisma().find_many(
            take=5,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the passwordHash field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'passwordHash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the isPremium field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'isPremium': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 2111915288,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 1149758321,
            },
            data={
                'create': {
                    'id': 1149758321,
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'passwordHash': 'biabhbdai',
                },
                'update': {
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'passwordHash': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'premiumExpirationDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'hideAds': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'avatar': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by about values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['about'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GenreActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Genre]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Genre.prisma().query_raw(
            'SELECT * FROM Genre WHERE id = $1',
            1644289366,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Genre
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Genre.prisma().query_first(
            'SELECT * FROM Genre WHERE name = $1',
            'bdiicjafbj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GenreCreateInput,
        include: Optional[types.GenreInclude] = None
    ) -> _PrismaModelT:
        """Create a new Genre record.

        Parameters
        ----------
        data
            Genre record data
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The created Genre record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Genre record from just the required fields
        genre = await Genre.prisma().create(
            data={
                # data to create a Genre record
                'name': 'bgehebiafc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GenreCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Genre records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Genre record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Genre.prisma().create_many(
            data=[
                {
                    # data to create a Genre record
                    'name': 'bghffegacj',
                },
                {
                    # data to create a Genre record
                    'name': 'bhghchehcc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Genre record.

        Parameters
        ----------
        where
            Genre filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The deleted Genre record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().delete(
            where={
                'id': 326272115,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Genre record.

        Parameters
        ----------
        where
            Genre filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The found Genre record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().find_unique(
            where={
                'id': 1343201072,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Genre record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Genre filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The found Genre record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().find_unique_or_raise(
            where={
                'id': 675780521,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
        include: Optional[types.GenreInclude] = None,
        order: Optional[Union[types.GenreOrderByInput, List[types.GenreOrderByInput]]] = None,
        distinct: Optional[List[types.GenreScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Genre records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Genre records returned
        skip
            Ignore the first N results
        where
            Genre filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Genre model
        order
            Order the returned Genre records by any field
        distinct
            Filter Genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Genre]
            The list of all Genre records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Genre records
        genres = await Genre.prisma().find_many(take=10)

        # find the first 5 Genre records ordered by the parentId field
        genres = await Genre.prisma().find_many(
            take=5,
            order={
                'parentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
        include: Optional[types.GenreInclude] = None,
        order: Optional[Union[types.GenreOrderByInput, List[types.GenreOrderByInput]]] = None,
        distinct: Optional[List[types.GenreScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Genre record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Genre filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Genre model
        order
            Order the returned Genre records by any field
        distinct
            Filter Genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Genre
            The first Genre record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Genre record ordered by the createdAt field
        genre = await Genre.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
        include: Optional[types.GenreInclude] = None,
        order: Optional[Union[types.GenreOrderByInput, List[types.GenreOrderByInput]]] = None,
        distinct: Optional[List[types.GenreScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Genre record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Genre filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Genre model
        order
            Order the returned Genre records by any field
        distinct
            Filter Genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Genre
            The first Genre record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Genre record ordered by the updatedAt field
        genre = await Genre.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GenreUpdateInput,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Genre record.

        Parameters
        ----------
        data
            Genre record data specifying what to update
        where
            Genre filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The updated Genre record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        genre = await Genre.prisma().update(
            where={
                'id': 744964398,
            },
            data={
                # data to update the Genre record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GenreWhereUniqueInput,
        data: types.GenreUpsertInput,
        include: Optional[types.GenreInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Genre filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The created or updated Genre record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().upsert(
            where={
                'id': 1969681615,
            },
            data={
                'create': {
                    'id': 1969681615,
                    'name': 'bhghchehcc',
                },
                'update': {
                    'name': 'bhghchehcc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GenreUpdateManyMutationInput,
        where: types.GenreWhereInput,
    ) -> int:
        """Update multiple Genre records

        Parameters
        ----------
        data
            Genre data to update the selected Genre records to
        where
            Filter to select the Genre records to update

        Returns
        -------
        int
            The total number of Genre records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Genre records
        total = await Genre.prisma().update_many(
            data={
                'id': 1116175964
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Genre records present in the database

        Parameters
        ----------
        select
            Select the Genre fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Genre filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GenreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Genre.prisma().count()

        # results: prisma.types.GenreCountAggregateOutput
        results = await Genre.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GenreCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
    ) -> types.GenreCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GenreCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
    ) -> Union[int, types.GenreCountAggregateOutput]:
        """Count the number of Genre records present in the database

        Parameters
        ----------
        select
            Select the Genre fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Genre filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GenreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Genre.prisma().count()

        # results: prisma.types.GenreCountAggregateOutput
        results = await Genre.prisma().count(
            select={
                '_all': True,
                'parentId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GenreCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GenreWhereInput] = None
    ) -> int:
        """Delete multiple Genre records.

        Parameters
        ----------
        where
            Optional Genre filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Genre records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Genre records
        total = await Genre.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GenreScalarFieldKeys'],
        *,
        where: Optional['types.GenreWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GenreAvgAggregateInput'] = None,
        sum: Optional['types.GenreSumAggregateInput'] = None,
        min: Optional['types.GenreMinAggregateInput'] = None,
        max: Optional['types.GenreMaxAggregateInput'] = None,
        having: Optional['types.GenreScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GenreCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GenreScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GenreScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GenreGroupByOutput']:
        """Group Genre records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Genre fields to group records by
        where
            Genre filter to select records
        take
            Limit the maximum number of Genre records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GenreGroupByOutput]
            A list of dictionaries representing the Genre record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Genre records by createdAt values
        # and count how many records are in each group
        results = await Genre.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AgeCategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AgeCategory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AgeCategory.prisma().query_raw(
            'SELECT * FROM AgeCategory WHERE id = $1',
            861472101,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AgeCategory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AgeCategory.prisma().query_first(
            'SELECT * FROM AgeCategory WHERE name = $1',
            'bdadaadhag',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AgeCategoryCreateInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new AgeCategory record.

        Parameters
        ----------
        data
            AgeCategory record data
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The created AgeCategory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AgeCategory record from just the required fields
        agecategory = await AgeCategory.prisma().create(
            data={
                # data to create a AgeCategory record
                'name': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AgeCategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AgeCategory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AgeCategory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AgeCategory.prisma().create_many(
            data=[
                {
                    # data to create a AgeCategory record
                    'name': 'caaaedabfc',
                },
                {
                    # data to create a AgeCategory record
                    'name': 'bigibebcib',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AgeCategory record.

        Parameters
        ----------
        where
            AgeCategory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The deleted AgeCategory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().delete(
            where={
                'id': 1860847622,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AgeCategory record.

        Parameters
        ----------
        where
            AgeCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The found AgeCategory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().find_unique(
            where={
                'id': 1448521415,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AgeCategory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AgeCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The found AgeCategory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().find_unique_or_raise(
            where={
                'id': 1628650740,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
        include: Optional[types.AgeCategoryInclude] = None,
        order: Optional[Union[types.AgeCategoryOrderByInput, List[types.AgeCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.AgeCategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AgeCategory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AgeCategory records returned
        skip
            Ignore the first N results
        where
            AgeCategory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgeCategory model
        order
            Order the returned AgeCategory records by any field
        distinct
            Filter AgeCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AgeCategory]
            The list of all AgeCategory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AgeCategory records
        agecategorys = await AgeCategory.prisma().find_many(take=10)

        # find the first 5 AgeCategory records ordered by the id field
        agecategorys = await AgeCategory.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
        include: Optional[types.AgeCategoryInclude] = None,
        order: Optional[Union[types.AgeCategoryOrderByInput, List[types.AgeCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.AgeCategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AgeCategory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AgeCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgeCategory model
        order
            Order the returned AgeCategory records by any field
        distinct
            Filter AgeCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AgeCategory
            The first AgeCategory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AgeCategory record ordered by the name field
        agecategory = await AgeCategory.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
        include: Optional[types.AgeCategoryInclude] = None,
        order: Optional[Union[types.AgeCategoryOrderByInput, List[types.AgeCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.AgeCategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AgeCategory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AgeCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgeCategory model
        order
            Order the returned AgeCategory records by any field
        distinct
            Filter AgeCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AgeCategory
            The first AgeCategory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AgeCategory record ordered by the id field
        agecategory = await AgeCategory.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AgeCategoryUpdateInput,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AgeCategory record.

        Parameters
        ----------
        data
            AgeCategory record data specifying what to update
        where
            AgeCategory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The updated AgeCategory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().update(
            where={
                'id': 1249606685,
            },
            data={
                # data to update the AgeCategory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        data: types.AgeCategoryUpsertInput,
        include: Optional[types.AgeCategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AgeCategory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The created or updated AgeCategory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().upsert(
            where={
                'id': 835903122,
            },
            data={
                'create': {
                    'id': 835903122,
                    'name': 'bigibebcib',
                },
                'update': {
                    'name': 'bigibebcib',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AgeCategoryUpdateManyMutationInput,
        where: types.AgeCategoryWhereInput,
    ) -> int:
        """Update multiple AgeCategory records

        Parameters
        ----------
        data
            AgeCategory data to update the selected AgeCategory records to
        where
            Filter to select the AgeCategory records to update

        Returns
        -------
        int
            The total number of AgeCategory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AgeCategory records
        total = await AgeCategory.prisma().update_many(
            data={
                'name': 'hgdhbjhhj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AgeCategory records present in the database

        Parameters
        ----------
        select
            Select the AgeCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AgeCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgeCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AgeCategory.prisma().count()

        # results: prisma.types.AgeCategoryCountAggregateOutput
        results = await AgeCategory.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AgeCategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
    ) -> types.AgeCategoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AgeCategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
    ) -> Union[int, types.AgeCategoryCountAggregateOutput]:
        """Count the number of AgeCategory records present in the database

        Parameters
        ----------
        select
            Select the AgeCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AgeCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgeCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AgeCategory.prisma().count()

        # results: prisma.types.AgeCategoryCountAggregateOutput
        results = await AgeCategory.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AgeCategoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AgeCategoryWhereInput] = None
    ) -> int:
        """Delete multiple AgeCategory records.

        Parameters
        ----------
        where
            Optional AgeCategory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AgeCategory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AgeCategory records
        total = await AgeCategory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AgeCategoryScalarFieldKeys'],
        *,
        where: Optional['types.AgeCategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AgeCategoryAvgAggregateInput'] = None,
        sum: Optional['types.AgeCategorySumAggregateInput'] = None,
        min: Optional['types.AgeCategoryMinAggregateInput'] = None,
        max: Optional['types.AgeCategoryMaxAggregateInput'] = None,
        having: Optional['types.AgeCategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AgeCategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AgeCategoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AgeCategoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AgeCategoryGroupByOutput']:
        """Group AgeCategory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AgeCategory fields to group records by
        where
            AgeCategory filter to select records
        take
            Limit the maximum number of AgeCategory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AgeCategoryGroupByOutput]
            A list of dictionaries representing the AgeCategory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AgeCategory records by id values
        # and count how many records are in each group
        results = await AgeCategory.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BookActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Book]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Book.prisma().query_raw(
            'SELECT * FROM Book WHERE id = $1',
            429995104,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Book
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Book.prisma().query_first(
            'SELECT * FROM Book WHERE title = $1',
            'bhhfibbigf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BookCreateInput,
        include: Optional[types.BookInclude] = None
    ) -> _PrismaModelT:
        """Create a new Book record.

        Parameters
        ----------
        data
            Book record data
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The created Book record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Book record from just the required fields
        book = await Book.prisma().create(
            data={
                # data to create a Book record
                'title': 'ijdbeffgg',
                'author': 'jjfeafhfj',
                'litresId': 2102736524,
                'ageCategoryId': 271520213,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BookCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Book records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Book record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Book.prisma().create_many(
            data=[
                {
                    # data to create a Book record
                    'title': 'efggddide',
                    'author': 'caficfigfb',
                    'litresId': 1583689592,
                    'ageCategoryId': 878442065,
                },
                {
                    # data to create a Book record
                    'title': 'bghfciaafe',
                    'author': 'bgchfhgceh',
                    'litresId': 2054802212,
                    'ageCategoryId': 60335757,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Book record.

        Parameters
        ----------
        where
            Book filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The deleted Book record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().delete(
            where={
                'id': 684462146,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Book record.

        Parameters
        ----------
        where
            Book filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The found Book record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().find_unique(
            where={
                'id': 1625503827,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Book record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Book filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The found Book record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().find_unique_or_raise(
            where={
                'id': 521827728,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
        include: Optional[types.BookInclude] = None,
        order: Optional[Union[types.BookOrderByInput, List[types.BookOrderByInput]]] = None,
        distinct: Optional[List[types.BookScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Book records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Book records returned
        skip
            Ignore the first N results
        where
            Book filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Book model
        order
            Order the returned Book records by any field
        distinct
            Filter Book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Book]
            The list of all Book records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Book records
        books = await Book.prisma().find_many(take=10)

        # find the first 5 Book records ordered by the author field
        books = await Book.prisma().find_many(
            take=5,
            order={
                'author': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
        include: Optional[types.BookInclude] = None,
        order: Optional[Union[types.BookOrderByInput, List[types.BookOrderByInput]]] = None,
        distinct: Optional[List[types.BookScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Book record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Book filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Book model
        order
            Order the returned Book records by any field
        distinct
            Filter Book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Book
            The first Book record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Book record ordered by the description field
        book = await Book.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
        include: Optional[types.BookInclude] = None,
        order: Optional[Union[types.BookOrderByInput, List[types.BookOrderByInput]]] = None,
        distinct: Optional[List[types.BookScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Book record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Book filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Book model
        order
            Order the returned Book records by any field
        distinct
            Filter Book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Book
            The first Book record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Book record ordered by the coverUrl field
        book = await Book.prisma().find_first_or_raise(
            skip=1,
            order={
                'coverUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BookUpdateInput,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Book record.

        Parameters
        ----------
        data
            Book record data specifying what to update
        where
            Book filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The updated Book record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        book = await Book.prisma().update(
            where={
                'id': 1266032265,
            },
            data={
                # data to update the Book record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BookWhereUniqueInput,
        data: types.BookUpsertInput,
        include: Optional[types.BookInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Book filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The created or updated Book record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().upsert(
            where={
                'id': 93253262,
            },
            data={
                'create': {
                    'id': 93253262,
                    'title': 'bghfciaafe',
                    'author': 'bgchfhgceh',
                    'litresId': 2054802212,
                    'ageCategoryId': 60335757,
                },
                'update': {
                    'title': 'bghfciaafe',
                    'author': 'bgchfhgceh',
                    'litresId': 2054802212,
                    'ageCategoryId': 60335757,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BookUpdateManyMutationInput,
        where: types.BookWhereInput,
    ) -> int:
        """Update multiple Book records

        Parameters
        ----------
        data
            Book data to update the selected Book records to
        where
            Filter to select the Book records to update

        Returns
        -------
        int
            The total number of Book records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Book records
        total = await Book.prisma().update_many(
            data={
                'litresId': 2053047983
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Book records present in the database

        Parameters
        ----------
        select
            Select the Book fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Book filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Book.prisma().count()

        # results: prisma.types.BookCountAggregateOutput
        results = await Book.prisma().count(
            select={
                '_all': True,
                'genreId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BookCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
    ) -> types.BookCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BookCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
    ) -> Union[int, types.BookCountAggregateOutput]:
        """Count the number of Book records present in the database

        Parameters
        ----------
        select
            Select the Book fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Book filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Book.prisma().count()

        # results: prisma.types.BookCountAggregateOutput
        results = await Book.prisma().count(
            select={
                '_all': True,
                'ageCategoryId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BookCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BookWhereInput] = None
    ) -> int:
        """Delete multiple Book records.

        Parameters
        ----------
        where
            Optional Book filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Book records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Book records
        total = await Book.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BookScalarFieldKeys'],
        *,
        where: Optional['types.BookWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BookAvgAggregateInput'] = None,
        sum: Optional['types.BookSumAggregateInput'] = None,
        min: Optional['types.BookMinAggregateInput'] = None,
        max: Optional['types.BookMaxAggregateInput'] = None,
        having: Optional['types.BookScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BookCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BookScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BookScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BookGroupByOutput']:
        """Group Book records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Book fields to group records by
        where
            Book filter to select records
        take
            Limit the maximum number of Book records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BookGroupByOutput]
            A list of dictionaries representing the Book record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Book records by rating values
        # and count how many records are in each group
        results = await Book.prisma().group_by(
            ['rating'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserBookActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserBook]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserBook.prisma().query_raw(
            'SELECT * FROM UserBook WHERE id = $1',
            685333180,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserBook
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserBook.prisma().query_first(
            'SELECT * FROM UserBook WHERE userId = $1',
            127474245,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserBookCreateInput,
        include: Optional[types.UserBookInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserBook record.

        Parameters
        ----------
        data
            UserBook record data
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The created UserBook record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserBook record from just the required fields
        userbook = await UserBook.prisma().create(
            data={
                # data to create a UserBook record
                'userId': 948921754,
                'bookId': 1964990155,
                'status': 'bcciijbibg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserBookCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserBook records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserBook record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserBook.prisma().create_many(
            data=[
                {
                    # data to create a UserBook record
                    'userId': 255202753,
                    'bookId': 1223573862,
                    'status': 'febcgjbfj',
                },
                {
                    # data to create a UserBook record
                    'userId': 1064846676,
                    'bookId': 508382461,
                    'status': 'bacecgfhbe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserBook record.

        Parameters
        ----------
        where
            UserBook filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The deleted UserBook record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().delete(
            where={
                'id': 872078403,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserBook record.

        Parameters
        ----------
        where
            UserBook filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The found UserBook record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().find_unique(
            where={
                'id': 1874748096,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserBook record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserBook filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The found UserBook record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().find_unique_or_raise(
            where={
                'id': 916896761,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
        include: Optional[types.UserBookInclude] = None,
        order: Optional[Union[types.UserBookOrderByInput, List[types.UserBookOrderByInput]]] = None,
        distinct: Optional[List[types.UserBookScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserBook records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserBook records returned
        skip
            Ignore the first N results
        where
            UserBook filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBook model
        order
            Order the returned UserBook records by any field
        distinct
            Filter UserBook records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserBook]
            The list of all UserBook records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserBook records
        userbooks = await UserBook.prisma().find_many(take=10)

        # find the first 5 UserBook records ordered by the bookId field
        userbooks = await UserBook.prisma().find_many(
            take=5,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
        include: Optional[types.UserBookInclude] = None,
        order: Optional[Union[types.UserBookOrderByInput, List[types.UserBookOrderByInput]]] = None,
        distinct: Optional[List[types.UserBookScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserBook record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserBook filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBook model
        order
            Order the returned UserBook records by any field
        distinct
            Filter UserBook records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserBook
            The first UserBook record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserBook record ordered by the status field
        userbook = await UserBook.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
        include: Optional[types.UserBookInclude] = None,
        order: Optional[Union[types.UserBookOrderByInput, List[types.UserBookOrderByInput]]] = None,
        distinct: Optional[List[types.UserBookScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserBook record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserBook filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBook model
        order
            Order the returned UserBook records by any field
        distinct
            Filter UserBook records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserBook
            The first UserBook record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserBook record ordered by the createdAt field
        userbook = await UserBook.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserBookUpdateInput,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserBook record.

        Parameters
        ----------
        data
            UserBook record data specifying what to update
        where
            UserBook filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The updated UserBook record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userbook = await UserBook.prisma().update(
            where={
                'id': 769267518,
            },
            data={
                # data to update the UserBook record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserBookWhereUniqueInput,
        data: types.UserBookUpsertInput,
        include: Optional[types.UserBookInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserBook filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The created or updated UserBook record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().upsert(
            where={
                'id': 820312479,
            },
            data={
                'create': {
                    'id': 820312479,
                    'userId': 1064846676,
                    'bookId': 508382461,
                    'status': 'bacecgfhbe',
                },
                'update': {
                    'userId': 1064846676,
                    'bookId': 508382461,
                    'status': 'bacecgfhbe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserBookUpdateManyMutationInput,
        where: types.UserBookWhereInput,
    ) -> int:
        """Update multiple UserBook records

        Parameters
        ----------
        data
            UserBook data to update the selected UserBook records to
        where
            Filter to select the UserBook records to update

        Returns
        -------
        int
            The total number of UserBook records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserBook records
        total = await UserBook.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserBook records present in the database

        Parameters
        ----------
        select
            Select the UserBook fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserBook filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserBookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserBook.prisma().count()

        # results: prisma.types.UserBookCountAggregateOutput
        results = await UserBook.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserBookCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
    ) -> types.UserBookCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserBookCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
    ) -> Union[int, types.UserBookCountAggregateOutput]:
        """Count the number of UserBook records present in the database

        Parameters
        ----------
        select
            Select the UserBook fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserBook filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserBookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserBook.prisma().count()

        # results: prisma.types.UserBookCountAggregateOutput
        results = await UserBook.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserBookCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserBookWhereInput] = None
    ) -> int:
        """Delete multiple UserBook records.

        Parameters
        ----------
        where
            Optional UserBook filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserBook records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserBook records
        total = await UserBook.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserBookScalarFieldKeys'],
        *,
        where: Optional['types.UserBookWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserBookAvgAggregateInput'] = None,
        sum: Optional['types.UserBookSumAggregateInput'] = None,
        min: Optional['types.UserBookMinAggregateInput'] = None,
        max: Optional['types.UserBookMaxAggregateInput'] = None,
        having: Optional['types.UserBookScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserBookCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserBookScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserBookScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserBookGroupByOutput']:
        """Group UserBook records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserBook fields to group records by
        where
            UserBook filter to select records
        take
            Limit the maximum number of UserBook records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserBookGroupByOutput]
            A list of dictionaries representing the UserBook record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserBook records by bookId values
        # and count how many records are in each group
        results = await UserBook.prisma().group_by(
            ['bookId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class VoteActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Vote]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Vote.prisma().query_raw(
            'SELECT * FROM Vote WHERE id = $1',
            92728044,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Vote
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Vote.prisma().query_first(
            'SELECT * FROM Vote WHERE userId = $1',
            344858293,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.VoteCreateInput,
        include: Optional[types.VoteInclude] = None
    ) -> _PrismaModelT:
        """Create a new Vote record.

        Parameters
        ----------
        data
            Vote record data
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The created Vote record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Vote record from just the required fields
        vote = await Vote.prisma().create(
            data={
                # data to create a Vote record
                'userId': 1121741130,
                'bookId': 1495896251,
                'weekNumber': 208521688,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.VoteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Vote records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Vote record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Vote.prisma().create_many(
            data=[
                {
                    # data to create a Vote record
                    'userId': 860811569,
                    'bookId': 1660932118,
                    'weekNumber': 525761943,
                },
                {
                    # data to create a Vote record
                    'userId': 736209796,
                    'bookId': 493907821,
                    'weekNumber': 639686562,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Vote record.

        Parameters
        ----------
        where
            Vote filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The deleted Vote record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().delete(
            where={
                'id': 654007347,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Vote record.

        Parameters
        ----------
        where
            Vote filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The found Vote record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().find_unique(
            where={
                'id': 1905261552,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Vote record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Vote filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The found Vote record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().find_unique_or_raise(
            where={
                'id': 78746985,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
        include: Optional[types.VoteInclude] = None,
        order: Optional[Union[types.VoteOrderByInput, List[types.VoteOrderByInput]]] = None,
        distinct: Optional[List[types.VoteScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Vote records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Vote records returned
        skip
            Ignore the first N results
        where
            Vote filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vote model
        order
            Order the returned Vote records by any field
        distinct
            Filter Vote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Vote]
            The list of all Vote records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Vote records
        votes = await Vote.prisma().find_many(take=10)

        # find the first 5 Vote records ordered by the bookId field
        votes = await Vote.prisma().find_many(
            take=5,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
        include: Optional[types.VoteInclude] = None,
        order: Optional[Union[types.VoteOrderByInput, List[types.VoteOrderByInput]]] = None,
        distinct: Optional[List[types.VoteScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Vote record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Vote filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vote model
        order
            Order the returned Vote records by any field
        distinct
            Filter Vote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Vote
            The first Vote record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Vote record ordered by the weekNumber field
        vote = await Vote.prisma().find_first(
            skip=1,
            order={
                'weekNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
        include: Optional[types.VoteInclude] = None,
        order: Optional[Union[types.VoteOrderByInput, List[types.VoteOrderByInput]]] = None,
        distinct: Optional[List[types.VoteScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Vote record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Vote filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vote model
        order
            Order the returned Vote records by any field
        distinct
            Filter Vote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Vote
            The first Vote record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Vote record ordered by the voteDate field
        vote = await Vote.prisma().find_first_or_raise(
            skip=1,
            order={
                'voteDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.VoteUpdateInput,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Vote record.

        Parameters
        ----------
        data
            Vote record data specifying what to update
        where
            Vote filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The updated Vote record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        vote = await Vote.prisma().update(
            where={
                'id': 1398328302,
            },
            data={
                # data to update the Vote record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.VoteWhereUniqueInput,
        data: types.VoteUpsertInput,
        include: Optional[types.VoteInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Vote filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The created or updated Vote record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().upsert(
            where={
                'id': 856000655,
            },
            data={
                'create': {
                    'id': 856000655,
                    'userId': 736209796,
                    'bookId': 493907821,
                    'weekNumber': 639686562,
                },
                'update': {
                    'userId': 736209796,
                    'bookId': 493907821,
                    'weekNumber': 639686562,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.VoteUpdateManyMutationInput,
        where: types.VoteWhereInput,
    ) -> int:
        """Update multiple Vote records

        Parameters
        ----------
        data
            Vote data to update the selected Vote records to
        where
            Filter to select the Vote records to update

        Returns
        -------
        int
            The total number of Vote records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Vote records
        total = await Vote.prisma().update_many(
            data={
                'id': 1452336924
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Vote records present in the database

        Parameters
        ----------
        select
            Select the Vote fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Vote filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VoteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Vote.prisma().count()

        # results: prisma.types.VoteCountAggregateOutput
        results = await Vote.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.VoteCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
    ) -> types.VoteCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.VoteCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
    ) -> Union[int, types.VoteCountAggregateOutput]:
        """Count the number of Vote records present in the database

        Parameters
        ----------
        select
            Select the Vote fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Vote filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VoteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Vote.prisma().count()

        # results: prisma.types.VoteCountAggregateOutput
        results = await Vote.prisma().count(
            select={
                '_all': True,
                'bookId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.VoteCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.VoteWhereInput] = None
    ) -> int:
        """Delete multiple Vote records.

        Parameters
        ----------
        where
            Optional Vote filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Vote records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Vote records
        total = await Vote.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.VoteScalarFieldKeys'],
        *,
        where: Optional['types.VoteWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.VoteAvgAggregateInput'] = None,
        sum: Optional['types.VoteSumAggregateInput'] = None,
        min: Optional['types.VoteMinAggregateInput'] = None,
        max: Optional['types.VoteMaxAggregateInput'] = None,
        having: Optional['types.VoteScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.VoteCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.VoteScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.VoteScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.VoteGroupByOutput']:
        """Group Vote records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Vote fields to group records by
        where
            Vote filter to select records
        take
            Limit the maximum number of Vote records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.VoteGroupByOutput]
            A list of dictionaries representing the Vote record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Vote records by weekNumber values
        # and count how many records are in each group
        results = await Vote.prisma().group_by(
            ['weekNumber'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReadingProgressActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ReadingProgress]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ReadingProgress.prisma().query_raw(
            'SELECT * FROM ReadingProgress WHERE id = $1',
            1573199653,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ReadingProgress
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ReadingProgress.prisma().query_first(
            'SELECT * FROM ReadingProgress WHERE userId = $1',
            2013903098,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReadingProgressCreateInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> _PrismaModelT:
        """Create a new ReadingProgress record.

        Parameters
        ----------
        data
            ReadingProgress record data
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The created ReadingProgress record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ReadingProgress record from just the required fields
        readingprogress = await ReadingProgress.prisma().create(
            data={
                # data to create a ReadingProgress record
                'userId': 500965035,
                'bookId': 1800624392,
                'weekNumber': 2077067425,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReadingProgressCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ReadingProgress records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ReadingProgress record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ReadingProgress.prisma().create_many(
            data=[
                {
                    # data to create a ReadingProgress record
                    'userId': 1672112838,
                    'bookId': 926677639,
                    'weekNumber': 1447624116,
                },
                {
                    # data to create a ReadingProgress record
                    'userId': 1738083805,
                    'bookId': 340946258,
                    'weekNumber': 601077795,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ReadingProgress record.

        Parameters
        ----------
        where
            ReadingProgress filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The deleted ReadingProgress record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().delete(
            where={
                'id': 290603296,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ReadingProgress record.

        Parameters
        ----------
        where
            ReadingProgress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The found ReadingProgress record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().find_unique(
            where={
                'id': 1855826649,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ReadingProgress record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ReadingProgress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The found ReadingProgress record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().find_unique_or_raise(
            where={
                'id': 1611009182,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
        include: Optional[types.ReadingProgressInclude] = None,
        order: Optional[Union[types.ReadingProgressOrderByInput, List[types.ReadingProgressOrderByInput]]] = None,
        distinct: Optional[List[types.ReadingProgressScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ReadingProgress records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ReadingProgress records returned
        skip
            Ignore the first N results
        where
            ReadingProgress filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReadingProgress model
        order
            Order the returned ReadingProgress records by any field
        distinct
            Filter ReadingProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ReadingProgress]
            The list of all ReadingProgress records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ReadingProgress records
        readingprogress = await ReadingProgress.prisma().find_many(take=10)

        # find the first 5 ReadingProgress records ordered by the bookId field
        readingprogress = await ReadingProgress.prisma().find_many(
            take=5,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
        include: Optional[types.ReadingProgressInclude] = None,
        order: Optional[Union[types.ReadingProgressOrderByInput, List[types.ReadingProgressOrderByInput]]] = None,
        distinct: Optional[List[types.ReadingProgressScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ReadingProgress record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReadingProgress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReadingProgress model
        order
            Order the returned ReadingProgress records by any field
        distinct
            Filter ReadingProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReadingProgress
            The first ReadingProgress record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReadingProgress record ordered by the weekNumber field
        readingprogress = await ReadingProgress.prisma().find_first(
            skip=1,
            order={
                'weekNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
        include: Optional[types.ReadingProgressInclude] = None,
        order: Optional[Union[types.ReadingProgressOrderByInput, List[types.ReadingProgressOrderByInput]]] = None,
        distinct: Optional[List[types.ReadingProgressScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ReadingProgress record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReadingProgress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReadingProgress model
        order
            Order the returned ReadingProgress records by any field
        distinct
            Filter ReadingProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReadingProgress
            The first ReadingProgress record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReadingProgress record ordered by the marks field
        readingprogress = await ReadingProgress.prisma().find_first_or_raise(
            skip=1,
            order={
                'marks': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReadingProgressUpdateInput,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ReadingProgress record.

        Parameters
        ----------
        data
            ReadingProgress record data specifying what to update
        where
            ReadingProgress filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The updated ReadingProgress record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().update(
            where={
                'id': 446673791,
            },
            data={
                # data to update the ReadingProgress record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        data: types.ReadingProgressUpsertInput,
        include: Optional[types.ReadingProgressInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ReadingProgress filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The created or updated ReadingProgress record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().upsert(
            where={
                'id': 300568396,
            },
            data={
                'create': {
                    'id': 300568396,
                    'userId': 1738083805,
                    'bookId': 340946258,
                    'weekNumber': 601077795,
                },
                'update': {
                    'userId': 1738083805,
                    'bookId': 340946258,
                    'weekNumber': 601077795,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReadingProgressUpdateManyMutationInput,
        where: types.ReadingProgressWhereInput,
    ) -> int:
        """Update multiple ReadingProgress records

        Parameters
        ----------
        data
            ReadingProgress data to update the selected ReadingProgress records to
        where
            Filter to select the ReadingProgress records to update

        Returns
        -------
        int
            The total number of ReadingProgress records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ReadingProgress records
        total = await ReadingProgress.prisma().update_many(
            data={
                'progressDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ReadingProgress records present in the database

        Parameters
        ----------
        select
            Select the ReadingProgress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReadingProgress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReadingProgressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReadingProgress.prisma().count()

        # results: prisma.types.ReadingProgressCountAggregateOutput
        results = await ReadingProgress.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReadingProgressCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
    ) -> types.ReadingProgressCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReadingProgressCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
    ) -> Union[int, types.ReadingProgressCountAggregateOutput]:
        """Count the number of ReadingProgress records present in the database

        Parameters
        ----------
        select
            Select the ReadingProgress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReadingProgress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReadingProgressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReadingProgress.prisma().count()

        # results: prisma.types.ReadingProgressCountAggregateOutput
        results = await ReadingProgress.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReadingProgressCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReadingProgressWhereInput] = None
    ) -> int:
        """Delete multiple ReadingProgress records.

        Parameters
        ----------
        where
            Optional ReadingProgress filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ReadingProgress records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ReadingProgress records
        total = await ReadingProgress.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReadingProgressScalarFieldKeys'],
        *,
        where: Optional['types.ReadingProgressWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReadingProgressAvgAggregateInput'] = None,
        sum: Optional['types.ReadingProgressSumAggregateInput'] = None,
        min: Optional['types.ReadingProgressMinAggregateInput'] = None,
        max: Optional['types.ReadingProgressMaxAggregateInput'] = None,
        having: Optional['types.ReadingProgressScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReadingProgressCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReadingProgressScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ReadingProgressScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ReadingProgressGroupByOutput']:
        """Group ReadingProgress records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ReadingProgress fields to group records by
        where
            ReadingProgress filter to select records
        take
            Limit the maximum number of ReadingProgress records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReadingProgressGroupByOutput]
            A list of dictionaries representing the ReadingProgress record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ReadingProgress records by bookId values
        # and count how many records are in each group
        results = await ReadingProgress.prisma().group_by(
            ['bookId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WeeklyResultActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.WeeklyResult]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await WeeklyResult.prisma().query_raw(
            'SELECT * FROM WeeklyResult WHERE id = $1',
            632626069,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.WeeklyResult
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await WeeklyResult.prisma().query_first(
            'SELECT * FROM WeeklyResult WHERE weekNumber = $1',
            1724011690,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WeeklyResultCreateInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> _PrismaModelT:
        """Create a new WeeklyResult record.

        Parameters
        ----------
        data
            WeeklyResult record data
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The created WeeklyResult record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a WeeklyResult record from just the required fields
        weeklyresult = await WeeklyResult.prisma().create(
            data={
                # data to create a WeeklyResult record
                'weekNumber': 470157467,
                'ageCategoryId': 1209209912,
                'bookId': 1536744465,
                'leaderUserId': 424218998,
                'totalMarks': 2125632375,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WeeklyResultCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple WeeklyResult records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of WeeklyResult record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await WeeklyResult.prisma().create_many(
            data=[
                {
                    # data to create a WeeklyResult record
                    'weekNumber': 536951780,
                    'ageCategoryId': 924723277,
                    'bookId': 1621937922,
                    'leaderUserId': 1848832019,
                    'totalMarks': 1921528400,
                },
                {
                    # data to create a WeeklyResult record
                    'weekNumber': 2100427849,
                    'ageCategoryId': 849140046,
                    'bookId': 928152175,
                    'leaderUserId': 273032060,
                    'totalMarks': 982848517,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single WeeklyResult record.

        Parameters
        ----------
        where
            WeeklyResult filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The deleted WeeklyResult record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().delete(
            where={
                'id': 510737498,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique WeeklyResult record.

        Parameters
        ----------
        where
            WeeklyResult filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The found WeeklyResult record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().find_unique(
            where={
                'id': 2117488267,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> _PrismaModelT:
        """Find a unique WeeklyResult record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            WeeklyResult filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The found WeeklyResult record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().find_unique_or_raise(
            where={
                'id': 1401944936,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
        include: Optional[types.WeeklyResultInclude] = None,
        order: Optional[Union[types.WeeklyResultOrderByInput, List[types.WeeklyResultOrderByInput]]] = None,
        distinct: Optional[List[types.WeeklyResultScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple WeeklyResult records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of WeeklyResult records returned
        skip
            Ignore the first N results
        where
            WeeklyResult filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WeeklyResult model
        order
            Order the returned WeeklyResult records by any field
        distinct
            Filter WeeklyResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.WeeklyResult]
            The list of all WeeklyResult records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 WeeklyResult records
        weeklyresults = await WeeklyResult.prisma().find_many(take=10)

        # find the first 5 WeeklyResult records ordered by the genreId field
        weeklyresults = await WeeklyResult.prisma().find_many(
            take=5,
            order={
                'genreId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
        include: Optional[types.WeeklyResultInclude] = None,
        order: Optional[Union[types.WeeklyResultOrderByInput, List[types.WeeklyResultOrderByInput]]] = None,
        distinct: Optional[List[types.WeeklyResultScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single WeeklyResult record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WeeklyResult filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WeeklyResult model
        order
            Order the returned WeeklyResult records by any field
        distinct
            Filter WeeklyResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WeeklyResult
            The first WeeklyResult record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WeeklyResult record ordered by the ageCategoryId field
        weeklyresult = await WeeklyResult.prisma().find_first(
            skip=1,
            order={
                'ageCategoryId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
        include: Optional[types.WeeklyResultInclude] = None,
        order: Optional[Union[types.WeeklyResultOrderByInput, List[types.WeeklyResultOrderByInput]]] = None,
        distinct: Optional[List[types.WeeklyResultScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single WeeklyResult record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WeeklyResult filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WeeklyResult model
        order
            Order the returned WeeklyResult records by any field
        distinct
            Filter WeeklyResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WeeklyResult
            The first WeeklyResult record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WeeklyResult record ordered by the bookId field
        weeklyresult = await WeeklyResult.prisma().find_first_or_raise(
            skip=1,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WeeklyResultUpdateInput,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single WeeklyResult record.

        Parameters
        ----------
        data
            WeeklyResult record data specifying what to update
        where
            WeeklyResult filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The updated WeeklyResult record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().update(
            where={
                'id': 1297607553,
            },
            data={
                # data to update the WeeklyResult record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        data: types.WeeklyResultUpsertInput,
        include: Optional[types.WeeklyResultInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            WeeklyResult filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The created or updated WeeklyResult record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().upsert(
            where={
                'id': 519488550,
            },
            data={
                'create': {
                    'id': 519488550,
                    'weekNumber': 2100427849,
                    'ageCategoryId': 849140046,
                    'bookId': 928152175,
                    'leaderUserId': 273032060,
                    'totalMarks': 982848517,
                },
                'update': {
                    'weekNumber': 2100427849,
                    'ageCategoryId': 849140046,
                    'bookId': 928152175,
                    'leaderUserId': 273032060,
                    'totalMarks': 982848517,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WeeklyResultUpdateManyMutationInput,
        where: types.WeeklyResultWhereInput,
    ) -> int:
        """Update multiple WeeklyResult records

        Parameters
        ----------
        data
            WeeklyResult data to update the selected WeeklyResult records to
        where
            Filter to select the WeeklyResult records to update

        Returns
        -------
        int
            The total number of WeeklyResult records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all WeeklyResult records
        total = await WeeklyResult.prisma().update_many(
            data={
                'leaderUserId': 976832615
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
    ) -> int:
        """Count the number of WeeklyResult records present in the database

        Parameters
        ----------
        select
            Select the WeeklyResult fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WeeklyResult filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WeeklyResultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WeeklyResult.prisma().count()

        # results: prisma.types.WeeklyResultCountAggregateOutput
        results = await WeeklyResult.prisma().count(
            select={
                '_all': True,
                'totalMarks': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WeeklyResultCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
    ) -> types.WeeklyResultCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WeeklyResultCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
    ) -> Union[int, types.WeeklyResultCountAggregateOutput]:
        """Count the number of WeeklyResult records present in the database

        Parameters
        ----------
        select
            Select the WeeklyResult fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WeeklyResult filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WeeklyResultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WeeklyResult.prisma().count()

        # results: prisma.types.WeeklyResultCountAggregateOutput
        results = await WeeklyResult.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WeeklyResultCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WeeklyResultWhereInput] = None
    ) -> int:
        """Delete multiple WeeklyResult records.

        Parameters
        ----------
        where
            Optional WeeklyResult filter to find the records to be deleted

        Returns
        -------
        int
            The total number of WeeklyResult records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all WeeklyResult records
        total = await WeeklyResult.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WeeklyResultScalarFieldKeys'],
        *,
        where: Optional['types.WeeklyResultWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WeeklyResultAvgAggregateInput'] = None,
        sum: Optional['types.WeeklyResultSumAggregateInput'] = None,
        min: Optional['types.WeeklyResultMinAggregateInput'] = None,
        max: Optional['types.WeeklyResultMaxAggregateInput'] = None,
        having: Optional['types.WeeklyResultScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WeeklyResultCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WeeklyResultScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WeeklyResultScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WeeklyResultGroupByOutput']:
        """Group WeeklyResult records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar WeeklyResult fields to group records by
        where
            WeeklyResult filter to select records
        take
            Limit the maximum number of WeeklyResult records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WeeklyResultGroupByOutput]
            A list of dictionaries representing the WeeklyResult record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group WeeklyResult records by weekNumber values
        # and count how many records are in each group
        results = await WeeklyResult.prisma().group_by(
            ['weekNumber'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Notification]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Notification.prisma().query_raw(
            'SELECT * FROM Notification WHERE id = $1',
            1696425492,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Notification
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Notification.prisma().query_first(
            'SELECT * FROM Notification WHERE userId = $1',
            169262781,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Notification record.

        Parameters
        ----------
        data
            Notification record data
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created Notification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Notification record from just the required fields
        notification = await Notification.prisma().create(
            data={
                # data to create a Notification record
                'userId': 1023081650,
                'message': 'dchgibach',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Notification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Notification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Notification.prisma().create_many(
            data=[
                {
                    # data to create a Notification record
                    'userId': 527748992,
                    'message': 'cacjdfhejh',
                },
                {
                    # data to create a Notification record
                    'userId': 1318597118,
                    'message': 'cbccbbcdfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Notification record.

        Parameters
        ----------
        where
            Notification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The deleted Notification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().delete(
            where={
                'id': 1024943020,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Notification record.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique(
            where={
                'id': 1717307509,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Notification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique_or_raise(
            where={
                'id': 1598124042,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Notification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N results
        where
            Notification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Notification]
            The list of all Notification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Notification records
        notifications = await Notification.prisma().find_many(take=10)

        # find the first 5 Notification records ordered by the message field
        notifications = await Notification.prisma().find_many(
            take=5,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Notification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the sentDate field
        notification = await Notification.prisma().find_first(
            skip=1,
            order={
                'sentDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Notification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the id field
        notification = await Notification.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Notification record.

        Parameters
        ----------
        data
            Notification record data specifying what to update
        where
            Notification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The updated Notification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notification = await Notification.prisma().update(
            where={
                'id': 817623163,
            },
            data={
                # data to update the Notification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Notification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created or updated Notification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().upsert(
            where={
                'id': 1030557336,
            },
            data={
                'create': {
                    'id': 1030557336,
                    'userId': 1318597118,
                    'message': 'cbccbbcdfb',
                },
                'update': {
                    'userId': 1318597118,
                    'message': 'cbccbbcdfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> int:
        """Update multiple Notification records

        Parameters
        ----------
        data
            Notification data to update the selected Notification records to
        where
            Filter to select the Notification records to update

        Returns
        -------
        int
            The total number of Notification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Notification records
        total = await Notification.prisma().update_many(
            data={
                'userId': 1131525873
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'message': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> types.NotificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationCountAggregateOutput]:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'sentDate': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None
    ) -> int:
        """Delete multiple Notification records.

        Parameters
        ----------
        where
            Optional Notification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Notification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Notification records
        total = await Notification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationScalarFieldKeys'],
        *,
        where: Optional['types.NotificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationAvgAggregateInput'] = None,
        sum: Optional['types.NotificationSumAggregateInput'] = None,
        min: Optional['types.NotificationMinAggregateInput'] = None,
        max: Optional['types.NotificationMaxAggregateInput'] = None,
        having: Optional['types.NotificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationGroupByOutput']:
        """Group Notification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Notification fields to group records by
        where
            Notification filter to select records
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationGroupByOutput]
            A list of dictionaries representing the Notification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Notification records by id values
        # and count how many records are in each group
        results = await Notification.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AdvertisementActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Advertisement]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Advertisement.prisma().query_raw(
            'SELECT * FROM Advertisement WHERE id = $1',
            210666198,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Advertisement
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Advertisement.prisma().query_first(
            'SELECT * FROM Advertisement WHERE content = $1',
            'bchgafhjed',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AdvertisementCreateInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> _PrismaModelT:
        """Create a new Advertisement record.

        Parameters
        ----------
        data
            Advertisement record data
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The created Advertisement record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Advertisement record from just the required fields
        advertisement = await Advertisement.prisma().create(
            data={
                # data to create a Advertisement record
                'content': 'heffgjdei',
                'partnerId': 307876141,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AdvertisementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Advertisement records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Advertisement record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Advertisement.prisma().create_many(
            data=[
                {
                    # data to create a Advertisement record
                    'content': 'bgheaejbcc',
                    'partnerId': 1526854643,
                },
                {
                    # data to create a Advertisement record
                    'content': 'jfiahhbae',
                    'partnerId': 1513050921,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Advertisement record.

        Parameters
        ----------
        where
            Advertisement filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The deleted Advertisement record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().delete(
            where={
                'id': 204674734,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Advertisement record.

        Parameters
        ----------
        where
            Advertisement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The found Advertisement record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().find_unique(
            where={
                'id': 2067651663,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Advertisement record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Advertisement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The found Advertisement record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().find_unique_or_raise(
            where={
                'id': 1183911900,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
        include: Optional[types.AdvertisementInclude] = None,
        order: Optional[Union[types.AdvertisementOrderByInput, List[types.AdvertisementOrderByInput]]] = None,
        distinct: Optional[List[types.AdvertisementScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Advertisement records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Advertisement records returned
        skip
            Ignore the first N results
        where
            Advertisement filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Advertisement model
        order
            Order the returned Advertisement records by any field
        distinct
            Filter Advertisement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Advertisement]
            The list of all Advertisement records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Advertisement records
        advertisements = await Advertisement.prisma().find_many(take=10)

        # find the first 5 Advertisement records ordered by the partnerId field
        advertisements = await Advertisement.prisma().find_many(
            take=5,
            order={
                'partnerId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
        include: Optional[types.AdvertisementInclude] = None,
        order: Optional[Union[types.AdvertisementOrderByInput, List[types.AdvertisementOrderByInput]]] = None,
        distinct: Optional[List[types.AdvertisementScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Advertisement record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Advertisement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Advertisement model
        order
            Order the returned Advertisement records by any field
        distinct
            Filter Advertisement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Advertisement
            The first Advertisement record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Advertisement record ordered by the isActive field
        advertisement = await Advertisement.prisma().find_first(
            skip=1,
            order={
                'isActive': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
        include: Optional[types.AdvertisementInclude] = None,
        order: Optional[Union[types.AdvertisementOrderByInput, List[types.AdvertisementOrderByInput]]] = None,
        distinct: Optional[List[types.AdvertisementScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Advertisement record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Advertisement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Advertisement model
        order
            Order the returned Advertisement records by any field
        distinct
            Filter Advertisement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Advertisement
            The first Advertisement record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Advertisement record ordered by the id field
        advertisement = await Advertisement.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AdvertisementUpdateInput,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Advertisement record.

        Parameters
        ----------
        data
            Advertisement record data specifying what to update
        where
            Advertisement filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The updated Advertisement record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().update(
            where={
                'id': 1589704933,
            },
            data={
                # data to update the Advertisement record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AdvertisementWhereUniqueInput,
        data: types.AdvertisementUpsertInput,
        include: Optional[types.AdvertisementInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Advertisement filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The created or updated Advertisement record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().upsert(
            where={
                'id': 1243475898,
            },
            data={
                'create': {
                    'id': 1243475898,
                    'content': 'jfiahhbae',
                    'partnerId': 1513050921,
                },
                'update': {
                    'content': 'jfiahhbae',
                    'partnerId': 1513050921,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AdvertisementUpdateManyMutationInput,
        where: types.AdvertisementWhereInput,
    ) -> int:
        """Update multiple Advertisement records

        Parameters
        ----------
        data
            Advertisement data to update the selected Advertisement records to
        where
            Filter to select the Advertisement records to update

        Returns
        -------
        int
            The total number of Advertisement records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Advertisement records
        total = await Advertisement.prisma().update_many(
            data={
                'content': 'bdgjicijhb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Advertisement records present in the database

        Parameters
        ----------
        select
            Select the Advertisement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Advertisement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdvertisementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Advertisement.prisma().count()

        # results: prisma.types.AdvertisementCountAggregateOutput
        results = await Advertisement.prisma().count(
            select={
                '_all': True,
                'partnerId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AdvertisementCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
    ) -> types.AdvertisementCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AdvertisementCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
    ) -> Union[int, types.AdvertisementCountAggregateOutput]:
        """Count the number of Advertisement records present in the database

        Parameters
        ----------
        select
            Select the Advertisement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Advertisement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdvertisementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Advertisement.prisma().count()

        # results: prisma.types.AdvertisementCountAggregateOutput
        results = await Advertisement.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AdvertisementCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AdvertisementWhereInput] = None
    ) -> int:
        """Delete multiple Advertisement records.

        Parameters
        ----------
        where
            Optional Advertisement filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Advertisement records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Advertisement records
        total = await Advertisement.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AdvertisementScalarFieldKeys'],
        *,
        where: Optional['types.AdvertisementWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AdvertisementAvgAggregateInput'] = None,
        sum: Optional['types.AdvertisementSumAggregateInput'] = None,
        min: Optional['types.AdvertisementMinAggregateInput'] = None,
        max: Optional['types.AdvertisementMaxAggregateInput'] = None,
        having: Optional['types.AdvertisementScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AdvertisementCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AdvertisementScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AdvertisementScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AdvertisementGroupByOutput']:
        """Group Advertisement records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Advertisement fields to group records by
        where
            Advertisement filter to select records
        take
            Limit the maximum number of Advertisement records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AdvertisementGroupByOutput]
            A list of dictionaries representing the Advertisement record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Advertisement records by id values
        # and count how many records are in each group
        results = await Advertisement.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PartnerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Partner]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Partner.prisma().query_raw(
            'SELECT * FROM Partner WHERE id = $1',
            1678593480,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Partner
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Partner.prisma().query_first(
            'SELECT * FROM Partner WHERE name = $1',
            'eadfcbbcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PartnerCreateInput,
        include: Optional[types.PartnerInclude] = None
    ) -> _PrismaModelT:
        """Create a new Partner record.

        Parameters
        ----------
        data
            Partner record data
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The created Partner record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Partner record from just the required fields
        partner = await Partner.prisma().create(
            data={
                # data to create a Partner record
                'name': 'geihgahba',
                'contactInfo': 'gahdcdhbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PartnerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Partner records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Partner record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Partner.prisma().create_many(
            data=[
                {
                    # data to create a Partner record
                    'name': 'begiijahea',
                    'contactInfo': 'gcjadjaaf',
                },
                {
                    # data to create a Partner record
                    'name': 'bcbebgiaic',
                    'contactInfo': 'ijigbdcbj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Partner record.

        Parameters
        ----------
        where
            Partner filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The deleted Partner record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().delete(
            where={
                'id': 658378208,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Partner record.

        Parameters
        ----------
        where
            Partner filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The found Partner record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().find_unique(
            where={
                'id': 954620057,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Partner record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Partner filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The found Partner record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().find_unique_or_raise(
            where={
                'id': 1214809950,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
        include: Optional[types.PartnerInclude] = None,
        order: Optional[Union[types.PartnerOrderByInput, List[types.PartnerOrderByInput]]] = None,
        distinct: Optional[List[types.PartnerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Partner records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Partner records returned
        skip
            Ignore the first N results
        where
            Partner filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Partner model
        order
            Order the returned Partner records by any field
        distinct
            Filter Partner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Partner]
            The list of all Partner records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Partner records
        partners = await Partner.prisma().find_many(take=10)

        # find the first 5 Partner records ordered by the contactInfo field
        partners = await Partner.prisma().find_many(
            take=5,
            order={
                'contactInfo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
        include: Optional[types.PartnerInclude] = None,
        order: Optional[Union[types.PartnerOrderByInput, List[types.PartnerOrderByInput]]] = None,
        distinct: Optional[List[types.PartnerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Partner record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Partner filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Partner model
        order
            Order the returned Partner records by any field
        distinct
            Filter Partner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Partner
            The first Partner record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Partner record ordered by the id field
        partner = await Partner.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
        include: Optional[types.PartnerInclude] = None,
        order: Optional[Union[types.PartnerOrderByInput, List[types.PartnerOrderByInput]]] = None,
        distinct: Optional[List[types.PartnerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Partner record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Partner filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Partner model
        order
            Order the returned Partner records by any field
        distinct
            Filter Partner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Partner
            The first Partner record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Partner record ordered by the name field
        partner = await Partner.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PartnerUpdateInput,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Partner record.

        Parameters
        ----------
        data
            Partner record data specifying what to update
        where
            Partner filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The updated Partner record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        partner = await Partner.prisma().update(
            where={
                'id': 1047820095,
            },
            data={
                # data to update the Partner record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PartnerWhereUniqueInput,
        data: types.PartnerUpsertInput,
        include: Optional[types.PartnerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Partner filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The created or updated Partner record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().upsert(
            where={
                'id': 1302734860,
            },
            data={
                'create': {
                    'id': 1302734860,
                    'name': 'bcbebgiaic',
                    'contactInfo': 'ijigbdcbj',
                },
                'update': {
                    'name': 'bcbebgiaic',
                    'contactInfo': 'ijigbdcbj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PartnerUpdateManyMutationInput,
        where: types.PartnerWhereInput,
    ) -> int:
        """Update multiple Partner records

        Parameters
        ----------
        data
            Partner data to update the selected Partner records to
        where
            Filter to select the Partner records to update

        Returns
        -------
        int
            The total number of Partner records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Partner records
        total = await Partner.prisma().update_many(
            data={
                'contactInfo': 'ijdafccef'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Partner records present in the database

        Parameters
        ----------
        select
            Select the Partner fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Partner filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PartnerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Partner.prisma().count()

        # results: prisma.types.PartnerCountAggregateOutput
        results = await Partner.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PartnerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
    ) -> types.PartnerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PartnerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
    ) -> Union[int, types.PartnerCountAggregateOutput]:
        """Count the number of Partner records present in the database

        Parameters
        ----------
        select
            Select the Partner fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Partner filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PartnerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Partner.prisma().count()

        # results: prisma.types.PartnerCountAggregateOutput
        results = await Partner.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PartnerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PartnerWhereInput] = None
    ) -> int:
        """Delete multiple Partner records.

        Parameters
        ----------
        where
            Optional Partner filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Partner records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Partner records
        total = await Partner.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PartnerScalarFieldKeys'],
        *,
        where: Optional['types.PartnerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PartnerAvgAggregateInput'] = None,
        sum: Optional['types.PartnerSumAggregateInput'] = None,
        min: Optional['types.PartnerMinAggregateInput'] = None,
        max: Optional['types.PartnerMaxAggregateInput'] = None,
        having: Optional['types.PartnerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PartnerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PartnerScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PartnerScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PartnerGroupByOutput']:
        """Group Partner records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Partner fields to group records by
        where
            Partner filter to select records
        take
            Limit the maximum number of Partner records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PartnerGroupByOutput]
            A list of dictionaries representing the Partner record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Partner records by contactInfo values
        # and count how many records are in each group
        results = await Partner.prisma().group_by(
            ['contactInfo'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models