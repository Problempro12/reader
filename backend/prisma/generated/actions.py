# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
                'username': 'bbehjachib',
                'passwordHash': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'dgiiaaijj',
                    'username': 'bfaiacjjfc',
                    'passwordHash': 'eigcfgbif',
                },
                {
                    # data to create a User record
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'passwordHash': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 836760821,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 595337866,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 790425851,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the username field
        users = await User.prisma().find_many(
            take=5,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the passwordHash field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'passwordHash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the isPremium field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'isPremium': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 2111915288,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 1149758321,
            },
            data={
                'create': {
                    'id': 1149758321,
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'passwordHash': 'biabhbdai',
                },
                'update': {
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'passwordHash': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'premiumExpirationDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'hideAds': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by updatedAt values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GroupActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Group]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Group.prisma().query_raw(
            'SELECT * FROM Group WHERE id = $1',
            1644289366,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Group
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Group.prisma().query_first(
            'SELECT * FROM Group WHERE name = $1',
            'bdiicjafbj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GroupCreateInput,
        include: Optional[types.GroupInclude] = None
    ) -> _PrismaModelT:
        """Create a new Group record.

        Parameters
        ----------
        data
            Group record data
        include
            Specifies which relations should be loaded on the returned Group model

        Returns
        -------
        prisma.models.Group
            The created Group record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Group record from just the required fields
        group = await Group.prisma().create(
            data={
                # data to create a Group record
                'name': 'bgehebiafc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GroupCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Group records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Group record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Group.prisma().create_many(
            data=[
                {
                    # data to create a Group record
                    'name': 'bghffegacj',
                },
                {
                    # data to create a Group record
                    'name': 'bhghchehcc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GroupWhereUniqueInput,
        include: Optional[types.GroupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Group record.

        Parameters
        ----------
        where
            Group filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Group model

        Returns
        -------
        prisma.models.Group
            The deleted Group record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        group = await Group.prisma().delete(
            where={
                'id': 326272115,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GroupWhereUniqueInput,
        include: Optional[types.GroupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Group record.

        Parameters
        ----------
        where
            Group filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Group model

        Returns
        -------
        prisma.models.Group
            The found Group record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        group = await Group.prisma().find_unique(
            where={
                'id': 1343201072,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GroupWhereUniqueInput,
        include: Optional[types.GroupInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Group record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Group filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Group model

        Returns
        -------
        prisma.models.Group
            The found Group record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        group = await Group.prisma().find_unique_or_raise(
            where={
                'id': 675780521,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GroupWhereInput] = None,
        cursor: Optional[types.GroupWhereUniqueInput] = None,
        include: Optional[types.GroupInclude] = None,
        order: Optional[Union[types.GroupOrderByInput, List[types.GroupOrderByInput]]] = None,
        distinct: Optional[List[types.GroupScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Group records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Group records returned
        skip
            Ignore the first N results
        where
            Group filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Group model
        order
            Order the returned Group records by any field
        distinct
            Filter Group records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Group]
            The list of all Group records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Group records
        groups = await Group.prisma().find_many(take=10)

        # find the first 5 Group records ordered by the createdAt field
        groups = await Group.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GroupWhereInput] = None,
        cursor: Optional[types.GroupWhereUniqueInput] = None,
        include: Optional[types.GroupInclude] = None,
        order: Optional[Union[types.GroupOrderByInput, List[types.GroupOrderByInput]]] = None,
        distinct: Optional[List[types.GroupScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Group record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Group filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Group model
        order
            Order the returned Group records by any field
        distinct
            Filter Group records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Group
            The first Group record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Group record ordered by the updatedAt field
        group = await Group.prisma().find_first(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GroupWhereInput] = None,
        cursor: Optional[types.GroupWhereUniqueInput] = None,
        include: Optional[types.GroupInclude] = None,
        order: Optional[Union[types.GroupOrderByInput, List[types.GroupOrderByInput]]] = None,
        distinct: Optional[List[types.GroupScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Group record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Group filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Group model
        order
            Order the returned Group records by any field
        distinct
            Filter Group records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Group
            The first Group record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Group record ordered by the id field
        group = await Group.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GroupUpdateInput,
        where: types.GroupWhereUniqueInput,
        include: Optional[types.GroupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Group record.

        Parameters
        ----------
        data
            Group record data specifying what to update
        where
            Group filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Group model

        Returns
        -------
        prisma.models.Group
            The updated Group record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        group = await Group.prisma().update(
            where={
                'id': 744964398,
            },
            data={
                # data to update the Group record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GroupWhereUniqueInput,
        data: types.GroupUpsertInput,
        include: Optional[types.GroupInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Group filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Group model

        Returns
        -------
        prisma.models.Group
            The created or updated Group record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        group = await Group.prisma().upsert(
            where={
                'id': 1969681615,
            },
            data={
                'create': {
                    'id': 1969681615,
                    'name': 'bhghchehcc',
                },
                'update': {
                    'name': 'bhghchehcc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GroupUpdateManyMutationInput,
        where: types.GroupWhereInput,
    ) -> int:
        """Update multiple Group records

        Parameters
        ----------
        data
            Group data to update the selected Group records to
        where
            Filter to select the Group records to update

        Returns
        -------
        int
            The total number of Group records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Group records
        total = await Group.prisma().update_many(
            data={
                'name': 'bbbgbhfjge'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GroupWhereInput] = None,
        cursor: Optional[types.GroupWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Group records present in the database

        Parameters
        ----------
        select
            Select the Group fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Group filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GroupCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Group.prisma().count()

        # results: prisma.types.GroupCountAggregateOutput
        results = await Group.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GroupCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GroupWhereInput] = None,
        cursor: Optional[types.GroupWhereUniqueInput] = None,
    ) -> types.GroupCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GroupCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GroupWhereInput] = None,
        cursor: Optional[types.GroupWhereUniqueInput] = None,
    ) -> Union[int, types.GroupCountAggregateOutput]:
        """Count the number of Group records present in the database

        Parameters
        ----------
        select
            Select the Group fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Group filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GroupCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Group.prisma().count()

        # results: prisma.types.GroupCountAggregateOutput
        results = await Group.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GroupCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GroupWhereInput] = None
    ) -> int:
        """Delete multiple Group records.

        Parameters
        ----------
        where
            Optional Group filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Group records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Group records
        total = await Group.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GroupScalarFieldKeys'],
        *,
        where: Optional['types.GroupWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GroupAvgAggregateInput'] = None,
        sum: Optional['types.GroupSumAggregateInput'] = None,
        min: Optional['types.GroupMinAggregateInput'] = None,
        max: Optional['types.GroupMaxAggregateInput'] = None,
        having: Optional['types.GroupScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GroupCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GroupScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GroupScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GroupGroupByOutput']:
        """Group Group records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Group fields to group records by
        where
            Group filter to select records
        take
            Limit the maximum number of Group records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GroupGroupByOutput]
            A list of dictionaries representing the Group record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Group records by id values
        # and count how many records are in each group
        results = await Group.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PermissionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Permission]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Permission.prisma().query_raw(
            'SELECT * FROM Permission WHERE id = $1',
            861472101,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Permission
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Permission.prisma().query_first(
            'SELECT * FROM Permission WHERE name = $1',
            'bdadaadhag',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PermissionCreateInput,
        include: Optional[types.PermissionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Permission record.

        Parameters
        ----------
        data
            Permission record data
        include
            Specifies which relations should be loaded on the returned Permission model

        Returns
        -------
        prisma.models.Permission
            The created Permission record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Permission record from just the required fields
        permission = await Permission.prisma().create(
            data={
                # data to create a Permission record
                'name': 'bgiggdidbf',
                'codename': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PermissionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Permission records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Permission record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Permission.prisma().create_many(
            data=[
                {
                    # data to create a Permission record
                    'name': 'bigibebcib',
                    'codename': 'bigaiehgcc',
                },
                {
                    # data to create a Permission record
                    'name': 'beeifcbebf',
                    'codename': 'bgcigfahea',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PermissionWhereUniqueInput,
        include: Optional[types.PermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Permission record.

        Parameters
        ----------
        where
            Permission filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Permission model

        Returns
        -------
        prisma.models.Permission
            The deleted Permission record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        permission = await Permission.prisma().delete(
            where={
                'id': 1249606685,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PermissionWhereUniqueInput,
        include: Optional[types.PermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Permission record.

        Parameters
        ----------
        where
            Permission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Permission model

        Returns
        -------
        prisma.models.Permission
            The found Permission record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        permission = await Permission.prisma().find_unique(
            where={
                'id': 835903122,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PermissionWhereUniqueInput,
        include: Optional[types.PermissionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Permission record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Permission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Permission model

        Returns
        -------
        prisma.models.Permission
            The found Permission record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        permission = await Permission.prisma().find_unique_or_raise(
            where={
                'id': 763719779,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PermissionWhereInput] = None,
        cursor: Optional[types.PermissionWhereUniqueInput] = None,
        include: Optional[types.PermissionInclude] = None,
        order: Optional[Union[types.PermissionOrderByInput, List[types.PermissionOrderByInput]]] = None,
        distinct: Optional[List[types.PermissionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Permission records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Permission records returned
        skip
            Ignore the first N results
        where
            Permission filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Permission model
        order
            Order the returned Permission records by any field
        distinct
            Filter Permission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Permission]
            The list of all Permission records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Permission records
        permissions = await Permission.prisma().find_many(take=10)

        # find the first 5 Permission records ordered by the codename field
        permissions = await Permission.prisma().find_many(
            take=5,
            order={
                'codename': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PermissionWhereInput] = None,
        cursor: Optional[types.PermissionWhereUniqueInput] = None,
        include: Optional[types.PermissionInclude] = None,
        order: Optional[Union[types.PermissionOrderByInput, List[types.PermissionOrderByInput]]] = None,
        distinct: Optional[List[types.PermissionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Permission record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Permission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Permission model
        order
            Order the returned Permission records by any field
        distinct
            Filter Permission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Permission
            The first Permission record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Permission record ordered by the createdAt field
        permission = await Permission.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PermissionWhereInput] = None,
        cursor: Optional[types.PermissionWhereUniqueInput] = None,
        include: Optional[types.PermissionInclude] = None,
        order: Optional[Union[types.PermissionOrderByInput, List[types.PermissionOrderByInput]]] = None,
        distinct: Optional[List[types.PermissionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Permission record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Permission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Permission model
        order
            Order the returned Permission records by any field
        distinct
            Filter Permission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Permission
            The first Permission record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Permission record ordered by the updatedAt field
        permission = await Permission.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PermissionUpdateInput,
        where: types.PermissionWhereUniqueInput,
        include: Optional[types.PermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Permission record.

        Parameters
        ----------
        data
            Permission record data specifying what to update
        where
            Permission filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Permission model

        Returns
        -------
        prisma.models.Permission
            The updated Permission record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        permission = await Permission.prisma().update(
            where={
                'id': 429995104,
            },
            data={
                # data to update the Permission record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PermissionWhereUniqueInput,
        data: types.PermissionUpsertInput,
        include: Optional[types.PermissionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Permission filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Permission model

        Returns
        -------
        prisma.models.Permission
            The created or updated Permission record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        permission = await Permission.prisma().upsert(
            where={
                'id': 1775811865,
            },
            data={
                'create': {
                    'id': 1775811865,
                    'name': 'beeifcbebf',
                    'codename': 'bgcigfahea',
                },
                'update': {
                    'name': 'beeifcbebf',
                    'codename': 'bgcigfahea',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PermissionUpdateManyMutationInput,
        where: types.PermissionWhereInput,
    ) -> int:
        """Update multiple Permission records

        Parameters
        ----------
        data
            Permission data to update the selected Permission records to
        where
            Filter to select the Permission records to update

        Returns
        -------
        int
            The total number of Permission records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Permission records
        total = await Permission.prisma().update_many(
            data={
                'id': 893145566
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PermissionWhereInput] = None,
        cursor: Optional[types.PermissionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Permission records present in the database

        Parameters
        ----------
        select
            Select the Permission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Permission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PermissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Permission.prisma().count()

        # results: prisma.types.PermissionCountAggregateOutput
        results = await Permission.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PermissionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PermissionWhereInput] = None,
        cursor: Optional[types.PermissionWhereUniqueInput] = None,
    ) -> types.PermissionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PermissionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PermissionWhereInput] = None,
        cursor: Optional[types.PermissionWhereUniqueInput] = None,
    ) -> Union[int, types.PermissionCountAggregateOutput]:
        """Count the number of Permission records present in the database

        Parameters
        ----------
        select
            Select the Permission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Permission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PermissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Permission.prisma().count()

        # results: prisma.types.PermissionCountAggregateOutput
        results = await Permission.prisma().count(
            select={
                '_all': True,
                'codename': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PermissionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PermissionWhereInput] = None
    ) -> int:
        """Delete multiple Permission records.

        Parameters
        ----------
        where
            Optional Permission filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Permission records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Permission records
        total = await Permission.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PermissionScalarFieldKeys'],
        *,
        where: Optional['types.PermissionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PermissionAvgAggregateInput'] = None,
        sum: Optional['types.PermissionSumAggregateInput'] = None,
        min: Optional['types.PermissionMinAggregateInput'] = None,
        max: Optional['types.PermissionMaxAggregateInput'] = None,
        having: Optional['types.PermissionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PermissionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PermissionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PermissionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PermissionGroupByOutput']:
        """Group Permission records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Permission fields to group records by
        where
            Permission filter to select records
        take
            Limit the maximum number of Permission records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PermissionGroupByOutput]
            A list of dictionaries representing the Permission record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Permission records by createdAt values
        # and count how many records are in each group
        results = await Permission.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserGroupActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserGroup]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserGroup.prisma().query_raw(
            'SELECT * FROM UserGroup WHERE id = $1',
            995405759,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserGroup
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserGroup.prisma().query_first(
            'SELECT * FROM UserGroup WHERE userId = $1',
            2102736524,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserGroupCreateInput,
        include: Optional[types.UserGroupInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserGroup record.

        Parameters
        ----------
        data
            UserGroup record data
        include
            Specifies which relations should be loaded on the returned UserGroup model

        Returns
        -------
        prisma.models.UserGroup
            The created UserGroup record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserGroup record from just the required fields
        usergroup = await UserGroup.prisma().create(
            data={
                # data to create a UserGroup record
                'userId': 271520213,
                'groupId': 456633834,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserGroupCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserGroup records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserGroup record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserGroup.prisma().create_many(
            data=[
                {
                    # data to create a UserGroup record
                    'userId': 2058258651,
                    'groupId': 1583689592,
                },
                {
                    # data to create a UserGroup record
                    'userId': 878442065,
                    'groupId': 1675280054,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserGroupWhereUniqueInput,
        include: Optional[types.UserGroupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserGroup record.

        Parameters
        ----------
        where
            UserGroup filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserGroup model

        Returns
        -------
        prisma.models.UserGroup
            The deleted UserGroup record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usergroup = await UserGroup.prisma().delete(
            where={
                'id': 1627576247,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserGroupWhereUniqueInput,
        include: Optional[types.UserGroupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserGroup record.

        Parameters
        ----------
        where
            UserGroup filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserGroup model

        Returns
        -------
        prisma.models.UserGroup
            The found UserGroup record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usergroup = await UserGroup.prisma().find_unique(
            where={
                'id': 2054802212,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserGroupWhereUniqueInput,
        include: Optional[types.UserGroupInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserGroup record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserGroup filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserGroup model

        Returns
        -------
        prisma.models.UserGroup
            The found UserGroup record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usergroup = await UserGroup.prisma().find_unique_or_raise(
            where={
                'id': 60335757,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserGroupWhereInput] = None,
        cursor: Optional[types.UserGroupWhereUniqueInput] = None,
        include: Optional[types.UserGroupInclude] = None,
        order: Optional[Union[types.UserGroupOrderByInput, List[types.UserGroupOrderByInput]]] = None,
        distinct: Optional[List[types.UserGroupScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserGroup records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserGroup records returned
        skip
            Ignore the first N results
        where
            UserGroup filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserGroup model
        order
            Order the returned UserGroup records by any field
        distinct
            Filter UserGroup records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserGroup]
            The list of all UserGroup records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserGroup records
        usergroups = await UserGroup.prisma().find_many(take=10)

        # find the first 5 UserGroup records ordered by the groupId field
        usergroups = await UserGroup.prisma().find_many(
            take=5,
            order={
                'groupId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserGroupWhereInput] = None,
        cursor: Optional[types.UserGroupWhereUniqueInput] = None,
        include: Optional[types.UserGroupInclude] = None,
        order: Optional[Union[types.UserGroupOrderByInput, List[types.UserGroupOrderByInput]]] = None,
        distinct: Optional[List[types.UserGroupScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserGroup record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserGroup filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserGroup model
        order
            Order the returned UserGroup records by any field
        distinct
            Filter UserGroup records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserGroup
            The first UserGroup record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserGroup record ordered by the createdAt field
        usergroup = await UserGroup.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserGroupWhereInput] = None,
        cursor: Optional[types.UserGroupWhereUniqueInput] = None,
        include: Optional[types.UserGroupInclude] = None,
        order: Optional[Union[types.UserGroupOrderByInput, List[types.UserGroupOrderByInput]]] = None,
        distinct: Optional[List[types.UserGroupScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserGroup record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserGroup filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserGroup model
        order
            Order the returned UserGroup records by any field
        distinct
            Filter UserGroup records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserGroup
            The first UserGroup record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserGroup record ordered by the id field
        usergroup = await UserGroup.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserGroupUpdateInput,
        where: types.UserGroupWhereUniqueInput,
        include: Optional[types.UserGroupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserGroup record.

        Parameters
        ----------
        data
            UserGroup record data specifying what to update
        where
            UserGroup filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserGroup model

        Returns
        -------
        prisma.models.UserGroup
            The updated UserGroup record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usergroup = await UserGroup.prisma().update(
            where={
                'id': 684462146,
            },
            data={
                # data to update the UserGroup record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserGroupWhereUniqueInput,
        data: types.UserGroupUpsertInput,
        include: Optional[types.UserGroupInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserGroup filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserGroup model

        Returns
        -------
        prisma.models.UserGroup
            The created or updated UserGroup record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usergroup = await UserGroup.prisma().upsert(
            where={
                'id': 1625503827,
            },
            data={
                'create': {
                    'id': 1625503827,
                    'userId': 878442065,
                    'groupId': 1675280054,
                },
                'update': {
                    'userId': 878442065,
                    'groupId': 1675280054,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserGroupUpdateManyMutationInput,
        where: types.UserGroupWhereInput,
    ) -> int:
        """Update multiple UserGroup records

        Parameters
        ----------
        data
            UserGroup data to update the selected UserGroup records to
        where
            Filter to select the UserGroup records to update

        Returns
        -------
        int
            The total number of UserGroup records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserGroup records
        total = await UserGroup.prisma().update_many(
            data={
                'userId': 521827728
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserGroupWhereInput] = None,
        cursor: Optional[types.UserGroupWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserGroup records present in the database

        Parameters
        ----------
        select
            Select the UserGroup fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserGroup filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserGroupCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserGroup.prisma().count()

        # results: prisma.types.UserGroupCountAggregateOutput
        results = await UserGroup.prisma().count(
            select={
                '_all': True,
                'groupId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserGroupCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserGroupWhereInput] = None,
        cursor: Optional[types.UserGroupWhereUniqueInput] = None,
    ) -> types.UserGroupCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserGroupCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserGroupWhereInput] = None,
        cursor: Optional[types.UserGroupWhereUniqueInput] = None,
    ) -> Union[int, types.UserGroupCountAggregateOutput]:
        """Count the number of UserGroup records present in the database

        Parameters
        ----------
        select
            Select the UserGroup fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserGroup filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserGroupCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserGroup.prisma().count()

        # results: prisma.types.UserGroupCountAggregateOutput
        results = await UserGroup.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserGroupCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserGroupWhereInput] = None
    ) -> int:
        """Delete multiple UserGroup records.

        Parameters
        ----------
        where
            Optional UserGroup filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserGroup records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserGroup records
        total = await UserGroup.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserGroupScalarFieldKeys'],
        *,
        where: Optional['types.UserGroupWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserGroupAvgAggregateInput'] = None,
        sum: Optional['types.UserGroupSumAggregateInput'] = None,
        min: Optional['types.UserGroupMinAggregateInput'] = None,
        max: Optional['types.UserGroupMaxAggregateInput'] = None,
        having: Optional['types.UserGroupScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserGroupCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserGroupScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserGroupScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupGroupByOutput']:
        """Group UserGroup records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserGroup fields to group records by
        where
            UserGroup filter to select records
        take
            Limit the maximum number of UserGroup records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupGroupByOutput]
            A list of dictionaries representing the UserGroup record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserGroup records by id values
        # and count how many records are in each group
        results = await UserGroup.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserPermissionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserPermission]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserPermission.prisma().query_raw(
            'SELECT * FROM UserPermission WHERE id = $1',
            1266032265,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserPermission
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserPermission.prisma().query_first(
            'SELECT * FROM UserPermission WHERE userId = $1',
            93253262,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserPermissionCreateInput,
        include: Optional[types.UserPermissionInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserPermission record.

        Parameters
        ----------
        data
            UserPermission record data
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The created UserPermission record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserPermission record from just the required fields
        userpermission = await UserPermission.prisma().create(
            data={
                # data to create a UserPermission record
                'userId': 2053047983,
                'permissionId': 685333180,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserPermissionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserPermission records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserPermission record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserPermission.prisma().create_many(
            data=[
                {
                    # data to create a UserPermission record
                    'userId': 127474245,
                    'permissionId': 948921754,
                },
                {
                    # data to create a UserPermission record
                    'userId': 1964990155,
                    'permissionId': 1228891816,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserPermissionWhereUniqueInput,
        include: Optional[types.UserPermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserPermission record.

        Parameters
        ----------
        where
            UserPermission filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The deleted UserPermission record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpermission = await UserPermission.prisma().delete(
            where={
                'id': 255202753,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserPermissionWhereUniqueInput,
        include: Optional[types.UserPermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserPermission record.

        Parameters
        ----------
        where
            UserPermission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The found UserPermission record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpermission = await UserPermission.prisma().find_unique(
            where={
                'id': 1223573862,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserPermissionWhereUniqueInput,
        include: Optional[types.UserPermissionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserPermission record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserPermission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The found UserPermission record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpermission = await UserPermission.prisma().find_unique_or_raise(
            where={
                'id': 541269159,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
        include: Optional[types.UserPermissionInclude] = None,
        order: Optional[Union[types.UserPermissionOrderByInput, List[types.UserPermissionOrderByInput]]] = None,
        distinct: Optional[List[types.UserPermissionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserPermission records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserPermission records returned
        skip
            Ignore the first N results
        where
            UserPermission filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPermission model
        order
            Order the returned UserPermission records by any field
        distinct
            Filter UserPermission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserPermission]
            The list of all UserPermission records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserPermission records
        userpermissions = await UserPermission.prisma().find_many(take=10)

        # find the first 5 UserPermission records ordered by the permissionId field
        userpermissions = await UserPermission.prisma().find_many(
            take=5,
            order={
                'permissionId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
        include: Optional[types.UserPermissionInclude] = None,
        order: Optional[Union[types.UserPermissionOrderByInput, List[types.UserPermissionOrderByInput]]] = None,
        distinct: Optional[List[types.UserPermissionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserPermission record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserPermission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPermission model
        order
            Order the returned UserPermission records by any field
        distinct
            Filter UserPermission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserPermission
            The first UserPermission record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserPermission record ordered by the createdAt field
        userpermission = await UserPermission.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
        include: Optional[types.UserPermissionInclude] = None,
        order: Optional[Union[types.UserPermissionOrderByInput, List[types.UserPermissionOrderByInput]]] = None,
        distinct: Optional[List[types.UserPermissionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserPermission record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserPermission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPermission model
        order
            Order the returned UserPermission records by any field
        distinct
            Filter UserPermission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserPermission
            The first UserPermission record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserPermission record ordered by the id field
        userpermission = await UserPermission.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserPermissionUpdateInput,
        where: types.UserPermissionWhereUniqueInput,
        include: Optional[types.UserPermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserPermission record.

        Parameters
        ----------
        data
            UserPermission record data specifying what to update
        where
            UserPermission filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The updated UserPermission record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userpermission = await UserPermission.prisma().update(
            where={
                'id': 1064846676,
            },
            data={
                # data to update the UserPermission record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserPermissionWhereUniqueInput,
        data: types.UserPermissionUpsertInput,
        include: Optional[types.UserPermissionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserPermission filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The created or updated UserPermission record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpermission = await UserPermission.prisma().upsert(
            where={
                'id': 508382461,
            },
            data={
                'create': {
                    'id': 508382461,
                    'userId': 1964990155,
                    'permissionId': 1228891816,
                },
                'update': {
                    'userId': 1964990155,
                    'permissionId': 1228891816,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserPermissionUpdateManyMutationInput,
        where: types.UserPermissionWhereInput,
    ) -> int:
        """Update multiple UserPermission records

        Parameters
        ----------
        data
            UserPermission data to update the selected UserPermission records to
        where
            Filter to select the UserPermission records to update

        Returns
        -------
        int
            The total number of UserPermission records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserPermission records
        total = await UserPermission.prisma().update_many(
            data={
                'userId': 1024265714
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserPermission records present in the database

        Parameters
        ----------
        select
            Select the UserPermission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserPermission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserPermissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserPermission.prisma().count()

        # results: prisma.types.UserPermissionCountAggregateOutput
        results = await UserPermission.prisma().count(
            select={
                '_all': True,
                'permissionId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserPermissionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
    ) -> types.UserPermissionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserPermissionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
    ) -> Union[int, types.UserPermissionCountAggregateOutput]:
        """Count the number of UserPermission records present in the database

        Parameters
        ----------
        select
            Select the UserPermission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserPermission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserPermissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserPermission.prisma().count()

        # results: prisma.types.UserPermissionCountAggregateOutput
        results = await UserPermission.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserPermissionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserPermissionWhereInput] = None
    ) -> int:
        """Delete multiple UserPermission records.

        Parameters
        ----------
        where
            Optional UserPermission filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserPermission records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserPermission records
        total = await UserPermission.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserPermissionScalarFieldKeys'],
        *,
        where: Optional['types.UserPermissionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserPermissionAvgAggregateInput'] = None,
        sum: Optional['types.UserPermissionSumAggregateInput'] = None,
        min: Optional['types.UserPermissionMinAggregateInput'] = None,
        max: Optional['types.UserPermissionMaxAggregateInput'] = None,
        having: Optional['types.UserPermissionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserPermissionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserPermissionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserPermissionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserPermissionGroupByOutput']:
        """Group UserPermission records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserPermission fields to group records by
        where
            UserPermission filter to select records
        take
            Limit the maximum number of UserPermission records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserPermissionGroupByOutput]
            A list of dictionaries representing the UserPermission record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserPermission records by id values
        # and count how many records are in each group
        results = await UserPermission.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GroupPermissionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.GroupPermission]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await GroupPermission.prisma().query_raw(
            'SELECT * FROM GroupPermission WHERE id = $1',
            872078403,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.GroupPermission
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await GroupPermission.prisma().query_first(
            'SELECT * FROM GroupPermission WHERE groupId = $1',
            1874748096,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GroupPermissionCreateInput,
        include: Optional[types.GroupPermissionInclude] = None
    ) -> _PrismaModelT:
        """Create a new GroupPermission record.

        Parameters
        ----------
        data
            GroupPermission record data
        include
            Specifies which relations should be loaded on the returned GroupPermission model

        Returns
        -------
        prisma.models.GroupPermission
            The created GroupPermission record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a GroupPermission record from just the required fields
        grouppermission = await GroupPermission.prisma().create(
            data={
                # data to create a GroupPermission record
                'groupId': 916896761,
                'permissionId': 769267518,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GroupPermissionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple GroupPermission records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of GroupPermission record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await GroupPermission.prisma().create_many(
            data=[
                {
                    # data to create a GroupPermission record
                    'groupId': 820312479,
                    'permissionId': 92728044,
                },
                {
                    # data to create a GroupPermission record
                    'groupId': 344858293,
                    'permissionId': 1121741130,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GroupPermissionWhereUniqueInput,
        include: Optional[types.GroupPermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single GroupPermission record.

        Parameters
        ----------
        where
            GroupPermission filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned GroupPermission model

        Returns
        -------
        prisma.models.GroupPermission
            The deleted GroupPermission record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        grouppermission = await GroupPermission.prisma().delete(
            where={
                'id': 1495896251,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GroupPermissionWhereUniqueInput,
        include: Optional[types.GroupPermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique GroupPermission record.

        Parameters
        ----------
        where
            GroupPermission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GroupPermission model

        Returns
        -------
        prisma.models.GroupPermission
            The found GroupPermission record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        grouppermission = await GroupPermission.prisma().find_unique(
            where={
                'id': 208521688,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GroupPermissionWhereUniqueInput,
        include: Optional[types.GroupPermissionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique GroupPermission record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            GroupPermission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GroupPermission model

        Returns
        -------
        prisma.models.GroupPermission
            The found GroupPermission record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        grouppermission = await GroupPermission.prisma().find_unique_or_raise(
            where={
                'id': 860811569,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GroupPermissionWhereInput] = None,
        cursor: Optional[types.GroupPermissionWhereUniqueInput] = None,
        include: Optional[types.GroupPermissionInclude] = None,
        order: Optional[Union[types.GroupPermissionOrderByInput, List[types.GroupPermissionOrderByInput]]] = None,
        distinct: Optional[List[types.GroupPermissionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple GroupPermission records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of GroupPermission records returned
        skip
            Ignore the first N results
        where
            GroupPermission filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GroupPermission model
        order
            Order the returned GroupPermission records by any field
        distinct
            Filter GroupPermission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.GroupPermission]
            The list of all GroupPermission records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 GroupPermission records
        grouppermissions = await GroupPermission.prisma().find_many(take=10)

        # find the first 5 GroupPermission records ordered by the permissionId field
        grouppermissions = await GroupPermission.prisma().find_many(
            take=5,
            order={
                'permissionId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GroupPermissionWhereInput] = None,
        cursor: Optional[types.GroupPermissionWhereUniqueInput] = None,
        include: Optional[types.GroupPermissionInclude] = None,
        order: Optional[Union[types.GroupPermissionOrderByInput, List[types.GroupPermissionOrderByInput]]] = None,
        distinct: Optional[List[types.GroupPermissionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single GroupPermission record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GroupPermission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GroupPermission model
        order
            Order the returned GroupPermission records by any field
        distinct
            Filter GroupPermission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GroupPermission
            The first GroupPermission record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GroupPermission record ordered by the createdAt field
        grouppermission = await GroupPermission.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GroupPermissionWhereInput] = None,
        cursor: Optional[types.GroupPermissionWhereUniqueInput] = None,
        include: Optional[types.GroupPermissionInclude] = None,
        order: Optional[Union[types.GroupPermissionOrderByInput, List[types.GroupPermissionOrderByInput]]] = None,
        distinct: Optional[List[types.GroupPermissionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single GroupPermission record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GroupPermission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GroupPermission model
        order
            Order the returned GroupPermission records by any field
        distinct
            Filter GroupPermission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GroupPermission
            The first GroupPermission record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GroupPermission record ordered by the id field
        grouppermission = await GroupPermission.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GroupPermissionUpdateInput,
        where: types.GroupPermissionWhereUniqueInput,
        include: Optional[types.GroupPermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single GroupPermission record.

        Parameters
        ----------
        data
            GroupPermission record data specifying what to update
        where
            GroupPermission filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned GroupPermission model

        Returns
        -------
        prisma.models.GroupPermission
            The updated GroupPermission record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        grouppermission = await GroupPermission.prisma().update(
            where={
                'id': 1660932118,
            },
            data={
                # data to update the GroupPermission record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GroupPermissionWhereUniqueInput,
        data: types.GroupPermissionUpsertInput,
        include: Optional[types.GroupPermissionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            GroupPermission filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned GroupPermission model

        Returns
        -------
        prisma.models.GroupPermission
            The created or updated GroupPermission record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        grouppermission = await GroupPermission.prisma().upsert(
            where={
                'id': 525761943,
            },
            data={
                'create': {
                    'id': 525761943,
                    'groupId': 344858293,
                    'permissionId': 1121741130,
                },
                'update': {
                    'groupId': 344858293,
                    'permissionId': 1121741130,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GroupPermissionUpdateManyMutationInput,
        where: types.GroupPermissionWhereInput,
    ) -> int:
        """Update multiple GroupPermission records

        Parameters
        ----------
        data
            GroupPermission data to update the selected GroupPermission records to
        where
            Filter to select the GroupPermission records to update

        Returns
        -------
        int
            The total number of GroupPermission records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all GroupPermission records
        total = await GroupPermission.prisma().update_many(
            data={
                'groupId': 736209796
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GroupPermissionWhereInput] = None,
        cursor: Optional[types.GroupPermissionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of GroupPermission records present in the database

        Parameters
        ----------
        select
            Select the GroupPermission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GroupPermission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GroupPermissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GroupPermission.prisma().count()

        # results: prisma.types.GroupPermissionCountAggregateOutput
        results = await GroupPermission.prisma().count(
            select={
                '_all': True,
                'permissionId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GroupPermissionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GroupPermissionWhereInput] = None,
        cursor: Optional[types.GroupPermissionWhereUniqueInput] = None,
    ) -> types.GroupPermissionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GroupPermissionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GroupPermissionWhereInput] = None,
        cursor: Optional[types.GroupPermissionWhereUniqueInput] = None,
    ) -> Union[int, types.GroupPermissionCountAggregateOutput]:
        """Count the number of GroupPermission records present in the database

        Parameters
        ----------
        select
            Select the GroupPermission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GroupPermission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GroupPermissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GroupPermission.prisma().count()

        # results: prisma.types.GroupPermissionCountAggregateOutput
        results = await GroupPermission.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GroupPermissionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GroupPermissionWhereInput] = None
    ) -> int:
        """Delete multiple GroupPermission records.

        Parameters
        ----------
        where
            Optional GroupPermission filter to find the records to be deleted

        Returns
        -------
        int
            The total number of GroupPermission records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all GroupPermission records
        total = await GroupPermission.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GroupPermissionScalarFieldKeys'],
        *,
        where: Optional['types.GroupPermissionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GroupPermissionAvgAggregateInput'] = None,
        sum: Optional['types.GroupPermissionSumAggregateInput'] = None,
        min: Optional['types.GroupPermissionMinAggregateInput'] = None,
        max: Optional['types.GroupPermissionMaxAggregateInput'] = None,
        having: Optional['types.GroupPermissionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GroupPermissionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GroupPermissionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GroupPermissionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GroupPermissionGroupByOutput']:
        """Group GroupPermission records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar GroupPermission fields to group records by
        where
            GroupPermission filter to select records
        take
            Limit the maximum number of GroupPermission records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GroupPermissionGroupByOutput]
            A list of dictionaries representing the GroupPermission record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group GroupPermission records by id values
        # and count how many records are in each group
        results = await GroupPermission.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Token]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Token.prisma().query_raw(
            'SELECT * FROM Token WHERE id = $1',
            493907821,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Token
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Token.prisma().query_first(
            'SELECT * FROM Token WHERE userId = $1',
            639686562,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TokenCreateInput,
        include: Optional[types.TokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new Token record.

        Parameters
        ----------
        data
            Token record data
        include
            Specifies which relations should be loaded on the returned Token model

        Returns
        -------
        prisma.models.Token
            The created Token record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Token record from just the required fields
        token = await Token.prisma().create(
            data={
                # data to create a Token record
                'userId': 654007347,
                'token': 'bjafcgbffc',
                'expiresAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Token records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Token record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Token.prisma().create_many(
            data=[
                {
                    # data to create a Token record
                    'userId': 78746985,
                    'token': 'bdjidcidac',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Token record
                    'userId': 856000655,
                    'token': 'befcddgjce',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TokenWhereUniqueInput,
        include: Optional[types.TokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Token record.

        Parameters
        ----------
        where
            Token filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Token model

        Returns
        -------
        prisma.models.Token
            The deleted Token record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token = await Token.prisma().delete(
            where={
                'id': 1573199653,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TokenWhereUniqueInput,
        include: Optional[types.TokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Token record.

        Parameters
        ----------
        where
            Token filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Token model

        Returns
        -------
        prisma.models.Token
            The found Token record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token = await Token.prisma().find_unique(
            where={
                'id': 2013903098,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TokenWhereUniqueInput,
        include: Optional[types.TokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Token record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Token filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Token model

        Returns
        -------
        prisma.models.Token
            The found Token record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token = await Token.prisma().find_unique_or_raise(
            where={
                'id': 500965035,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TokenWhereInput] = None,
        cursor: Optional[types.TokenWhereUniqueInput] = None,
        include: Optional[types.TokenInclude] = None,
        order: Optional[Union[types.TokenOrderByInput, List[types.TokenOrderByInput]]] = None,
        distinct: Optional[List[types.TokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Token records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Token records returned
        skip
            Ignore the first N results
        where
            Token filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Token model
        order
            Order the returned Token records by any field
        distinct
            Filter Token records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Token]
            The list of all Token records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Token records
        tokens = await Token.prisma().find_many(take=10)

        # find the first 5 Token records ordered by the token field
        tokens = await Token.prisma().find_many(
            take=5,
            order={
                'token': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TokenWhereInput] = None,
        cursor: Optional[types.TokenWhereUniqueInput] = None,
        include: Optional[types.TokenInclude] = None,
        order: Optional[Union[types.TokenOrderByInput, List[types.TokenOrderByInput]]] = None,
        distinct: Optional[List[types.TokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Token record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Token filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Token model
        order
            Order the returned Token records by any field
        distinct
            Filter Token records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Token
            The first Token record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Token record ordered by the createdAt field
        token = await Token.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TokenWhereInput] = None,
        cursor: Optional[types.TokenWhereUniqueInput] = None,
        include: Optional[types.TokenInclude] = None,
        order: Optional[Union[types.TokenOrderByInput, List[types.TokenOrderByInput]]] = None,
        distinct: Optional[List[types.TokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Token record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Token filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Token model
        order
            Order the returned Token records by any field
        distinct
            Filter Token records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Token
            The first Token record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Token record ordered by the expiresAt field
        token = await Token.prisma().find_first_or_raise(
            skip=1,
            order={
                'expiresAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TokenUpdateInput,
        where: types.TokenWhereUniqueInput,
        include: Optional[types.TokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Token record.

        Parameters
        ----------
        data
            Token record data specifying what to update
        where
            Token filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Token model

        Returns
        -------
        prisma.models.Token
            The updated Token record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        token = await Token.prisma().update(
            where={
                'id': 1800624392,
            },
            data={
                # data to update the Token record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TokenWhereUniqueInput,
        data: types.TokenUpsertInput,
        include: Optional[types.TokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Token filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Token model

        Returns
        -------
        prisma.models.Token
            The created or updated Token record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token = await Token.prisma().upsert(
            where={
                'id': 2077067425,
            },
            data={
                'create': {
                    'id': 2077067425,
                    'userId': 856000655,
                    'token': 'befcddgjce',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 856000655,
                    'token': 'befcddgjce',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TokenUpdateManyMutationInput,
        where: types.TokenWhereInput,
    ) -> int:
        """Update multiple Token records

        Parameters
        ----------
        data
            Token data to update the selected Token records to
        where
            Filter to select the Token records to update

        Returns
        -------
        int
            The total number of Token records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Token records
        total = await Token.prisma().update_many(
            data={
                'id': 1672112838
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TokenWhereInput] = None,
        cursor: Optional[types.TokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Token records present in the database

        Parameters
        ----------
        select
            Select the Token fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Token filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Token.prisma().count()

        # results: prisma.types.TokenCountAggregateOutput
        results = await Token.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TokenWhereInput] = None,
        cursor: Optional[types.TokenWhereUniqueInput] = None,
    ) -> types.TokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TokenWhereInput] = None,
        cursor: Optional[types.TokenWhereUniqueInput] = None,
    ) -> Union[int, types.TokenCountAggregateOutput]:
        """Count the number of Token records present in the database

        Parameters
        ----------
        select
            Select the Token fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Token filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Token.prisma().count()

        # results: prisma.types.TokenCountAggregateOutput
        results = await Token.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TokenWhereInput] = None
    ) -> int:
        """Delete multiple Token records.

        Parameters
        ----------
        where
            Optional Token filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Token records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Token records
        total = await Token.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TokenScalarFieldKeys'],
        *,
        where: Optional['types.TokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TokenAvgAggregateInput'] = None,
        sum: Optional['types.TokenSumAggregateInput'] = None,
        min: Optional['types.TokenMinAggregateInput'] = None,
        max: Optional['types.TokenMaxAggregateInput'] = None,
        having: Optional['types.TokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TokenGroupByOutput']:
        """Group Token records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Token fields to group records by
        where
            Token filter to select records
        take
            Limit the maximum number of Token records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TokenGroupByOutput]
            A list of dictionaries representing the Token record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Token records by createdAt values
        # and count how many records are in each group
        results = await Token.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Session]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Session.prisma().query_raw(
            'SELECT * FROM Session WHERE id = $1',
            926677639,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Session
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Session.prisma().query_first(
            'SELECT * FROM Session WHERE userId = $1',
            1447624116,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SessionCreateInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Session record.

        Parameters
        ----------
        data
            Session record data
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created Session record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Session record from just the required fields
        session = await Session.prisma().create(
            data={
                # data to create a Session record
                'userId': 1738083805,
                'sessionKey': 'deajegcfi',
                'expiresAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Session records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Session record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Session.prisma().create_many(
            data=[
                {
                    # data to create a Session record
                    'userId': 601077795,
                    'sessionKey': 'cjagadcjg',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Session record
                    'userId': 1855826649,
                    'sessionKey': 'bgbbaajbic',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Session record.

        Parameters
        ----------
        where
            Session filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The deleted Session record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().delete(
            where={
                'id': 446673791,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Session record.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique(
            where={
                'id': 300568396,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Session record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique_or_raise(
            where={
                'id': 632626069,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Session records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N results
        where
            Session filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Session]
            The list of all Session records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Session records
        sessions = await Session.prisma().find_many(take=10)

        # find the first 5 Session records ordered by the sessionKey field
        sessions = await Session.prisma().find_many(
            take=5,
            order={
                'sessionKey': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Session record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the createdAt field
        session = await Session.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Session record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the expiresAt field
        session = await Session.prisma().find_first_or_raise(
            skip=1,
            order={
                'expiresAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SessionUpdateInput,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Session record.

        Parameters
        ----------
        data
            Session record data specifying what to update
        where
            Session filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The updated Session record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        session = await Session.prisma().update(
            where={
                'id': 1724011690,
            },
            data={
                # data to update the Session record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SessionWhereUniqueInput,
        data: types.SessionUpsertInput,
        include: Optional[types.SessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Session filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created or updated Session record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().upsert(
            where={
                'id': 470157467,
            },
            data={
                'create': {
                    'id': 470157467,
                    'userId': 1855826649,
                    'sessionKey': 'bgbbaajbic',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 1855826649,
                    'sessionKey': 'bgbbaajbic',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SessionUpdateManyMutationInput,
        where: types.SessionWhereInput,
    ) -> int:
        """Update multiple Session records

        Parameters
        ----------
        data
            Session data to update the selected Session records to
        where
            Filter to select the Session records to update

        Returns
        -------
        int
            The total number of Session records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Session records
        total = await Session.prisma().update_many(
            data={
                'id': 1209209912
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> types.SessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> Union[int, types.SessionCountAggregateOutput]:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'sessionKey': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SessionWhereInput] = None
    ) -> int:
        """Delete multiple Session records.

        Parameters
        ----------
        where
            Optional Session filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Session records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Session records
        total = await Session.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SessionScalarFieldKeys'],
        *,
        where: Optional['types.SessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SessionAvgAggregateInput'] = None,
        sum: Optional['types.SessionSumAggregateInput'] = None,
        min: Optional['types.SessionMinAggregateInput'] = None,
        max: Optional['types.SessionMaxAggregateInput'] = None,
        having: Optional['types.SessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SessionGroupByOutput']:
        """Group Session records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Session fields to group records by
        where
            Session filter to select records
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SessionGroupByOutput]
            A list of dictionaries representing the Session record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Session records by createdAt values
        # and count how many records are in each group
        results = await Session.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GenreActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Genre]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Genre.prisma().query_raw(
            'SELECT * FROM Genre WHERE name = $1',
            'bfdgheeegf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Genre
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Genre.prisma().query_first(
            'SELECT * FROM Genre WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GenreCreateInput,
        include: Optional[types.GenreInclude] = None
    ) -> _PrismaModelT:
        """Create a new Genre record.

        Parameters
        ----------
        data
            Genre record data
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The created Genre record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Genre record from just the required fields
        genre = await Genre.prisma().create(
            data={
                # data to create a Genre record
                'name': 'ececbijji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GenreCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Genre records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Genre record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Genre.prisma().create_many(
            data=[
                {
                    # data to create a Genre record
                    'name': 'cbcfgdcdhf',
                },
                {
                    # data to create a Genre record
                    'name': 'fdgjfbhia',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Genre record.

        Parameters
        ----------
        where
            Genre filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The deleted Genre record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().delete(
            where={
                'id': 924723277,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Genre record.

        Parameters
        ----------
        where
            Genre filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The found Genre record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().find_unique(
            where={
                'id': 1621937922,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Genre record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Genre filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The found Genre record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().find_unique_or_raise(
            where={
                'id': 1848832019,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
        include: Optional[types.GenreInclude] = None,
        order: Optional[Union[types.GenreOrderByInput, List[types.GenreOrderByInput]]] = None,
        distinct: Optional[List[types.GenreScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Genre records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Genre records returned
        skip
            Ignore the first N results
        where
            Genre filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Genre model
        order
            Order the returned Genre records by any field
        distinct
            Filter Genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Genre]
            The list of all Genre records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Genre records
        genres = await Genre.prisma().find_many(take=10)

        # find the first 5 Genre records ordered by the updatedAt field
        genres = await Genre.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
        include: Optional[types.GenreInclude] = None,
        order: Optional[Union[types.GenreOrderByInput, List[types.GenreOrderByInput]]] = None,
        distinct: Optional[List[types.GenreScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Genre record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Genre filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Genre model
        order
            Order the returned Genre records by any field
        distinct
            Filter Genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Genre
            The first Genre record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Genre record ordered by the id field
        genre = await Genre.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
        include: Optional[types.GenreInclude] = None,
        order: Optional[Union[types.GenreOrderByInput, List[types.GenreOrderByInput]]] = None,
        distinct: Optional[List[types.GenreScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Genre record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Genre filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Genre model
        order
            Order the returned Genre records by any field
        distinct
            Filter Genre records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Genre
            The first Genre record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Genre record ordered by the parentId field
        genre = await Genre.prisma().find_first_or_raise(
            skip=1,
            order={
                'parentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GenreUpdateInput,
        where: types.GenreWhereUniqueInput,
        include: Optional[types.GenreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Genre record.

        Parameters
        ----------
        data
            Genre record data specifying what to update
        where
            Genre filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The updated Genre record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        genre = await Genre.prisma().update(
            where={
                'id': 1921528400,
            },
            data={
                # data to update the Genre record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GenreWhereUniqueInput,
        data: types.GenreUpsertInput,
        include: Optional[types.GenreInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Genre filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Genre model

        Returns
        -------
        prisma.models.Genre
            The created or updated Genre record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        genre = await Genre.prisma().upsert(
            where={
                'id': 2100427849,
            },
            data={
                'create': {
                    'id': 2100427849,
                    'name': 'fdgjfbhia',
                },
                'update': {
                    'name': 'fdgjfbhia',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GenreUpdateManyMutationInput,
        where: types.GenreWhereInput,
    ) -> int:
        """Update multiple Genre records

        Parameters
        ----------
        data
            Genre data to update the selected Genre records to
        where
            Filter to select the Genre records to update

        Returns
        -------
        int
            The total number of Genre records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Genre records
        total = await Genre.prisma().update_many(
            data={
                'name': 'iejbeaaeg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Genre records present in the database

        Parameters
        ----------
        select
            Select the Genre fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Genre filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GenreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Genre.prisma().count()

        # results: prisma.types.GenreCountAggregateOutput
        results = await Genre.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GenreCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
    ) -> types.GenreCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GenreCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GenreWhereInput] = None,
        cursor: Optional[types.GenreWhereUniqueInput] = None,
    ) -> Union[int, types.GenreCountAggregateOutput]:
        """Count the number of Genre records present in the database

        Parameters
        ----------
        select
            Select the Genre fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Genre filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GenreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Genre.prisma().count()

        # results: prisma.types.GenreCountAggregateOutput
        results = await Genre.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GenreCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GenreWhereInput] = None
    ) -> int:
        """Delete multiple Genre records.

        Parameters
        ----------
        where
            Optional Genre filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Genre records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Genre records
        total = await Genre.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GenreScalarFieldKeys'],
        *,
        where: Optional['types.GenreWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GenreAvgAggregateInput'] = None,
        sum: Optional['types.GenreSumAggregateInput'] = None,
        min: Optional['types.GenreMinAggregateInput'] = None,
        max: Optional['types.GenreMaxAggregateInput'] = None,
        having: Optional['types.GenreScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GenreCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GenreScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GenreScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GenreGroupByOutput']:
        """Group Genre records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Genre fields to group records by
        where
            Genre filter to select records
        take
            Limit the maximum number of Genre records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GenreGroupByOutput]
            A list of dictionaries representing the Genre record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Genre records by id values
        # and count how many records are in each group
        results = await Genre.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AgeCategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AgeCategory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AgeCategory.prisma().query_raw(
            'SELECT * FROM AgeCategory WHERE id = $1',
            928152175,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AgeCategory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AgeCategory.prisma().query_first(
            'SELECT * FROM AgeCategory WHERE name = $1',
            'chdadcaga',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AgeCategoryCreateInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new AgeCategory record.

        Parameters
        ----------
        data
            AgeCategory record data
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The created AgeCategory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AgeCategory record from just the required fields
        agecategory = await AgeCategory.prisma().create(
            data={
                # data to create a AgeCategory record
                'name': 'jicieifbh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AgeCategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AgeCategory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AgeCategory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AgeCategory.prisma().create_many(
            data=[
                {
                    # data to create a AgeCategory record
                    'name': 'fbahdheji',
                },
                {
                    # data to create a AgeCategory record
                    'name': 'cbbheiicgh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AgeCategory record.

        Parameters
        ----------
        where
            AgeCategory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The deleted AgeCategory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().delete(
            where={
                'id': 1401944936,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AgeCategory record.

        Parameters
        ----------
        where
            AgeCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The found AgeCategory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().find_unique(
            where={
                'id': 1297607553,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AgeCategory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AgeCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The found AgeCategory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().find_unique_or_raise(
            where={
                'id': 519488550,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
        include: Optional[types.AgeCategoryInclude] = None,
        order: Optional[Union[types.AgeCategoryOrderByInput, List[types.AgeCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.AgeCategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AgeCategory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AgeCategory records returned
        skip
            Ignore the first N results
        where
            AgeCategory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgeCategory model
        order
            Order the returned AgeCategory records by any field
        distinct
            Filter AgeCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AgeCategory]
            The list of all AgeCategory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AgeCategory records
        agecategorys = await AgeCategory.prisma().find_many(take=10)

        # find the first 5 AgeCategory records ordered by the id field
        agecategorys = await AgeCategory.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
        include: Optional[types.AgeCategoryInclude] = None,
        order: Optional[Union[types.AgeCategoryOrderByInput, List[types.AgeCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.AgeCategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AgeCategory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AgeCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgeCategory model
        order
            Order the returned AgeCategory records by any field
        distinct
            Filter AgeCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AgeCategory
            The first AgeCategory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AgeCategory record ordered by the name field
        agecategory = await AgeCategory.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
        include: Optional[types.AgeCategoryInclude] = None,
        order: Optional[Union[types.AgeCategoryOrderByInput, List[types.AgeCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.AgeCategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AgeCategory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AgeCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgeCategory model
        order
            Order the returned AgeCategory records by any field
        distinct
            Filter AgeCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AgeCategory
            The first AgeCategory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AgeCategory record ordered by the id field
        agecategory = await AgeCategory.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AgeCategoryUpdateInput,
        where: types.AgeCategoryWhereUniqueInput,
        include: Optional[types.AgeCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AgeCategory record.

        Parameters
        ----------
        data
            AgeCategory record data specifying what to update
        where
            AgeCategory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The updated AgeCategory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().update(
            where={
                'id': 976832615,
            },
            data={
                # data to update the AgeCategory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AgeCategoryWhereUniqueInput,
        data: types.AgeCategoryUpsertInput,
        include: Optional[types.AgeCategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AgeCategory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AgeCategory model

        Returns
        -------
        prisma.models.AgeCategory
            The created or updated AgeCategory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agecategory = await AgeCategory.prisma().upsert(
            where={
                'id': 1696425492,
            },
            data={
                'create': {
                    'id': 1696425492,
                    'name': 'cbbheiicgh',
                },
                'update': {
                    'name': 'cbbheiicgh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AgeCategoryUpdateManyMutationInput,
        where: types.AgeCategoryWhereInput,
    ) -> int:
        """Update multiple AgeCategory records

        Parameters
        ----------
        data
            AgeCategory data to update the selected AgeCategory records to
        where
            Filter to select the AgeCategory records to update

        Returns
        -------
        int
            The total number of AgeCategory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AgeCategory records
        total = await AgeCategory.prisma().update_many(
            data={
                'name': 'bgjcgchib'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AgeCategory records present in the database

        Parameters
        ----------
        select
            Select the AgeCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AgeCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgeCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AgeCategory.prisma().count()

        # results: prisma.types.AgeCategoryCountAggregateOutput
        results = await AgeCategory.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AgeCategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
    ) -> types.AgeCategoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AgeCategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgeCategoryWhereInput] = None,
        cursor: Optional[types.AgeCategoryWhereUniqueInput] = None,
    ) -> Union[int, types.AgeCategoryCountAggregateOutput]:
        """Count the number of AgeCategory records present in the database

        Parameters
        ----------
        select
            Select the AgeCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AgeCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgeCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AgeCategory.prisma().count()

        # results: prisma.types.AgeCategoryCountAggregateOutput
        results = await AgeCategory.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AgeCategoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AgeCategoryWhereInput] = None
    ) -> int:
        """Delete multiple AgeCategory records.

        Parameters
        ----------
        where
            Optional AgeCategory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AgeCategory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AgeCategory records
        total = await AgeCategory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AgeCategoryScalarFieldKeys'],
        *,
        where: Optional['types.AgeCategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AgeCategoryAvgAggregateInput'] = None,
        sum: Optional['types.AgeCategorySumAggregateInput'] = None,
        min: Optional['types.AgeCategoryMinAggregateInput'] = None,
        max: Optional['types.AgeCategoryMaxAggregateInput'] = None,
        having: Optional['types.AgeCategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AgeCategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AgeCategoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AgeCategoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AgeCategoryGroupByOutput']:
        """Group AgeCategory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AgeCategory fields to group records by
        where
            AgeCategory filter to select records
        take
            Limit the maximum number of AgeCategory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AgeCategoryGroupByOutput]
            A list of dictionaries representing the AgeCategory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AgeCategory records by id values
        # and count how many records are in each group
        results = await AgeCategory.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AuthorActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Author]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Author.prisma().query_raw(
            'SELECT * FROM Author WHERE id = $1',
            1023081650,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Author
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Author.prisma().query_first(
            'SELECT * FROM Author WHERE name = $1',
            'dchgibach',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AuthorCreateInput,
        include: Optional[types.AuthorInclude] = None
    ) -> _PrismaModelT:
        """Create a new Author record.

        Parameters
        ----------
        data
            Author record data
        include
            Specifies which relations should be loaded on the returned Author model

        Returns
        -------
        prisma.models.Author
            The created Author record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Author record from just the required fields
        author = await Author.prisma().create(
            data={
                # data to create a Author record
                'name': 'fchheijjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AuthorCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Author records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Author record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Author.prisma().create_many(
            data=[
                {
                    # data to create a Author record
                    'name': 'cacjdfhejh',
                },
                {
                    # data to create a Author record
                    'name': 'bdbifjhbbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AuthorWhereUniqueInput,
        include: Optional[types.AuthorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Author record.

        Parameters
        ----------
        where
            Author filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Author model

        Returns
        -------
        prisma.models.Author
            The deleted Author record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        author = await Author.prisma().delete(
            where={
                'id': 2122112351,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AuthorWhereUniqueInput,
        include: Optional[types.AuthorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Author record.

        Parameters
        ----------
        where
            Author filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Author model

        Returns
        -------
        prisma.models.Author
            The found Author record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        author = await Author.prisma().find_unique(
            where={
                'id': 1024943020,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AuthorWhereUniqueInput,
        include: Optional[types.AuthorInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Author record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Author filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Author model

        Returns
        -------
        prisma.models.Author
            The found Author record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        author = await Author.prisma().find_unique_or_raise(
            where={
                'id': 1717307509,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuthorWhereInput] = None,
        cursor: Optional[types.AuthorWhereUniqueInput] = None,
        include: Optional[types.AuthorInclude] = None,
        order: Optional[Union[types.AuthorOrderByInput, List[types.AuthorOrderByInput]]] = None,
        distinct: Optional[List[types.AuthorScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Author records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Author records returned
        skip
            Ignore the first N results
        where
            Author filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Author model
        order
            Order the returned Author records by any field
        distinct
            Filter Author records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Author]
            The list of all Author records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Author records
        authors = await Author.prisma().find_many(take=10)

        # find the first 5 Author records ordered by the createdAt field
        authors = await Author.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuthorWhereInput] = None,
        cursor: Optional[types.AuthorWhereUniqueInput] = None,
        include: Optional[types.AuthorInclude] = None,
        order: Optional[Union[types.AuthorOrderByInput, List[types.AuthorOrderByInput]]] = None,
        distinct: Optional[List[types.AuthorScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Author record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Author filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Author model
        order
            Order the returned Author records by any field
        distinct
            Filter Author records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Author
            The first Author record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Author record ordered by the updatedAt field
        author = await Author.prisma().find_first(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuthorWhereInput] = None,
        cursor: Optional[types.AuthorWhereUniqueInput] = None,
        include: Optional[types.AuthorInclude] = None,
        order: Optional[Union[types.AuthorOrderByInput, List[types.AuthorOrderByInput]]] = None,
        distinct: Optional[List[types.AuthorScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Author record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Author filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Author model
        order
            Order the returned Author records by any field
        distinct
            Filter Author records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Author
            The first Author record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Author record ordered by the id field
        author = await Author.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AuthorUpdateInput,
        where: types.AuthorWhereUniqueInput,
        include: Optional[types.AuthorInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Author record.

        Parameters
        ----------
        data
            Author record data specifying what to update
        where
            Author filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Author model

        Returns
        -------
        prisma.models.Author
            The updated Author record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        author = await Author.prisma().update(
            where={
                'id': 1598124042,
            },
            data={
                # data to update the Author record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AuthorWhereUniqueInput,
        data: types.AuthorUpsertInput,
        include: Optional[types.AuthorInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Author filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Author model

        Returns
        -------
        prisma.models.Author
            The created or updated Author record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        author = await Author.prisma().upsert(
            where={
                'id': 817623163,
            },
            data={
                'create': {
                    'id': 817623163,
                    'name': 'bdbifjhbbi',
                },
                'update': {
                    'name': 'bdbifjhbbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AuthorUpdateManyMutationInput,
        where: types.AuthorWhereInput,
    ) -> int:
        """Update multiple Author records

        Parameters
        ----------
        data
            Author data to update the selected Author records to
        where
            Filter to select the Author records to update

        Returns
        -------
        int
            The total number of Author records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Author records
        total = await Author.prisma().update_many(
            data={
                'name': 'badaffhddg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuthorWhereInput] = None,
        cursor: Optional[types.AuthorWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Author records present in the database

        Parameters
        ----------
        select
            Select the Author fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Author filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuthorCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Author.prisma().count()

        # results: prisma.types.AuthorCountAggregateOutput
        results = await Author.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AuthorCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuthorWhereInput] = None,
        cursor: Optional[types.AuthorWhereUniqueInput] = None,
    ) -> types.AuthorCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AuthorCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuthorWhereInput] = None,
        cursor: Optional[types.AuthorWhereUniqueInput] = None,
    ) -> Union[int, types.AuthorCountAggregateOutput]:
        """Count the number of Author records present in the database

        Parameters
        ----------
        select
            Select the Author fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Author filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuthorCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Author.prisma().count()

        # results: prisma.types.AuthorCountAggregateOutput
        results = await Author.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AuthorCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AuthorWhereInput] = None
    ) -> int:
        """Delete multiple Author records.

        Parameters
        ----------
        where
            Optional Author filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Author records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Author records
        total = await Author.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AuthorScalarFieldKeys'],
        *,
        where: Optional['types.AuthorWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AuthorAvgAggregateInput'] = None,
        sum: Optional['types.AuthorSumAggregateInput'] = None,
        min: Optional['types.AuthorMinAggregateInput'] = None,
        max: Optional['types.AuthorMaxAggregateInput'] = None,
        having: Optional['types.AuthorScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AuthorCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AuthorScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AuthorScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AuthorGroupByOutput']:
        """Group Author records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Author fields to group records by
        where
            Author filter to select records
        take
            Limit the maximum number of Author records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AuthorGroupByOutput]
            A list of dictionaries representing the Author record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Author records by id values
        # and count how many records are in each group
        results = await Author.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BookActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Book]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Book.prisma().query_raw(
            'SELECT * FROM Book WHERE id = $1',
            1131525873,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Book
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Book.prisma().query_first(
            'SELECT * FROM Book WHERE title = $1',
            'cbagggbji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BookCreateInput,
        include: Optional[types.BookInclude] = None
    ) -> _PrismaModelT:
        """Create a new Book record.

        Parameters
        ----------
        data
            Book record data
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The created Book record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Book record from just the required fields
        book = await Book.prisma().create(
            data={
                # data to create a Book record
                'title': 'bchgafhjed',
                'authorId': 745569348,
                'ageCategoryId': 307876141,
                'genreId': 1674049122,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BookCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Book records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Book record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Book.prisma().create_many(
            data=[
                {
                    # data to create a Book record
                    'title': 'bfcgifeged',
                    'authorId': 958077104,
                    'ageCategoryId': 1513050921,
                    'genreId': 204674734,
                },
                {
                    # data to create a Book record
                    'title': 'caghgfbggd',
                    'authorId': 1183911900,
                    'ageCategoryId': 1589704933,
                    'genreId': 1243475898,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Book record.

        Parameters
        ----------
        where
            Book filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The deleted Book record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().delete(
            where={
                'id': 1369828971,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Book record.

        Parameters
        ----------
        where
            Book filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The found Book record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().find_unique(
            where={
                'id': 1678593480,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Book record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Book filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The found Book record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().find_unique_or_raise(
            where={
                'id': 403521121,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
        include: Optional[types.BookInclude] = None,
        order: Optional[Union[types.BookOrderByInput, List[types.BookOrderByInput]]] = None,
        distinct: Optional[List[types.BookScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Book records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Book records returned
        skip
            Ignore the first N results
        where
            Book filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Book model
        order
            Order the returned Book records by any field
        distinct
            Filter Book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Book]
            The list of all Book records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Book records
        books = await Book.prisma().find_many(take=10)

        # find the first 5 Book records ordered by the authorId field
        books = await Book.prisma().find_many(
            take=5,
            order={
                'authorId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
        include: Optional[types.BookInclude] = None,
        order: Optional[Union[types.BookOrderByInput, List[types.BookOrderByInput]]] = None,
        distinct: Optional[List[types.BookScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Book record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Book filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Book model
        order
            Order the returned Book records by any field
        distinct
            Filter Book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Book
            The first Book record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Book record ordered by the description field
        book = await Book.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
        include: Optional[types.BookInclude] = None,
        order: Optional[Union[types.BookOrderByInput, List[types.BookOrderByInput]]] = None,
        distinct: Optional[List[types.BookScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Book record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Book filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Book model
        order
            Order the returned Book records by any field
        distinct
            Filter Book records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Book
            The first Book record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Book record ordered by the coverUrl field
        book = await Book.prisma().find_first_or_raise(
            skip=1,
            order={
                'coverUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BookUpdateInput,
        where: types.BookWhereUniqueInput,
        include: Optional[types.BookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Book record.

        Parameters
        ----------
        data
            Book record data specifying what to update
        where
            Book filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The updated Book record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        book = await Book.prisma().update(
            where={
                'id': 648760710,
            },
            data={
                # data to update the Book record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BookWhereUniqueInput,
        data: types.BookUpsertInput,
        include: Optional[types.BookInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Book filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Book model

        Returns
        -------
        prisma.models.Book
            The created or updated Book record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        book = await Book.prisma().upsert(
            where={
                'id': 607323719,
            },
            data={
                'create': {
                    'id': 607323719,
                    'title': 'caghgfbggd',
                    'authorId': 1183911900,
                    'ageCategoryId': 1589704933,
                    'genreId': 1243475898,
                },
                'update': {
                    'title': 'caghgfbggd',
                    'authorId': 1183911900,
                    'ageCategoryId': 1589704933,
                    'genreId': 1243475898,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BookUpdateManyMutationInput,
        where: types.BookWhereInput,
    ) -> int:
        """Update multiple Book records

        Parameters
        ----------
        data
            Book data to update the selected Book records to
        where
            Filter to select the Book records to update

        Returns
        -------
        int
            The total number of Book records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Book records
        total = await Book.prisma().update_many(
            data={
                'externalId': 'begiijahea'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Book records present in the database

        Parameters
        ----------
        select
            Select the Book fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Book filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Book.prisma().count()

        # results: prisma.types.BookCountAggregateOutput
        results = await Book.prisma().count(
            select={
                '_all': True,
                'ageCategoryId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BookCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
    ) -> types.BookCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BookCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BookWhereInput] = None,
        cursor: Optional[types.BookWhereUniqueInput] = None,
    ) -> Union[int, types.BookCountAggregateOutput]:
        """Count the number of Book records present in the database

        Parameters
        ----------
        select
            Select the Book fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Book filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Book.prisma().count()

        # results: prisma.types.BookCountAggregateOutput
        results = await Book.prisma().count(
            select={
                '_all': True,
                'rating': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BookCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BookWhereInput] = None
    ) -> int:
        """Delete multiple Book records.

        Parameters
        ----------
        where
            Optional Book filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Book records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Book records
        total = await Book.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BookScalarFieldKeys'],
        *,
        where: Optional['types.BookWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BookAvgAggregateInput'] = None,
        sum: Optional['types.BookSumAggregateInput'] = None,
        min: Optional['types.BookMinAggregateInput'] = None,
        max: Optional['types.BookMaxAggregateInput'] = None,
        having: Optional['types.BookScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BookCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BookScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BookScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BookGroupByOutput']:
        """Group Book records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Book fields to group records by
        where
            Book filter to select records
        take
            Limit the maximum number of Book records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BookGroupByOutput]
            A list of dictionaries representing the Book record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Book records by rating_count values
        # and count how many records are in each group
        results = await Book.prisma().group_by(
            ['rating_count'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserBookActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserBook]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserBook.prisma().query_raw(
            'SELECT * FROM UserBook WHERE id = $1',
            629039005,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserBook
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserBook.prisma().query_first(
            'SELECT * FROM UserBook WHERE userId = $1',
            1214168082,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserBookCreateInput,
        include: Optional[types.UserBookInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserBook record.

        Parameters
        ----------
        data
            UserBook record data
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The created UserBook record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserBook record from just the required fields
        userbook = await UserBook.prisma().create(
            data={
                # data to create a UserBook record
                'userId': 898613219,
                'bookId': 658378208,
                'status': 'jfegcaafh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserBookCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserBook records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserBook record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserBook.prisma().create_many(
            data=[
                {
                    # data to create a UserBook record
                    'userId': 1214809950,
                    'bookId': 1047820095,
                    'status': 'bdachdeiga',
                },
                {
                    # data to create a UserBook record
                    'userId': 893052245,
                    'bookId': 280083306,
                    'status': 'fejggijff',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserBook record.

        Parameters
        ----------
        where
            UserBook filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The deleted UserBook record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().delete(
            where={
                'id': 76790008,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserBook record.

        Parameters
        ----------
        where
            UserBook filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The found UserBook record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().find_unique(
            where={
                'id': 2098299345,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserBook record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserBook filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The found UserBook record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().find_unique_or_raise(
            where={
                'id': 245900342,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
        include: Optional[types.UserBookInclude] = None,
        order: Optional[Union[types.UserBookOrderByInput, List[types.UserBookOrderByInput]]] = None,
        distinct: Optional[List[types.UserBookScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserBook records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserBook records returned
        skip
            Ignore the first N results
        where
            UserBook filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBook model
        order
            Order the returned UserBook records by any field
        distinct
            Filter UserBook records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserBook]
            The list of all UserBook records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserBook records
        userbooks = await UserBook.prisma().find_many(take=10)

        # find the first 5 UserBook records ordered by the bookId field
        userbooks = await UserBook.prisma().find_many(
            take=5,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
        include: Optional[types.UserBookInclude] = None,
        order: Optional[Union[types.UserBookOrderByInput, List[types.UserBookOrderByInput]]] = None,
        distinct: Optional[List[types.UserBookScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserBook record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserBook filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBook model
        order
            Order the returned UserBook records by any field
        distinct
            Filter UserBook records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserBook
            The first UserBook record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserBook record ordered by the status field
        userbook = await UserBook.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
        include: Optional[types.UserBookInclude] = None,
        order: Optional[Union[types.UserBookOrderByInput, List[types.UserBookOrderByInput]]] = None,
        distinct: Optional[List[types.UserBookScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserBook record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserBook filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBook model
        order
            Order the returned UserBook records by any field
        distinct
            Filter UserBook records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserBook
            The first UserBook record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserBook record ordered by the rating field
        userbook = await UserBook.prisma().find_first_or_raise(
            skip=1,
            order={
                'rating': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserBookUpdateInput,
        where: types.UserBookWhereUniqueInput,
        include: Optional[types.UserBookInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserBook record.

        Parameters
        ----------
        data
            UserBook record data specifying what to update
        where
            UserBook filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The updated UserBook record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userbook = await UserBook.prisma().update(
            where={
                'id': 811863863,
            },
            data={
                # data to update the UserBook record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserBookWhereUniqueInput,
        data: types.UserBookUpsertInput,
        include: Optional[types.UserBookInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserBook filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserBook model

        Returns
        -------
        prisma.models.UserBook
            The created or updated UserBook record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbook = await UserBook.prisma().upsert(
            where={
                'id': 1388801188,
            },
            data={
                'create': {
                    'id': 1388801188,
                    'userId': 893052245,
                    'bookId': 280083306,
                    'status': 'fejggijff',
                },
                'update': {
                    'userId': 893052245,
                    'bookId': 280083306,
                    'status': 'fejggijff',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserBookUpdateManyMutationInput,
        where: types.UserBookWhereInput,
    ) -> int:
        """Update multiple UserBook records

        Parameters
        ----------
        data
            UserBook data to update the selected UserBook records to
        where
            Filter to select the UserBook records to update

        Returns
        -------
        int
            The total number of UserBook records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserBook records
        total = await UserBook.prisma().update_many(
            data={
                'addedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserBook records present in the database

        Parameters
        ----------
        select
            Select the UserBook fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserBook filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserBookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserBook.prisma().count()

        # results: prisma.types.UserBookCountAggregateOutput
        results = await UserBook.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserBookCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
    ) -> types.UserBookCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserBookCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBookWhereInput] = None,
        cursor: Optional[types.UserBookWhereUniqueInput] = None,
    ) -> Union[int, types.UserBookCountAggregateOutput]:
        """Count the number of UserBook records present in the database

        Parameters
        ----------
        select
            Select the UserBook fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserBook filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserBookCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserBook.prisma().count()

        # results: prisma.types.UserBookCountAggregateOutput
        results = await UserBook.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserBookCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserBookWhereInput] = None
    ) -> int:
        """Delete multiple UserBook records.

        Parameters
        ----------
        where
            Optional UserBook filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserBook records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserBook records
        total = await UserBook.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserBookScalarFieldKeys'],
        *,
        where: Optional['types.UserBookWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserBookAvgAggregateInput'] = None,
        sum: Optional['types.UserBookSumAggregateInput'] = None,
        min: Optional['types.UserBookMinAggregateInput'] = None,
        max: Optional['types.UserBookMaxAggregateInput'] = None,
        having: Optional['types.UserBookScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserBookCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserBookScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserBookScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserBookGroupByOutput']:
        """Group UserBook records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserBook fields to group records by
        where
            UserBook filter to select records
        take
            Limit the maximum number of UserBook records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserBookGroupByOutput]
            A list of dictionaries representing the UserBook record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserBook records by id values
        # and count how many records are in each group
        results = await UserBook.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class VoteActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Vote]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Vote.prisma().query_raw(
            'SELECT * FROM Vote WHERE id = $1',
            752577037,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Vote
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Vote.prisma().query_first(
            'SELECT * FROM Vote WHERE userId = $1',
            1187663298,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.VoteCreateInput,
        include: Optional[types.VoteInclude] = None
    ) -> _PrismaModelT:
        """Create a new Vote record.

        Parameters
        ----------
        data
            Vote record data
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The created Vote record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Vote record from just the required fields
        vote = await Vote.prisma().create(
            data={
                # data to create a Vote record
                'userId': 769681363,
                'bookId': 1214295824,
                'weekNumber': 1021417993,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.VoteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Vote records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Vote record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Vote.prisma().create_many(
            data=[
                {
                    # data to create a Vote record
                    'userId': 351503374,
                    'bookId': 1321184815,
                    'weekNumber': 369732668,
                },
                {
                    # data to create a Vote record
                    'userId': 1191235013,
                    'bookId': 627561242,
                    'weekNumber': 1872952907,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Vote record.

        Parameters
        ----------
        where
            Vote filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The deleted Vote record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().delete(
            where={
                'id': 1793282088,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Vote record.

        Parameters
        ----------
        where
            Vote filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The found Vote record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().find_unique(
            where={
                'id': 1814397249,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Vote record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Vote filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The found Vote record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().find_unique_or_raise(
            where={
                'id': 1923090150,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
        include: Optional[types.VoteInclude] = None,
        order: Optional[Union[types.VoteOrderByInput, List[types.VoteOrderByInput]]] = None,
        distinct: Optional[List[types.VoteScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Vote records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Vote records returned
        skip
            Ignore the first N results
        where
            Vote filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vote model
        order
            Order the returned Vote records by any field
        distinct
            Filter Vote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Vote]
            The list of all Vote records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Vote records
        votes = await Vote.prisma().find_many(take=10)

        # find the first 5 Vote records ordered by the bookId field
        votes = await Vote.prisma().find_many(
            take=5,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
        include: Optional[types.VoteInclude] = None,
        order: Optional[Union[types.VoteOrderByInput, List[types.VoteOrderByInput]]] = None,
        distinct: Optional[List[types.VoteScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Vote record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Vote filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vote model
        order
            Order the returned Vote records by any field
        distinct
            Filter Vote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Vote
            The first Vote record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Vote record ordered by the weekNumber field
        vote = await Vote.prisma().find_first(
            skip=1,
            order={
                'weekNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
        include: Optional[types.VoteInclude] = None,
        order: Optional[Union[types.VoteOrderByInput, List[types.VoteOrderByInput]]] = None,
        distinct: Optional[List[types.VoteScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Vote record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Vote filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vote model
        order
            Order the returned Vote records by any field
        distinct
            Filter Vote records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Vote
            The first Vote record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Vote record ordered by the voteDate field
        vote = await Vote.prisma().find_first_or_raise(
            skip=1,
            order={
                'voteDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.VoteUpdateInput,
        where: types.VoteWhereUniqueInput,
        include: Optional[types.VoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Vote record.

        Parameters
        ----------
        data
            Vote record data specifying what to update
        where
            Vote filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The updated Vote record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        vote = await Vote.prisma().update(
            where={
                'id': 1277244455,
            },
            data={
                # data to update the Vote record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.VoteWhereUniqueInput,
        data: types.VoteUpsertInput,
        include: Optional[types.VoteInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Vote filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Vote model

        Returns
        -------
        prisma.models.Vote
            The created or updated Vote record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vote = await Vote.prisma().upsert(
            where={
                'id': 1160857300,
            },
            data={
                'create': {
                    'id': 1160857300,
                    'userId': 1191235013,
                    'bookId': 627561242,
                    'weekNumber': 1872952907,
                },
                'update': {
                    'userId': 1191235013,
                    'bookId': 627561242,
                    'weekNumber': 1872952907,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.VoteUpdateManyMutationInput,
        where: types.VoteWhereInput,
    ) -> int:
        """Update multiple Vote records

        Parameters
        ----------
        data
            Vote data to update the selected Vote records to
        where
            Filter to select the Vote records to update

        Returns
        -------
        int
            The total number of Vote records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Vote records
        total = await Vote.prisma().update_many(
            data={
                'id': 361230461
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Vote records present in the database

        Parameters
        ----------
        select
            Select the Vote fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Vote filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VoteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Vote.prisma().count()

        # results: prisma.types.VoteCountAggregateOutput
        results = await Vote.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.VoteCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
    ) -> types.VoteCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.VoteCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VoteWhereInput] = None,
        cursor: Optional[types.VoteWhereUniqueInput] = None,
    ) -> Union[int, types.VoteCountAggregateOutput]:
        """Count the number of Vote records present in the database

        Parameters
        ----------
        select
            Select the Vote fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Vote filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VoteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Vote.prisma().count()

        # results: prisma.types.VoteCountAggregateOutput
        results = await Vote.prisma().count(
            select={
                '_all': True,
                'bookId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.VoteCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.VoteWhereInput] = None
    ) -> int:
        """Delete multiple Vote records.

        Parameters
        ----------
        where
            Optional Vote filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Vote records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Vote records
        total = await Vote.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.VoteScalarFieldKeys'],
        *,
        where: Optional['types.VoteWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.VoteAvgAggregateInput'] = None,
        sum: Optional['types.VoteSumAggregateInput'] = None,
        min: Optional['types.VoteMinAggregateInput'] = None,
        max: Optional['types.VoteMaxAggregateInput'] = None,
        having: Optional['types.VoteScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.VoteCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.VoteScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.VoteScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.VoteGroupByOutput']:
        """Group Vote records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Vote fields to group records by
        where
            Vote filter to select records
        take
            Limit the maximum number of Vote records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.VoteGroupByOutput]
            A list of dictionaries representing the Vote record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Vote records by weekNumber values
        # and count how many records are in each group
        results = await Vote.prisma().group_by(
            ['weekNumber'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReadingProgressActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ReadingProgress]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ReadingProgress.prisma().query_raw(
            'SELECT * FROM ReadingProgress WHERE id = $1',
            1406511986,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ReadingProgress
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ReadingProgress.prisma().query_first(
            'SELECT * FROM ReadingProgress WHERE userId = $1',
            1482877891,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReadingProgressCreateInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> _PrismaModelT:
        """Create a new ReadingProgress record.

        Parameters
        ----------
        data
            ReadingProgress record data
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The created ReadingProgress record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ReadingProgress record from just the required fields
        readingprogress = await ReadingProgress.prisma().create(
            data={
                # data to create a ReadingProgress record
                'userId': 566623296,
                'bookId': 229119865,
                'weekNumber': 1750011070,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReadingProgressCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ReadingProgress records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ReadingProgress record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ReadingProgress.prisma().create_many(
            data=[
                {
                    # data to create a ReadingProgress record
                    'userId': 410943775,
                    'bookId': 909024364,
                    'weekNumber': 755610165,
                },
                {
                    # data to create a ReadingProgress record
                    'userId': 1802188490,
                    'bookId': 294916155,
                    'weekNumber': 564073304,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ReadingProgress record.

        Parameters
        ----------
        where
            ReadingProgress filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The deleted ReadingProgress record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().delete(
            where={
                'id': 380648625,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ReadingProgress record.

        Parameters
        ----------
        where
            ReadingProgress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The found ReadingProgress record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().find_unique(
            where={
                'id': 1030616470,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ReadingProgress record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ReadingProgress filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The found ReadingProgress record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().find_unique_or_raise(
            where={
                'id': 816411927,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
        include: Optional[types.ReadingProgressInclude] = None,
        order: Optional[Union[types.ReadingProgressOrderByInput, List[types.ReadingProgressOrderByInput]]] = None,
        distinct: Optional[List[types.ReadingProgressScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ReadingProgress records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ReadingProgress records returned
        skip
            Ignore the first N results
        where
            ReadingProgress filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReadingProgress model
        order
            Order the returned ReadingProgress records by any field
        distinct
            Filter ReadingProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ReadingProgress]
            The list of all ReadingProgress records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ReadingProgress records
        readingprogress = await ReadingProgress.prisma().find_many(take=10)

        # find the first 5 ReadingProgress records ordered by the bookId field
        readingprogress = await ReadingProgress.prisma().find_many(
            take=5,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
        include: Optional[types.ReadingProgressInclude] = None,
        order: Optional[Union[types.ReadingProgressOrderByInput, List[types.ReadingProgressOrderByInput]]] = None,
        distinct: Optional[List[types.ReadingProgressScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ReadingProgress record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReadingProgress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReadingProgress model
        order
            Order the returned ReadingProgress records by any field
        distinct
            Filter ReadingProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReadingProgress
            The first ReadingProgress record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReadingProgress record ordered by the weekNumber field
        readingprogress = await ReadingProgress.prisma().find_first(
            skip=1,
            order={
                'weekNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
        include: Optional[types.ReadingProgressInclude] = None,
        order: Optional[Union[types.ReadingProgressOrderByInput, List[types.ReadingProgressOrderByInput]]] = None,
        distinct: Optional[List[types.ReadingProgressScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ReadingProgress record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReadingProgress filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReadingProgress model
        order
            Order the returned ReadingProgress records by any field
        distinct
            Filter ReadingProgress records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReadingProgress
            The first ReadingProgress record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReadingProgress record ordered by the marks field
        readingprogress = await ReadingProgress.prisma().find_first_or_raise(
            skip=1,
            order={
                'marks': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReadingProgressUpdateInput,
        where: types.ReadingProgressWhereUniqueInput,
        include: Optional[types.ReadingProgressInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ReadingProgress record.

        Parameters
        ----------
        data
            ReadingProgress record data specifying what to update
        where
            ReadingProgress filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The updated ReadingProgress record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().update(
            where={
                'id': 1084099844,
            },
            data={
                # data to update the ReadingProgress record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReadingProgressWhereUniqueInput,
        data: types.ReadingProgressUpsertInput,
        include: Optional[types.ReadingProgressInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ReadingProgress filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ReadingProgress model

        Returns
        -------
        prisma.models.ReadingProgress
            The created or updated ReadingProgress record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        readingprogress = await ReadingProgress.prisma().upsert(
            where={
                'id': 1079702253,
            },
            data={
                'create': {
                    'id': 1079702253,
                    'userId': 1802188490,
                    'bookId': 294916155,
                    'weekNumber': 564073304,
                },
                'update': {
                    'userId': 1802188490,
                    'bookId': 294916155,
                    'weekNumber': 564073304,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReadingProgressUpdateManyMutationInput,
        where: types.ReadingProgressWhereInput,
    ) -> int:
        """Update multiple ReadingProgress records

        Parameters
        ----------
        data
            ReadingProgress data to update the selected ReadingProgress records to
        where
            Filter to select the ReadingProgress records to update

        Returns
        -------
        int
            The total number of ReadingProgress records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ReadingProgress records
        total = await ReadingProgress.prisma().update_many(
            data={
                'progressDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ReadingProgress records present in the database

        Parameters
        ----------
        select
            Select the ReadingProgress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReadingProgress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReadingProgressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReadingProgress.prisma().count()

        # results: prisma.types.ReadingProgressCountAggregateOutput
        results = await ReadingProgress.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReadingProgressCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
    ) -> types.ReadingProgressCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReadingProgressCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReadingProgressWhereInput] = None,
        cursor: Optional[types.ReadingProgressWhereUniqueInput] = None,
    ) -> Union[int, types.ReadingProgressCountAggregateOutput]:
        """Count the number of ReadingProgress records present in the database

        Parameters
        ----------
        select
            Select the ReadingProgress fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReadingProgress filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReadingProgressCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReadingProgress.prisma().count()

        # results: prisma.types.ReadingProgressCountAggregateOutput
        results = await ReadingProgress.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReadingProgressCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReadingProgressWhereInput] = None
    ) -> int:
        """Delete multiple ReadingProgress records.

        Parameters
        ----------
        where
            Optional ReadingProgress filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ReadingProgress records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ReadingProgress records
        total = await ReadingProgress.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReadingProgressScalarFieldKeys'],
        *,
        where: Optional['types.ReadingProgressWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReadingProgressAvgAggregateInput'] = None,
        sum: Optional['types.ReadingProgressSumAggregateInput'] = None,
        min: Optional['types.ReadingProgressMinAggregateInput'] = None,
        max: Optional['types.ReadingProgressMaxAggregateInput'] = None,
        having: Optional['types.ReadingProgressScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReadingProgressCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReadingProgressScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ReadingProgressScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ReadingProgressGroupByOutput']:
        """Group ReadingProgress records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ReadingProgress fields to group records by
        where
            ReadingProgress filter to select records
        take
            Limit the maximum number of ReadingProgress records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReadingProgressGroupByOutput]
            A list of dictionaries representing the ReadingProgress record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ReadingProgress records by bookId values
        # and count how many records are in each group
        results = await ReadingProgress.prisma().group_by(
            ['bookId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WeeklyResultActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.WeeklyResult]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await WeeklyResult.prisma().query_raw(
            'SELECT * FROM WeeklyResult WHERE id = $1',
            755750178,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.WeeklyResult
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await WeeklyResult.prisma().query_first(
            'SELECT * FROM WeeklyResult WHERE weekNumber = $1',
            1128680371,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WeeklyResultCreateInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> _PrismaModelT:
        """Create a new WeeklyResult record.

        Parameters
        ----------
        data
            WeeklyResult record data
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The created WeeklyResult record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a WeeklyResult record from just the required fields
        weeklyresult = await WeeklyResult.prisma().create(
            data={
                # data to create a WeeklyResult record
                'weekNumber': 259061104,
                'ageCategoryId': 1115738345,
                'bookId': 1303781742,
                'leaderUserId': 1573908495,
                'totalMarks': 1195899036,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WeeklyResultCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple WeeklyResult records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of WeeklyResult record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await WeeklyResult.prisma().create_many(
            data=[
                {
                    # data to create a WeeklyResult record
                    'weekNumber': 739021477,
                    'ageCategoryId': 1722214010,
                    'bookId': 1269136939,
                    'leaderUserId': 573178504,
                    'totalMarks': 1440265249,
                },
                {
                    # data to create a WeeklyResult record
                    'weekNumber': 1185738822,
                    'ageCategoryId': 1694224903,
                    'bookId': 1906360116,
                    'leaderUserId': 1911255389,
                    'totalMarks': 146262738,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single WeeklyResult record.

        Parameters
        ----------
        where
            WeeklyResult filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The deleted WeeklyResult record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().delete(
            where={
                'id': 1719240611,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique WeeklyResult record.

        Parameters
        ----------
        where
            WeeklyResult filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The found WeeklyResult record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().find_unique(
            where={
                'id': 1948555936,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> _PrismaModelT:
        """Find a unique WeeklyResult record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            WeeklyResult filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The found WeeklyResult record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().find_unique_or_raise(
            where={
                'id': 1383253593,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
        include: Optional[types.WeeklyResultInclude] = None,
        order: Optional[Union[types.WeeklyResultOrderByInput, List[types.WeeklyResultOrderByInput]]] = None,
        distinct: Optional[List[types.WeeklyResultScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple WeeklyResult records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of WeeklyResult records returned
        skip
            Ignore the first N results
        where
            WeeklyResult filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WeeklyResult model
        order
            Order the returned WeeklyResult records by any field
        distinct
            Filter WeeklyResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.WeeklyResult]
            The list of all WeeklyResult records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 WeeklyResult records
        weeklyresults = await WeeklyResult.prisma().find_many(take=10)

        # find the first 5 WeeklyResult records ordered by the ageCategoryId field
        weeklyresults = await WeeklyResult.prisma().find_many(
            take=5,
            order={
                'ageCategoryId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
        include: Optional[types.WeeklyResultInclude] = None,
        order: Optional[Union[types.WeeklyResultOrderByInput, List[types.WeeklyResultOrderByInput]]] = None,
        distinct: Optional[List[types.WeeklyResultScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single WeeklyResult record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WeeklyResult filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WeeklyResult model
        order
            Order the returned WeeklyResult records by any field
        distinct
            Filter WeeklyResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WeeklyResult
            The first WeeklyResult record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WeeklyResult record ordered by the bookId field
        weeklyresult = await WeeklyResult.prisma().find_first(
            skip=1,
            order={
                'bookId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
        include: Optional[types.WeeklyResultInclude] = None,
        order: Optional[Union[types.WeeklyResultOrderByInput, List[types.WeeklyResultOrderByInput]]] = None,
        distinct: Optional[List[types.WeeklyResultScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single WeeklyResult record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WeeklyResult filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WeeklyResult model
        order
            Order the returned WeeklyResult records by any field
        distinct
            Filter WeeklyResult records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WeeklyResult
            The first WeeklyResult record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WeeklyResult record ordered by the leaderUserId field
        weeklyresult = await WeeklyResult.prisma().find_first_or_raise(
            skip=1,
            order={
                'leaderUserId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WeeklyResultUpdateInput,
        where: types.WeeklyResultWhereUniqueInput,
        include: Optional[types.WeeklyResultInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single WeeklyResult record.

        Parameters
        ----------
        data
            WeeklyResult record data specifying what to update
        where
            WeeklyResult filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The updated WeeklyResult record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().update(
            where={
                'id': 354664990,
            },
            data={
                # data to update the WeeklyResult record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WeeklyResultWhereUniqueInput,
        data: types.WeeklyResultUpsertInput,
        include: Optional[types.WeeklyResultInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            WeeklyResult filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned WeeklyResult model

        Returns
        -------
        prisma.models.WeeklyResult
            The created or updated WeeklyResult record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weeklyresult = await WeeklyResult.prisma().upsert(
            where={
                'id': 647166719,
            },
            data={
                'create': {
                    'id': 647166719,
                    'weekNumber': 1185738822,
                    'ageCategoryId': 1694224903,
                    'bookId': 1906360116,
                    'leaderUserId': 1911255389,
                    'totalMarks': 146262738,
                },
                'update': {
                    'weekNumber': 1185738822,
                    'ageCategoryId': 1694224903,
                    'bookId': 1906360116,
                    'leaderUserId': 1911255389,
                    'totalMarks': 146262738,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WeeklyResultUpdateManyMutationInput,
        where: types.WeeklyResultWhereInput,
    ) -> int:
        """Update multiple WeeklyResult records

        Parameters
        ----------
        data
            WeeklyResult data to update the selected WeeklyResult records to
        where
            Filter to select the WeeklyResult records to update

        Returns
        -------
        int
            The total number of WeeklyResult records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all WeeklyResult records
        total = await WeeklyResult.prisma().update_many(
            data={
                'totalMarks': 357089484
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
    ) -> int:
        """Count the number of WeeklyResult records present in the database

        Parameters
        ----------
        select
            Select the WeeklyResult fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WeeklyResult filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WeeklyResultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WeeklyResult.prisma().count()

        # results: prisma.types.WeeklyResultCountAggregateOutput
        results = await WeeklyResult.prisma().count(
            select={
                '_all': True,
                'genreId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WeeklyResultCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
    ) -> types.WeeklyResultCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WeeklyResultCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeeklyResultWhereInput] = None,
        cursor: Optional[types.WeeklyResultWhereUniqueInput] = None,
    ) -> Union[int, types.WeeklyResultCountAggregateOutput]:
        """Count the number of WeeklyResult records present in the database

        Parameters
        ----------
        select
            Select the WeeklyResult fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WeeklyResult filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WeeklyResultCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WeeklyResult.prisma().count()

        # results: prisma.types.WeeklyResultCountAggregateOutput
        results = await WeeklyResult.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WeeklyResultCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WeeklyResultWhereInput] = None
    ) -> int:
        """Delete multiple WeeklyResult records.

        Parameters
        ----------
        where
            Optional WeeklyResult filter to find the records to be deleted

        Returns
        -------
        int
            The total number of WeeklyResult records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all WeeklyResult records
        total = await WeeklyResult.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WeeklyResultScalarFieldKeys'],
        *,
        where: Optional['types.WeeklyResultWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WeeklyResultAvgAggregateInput'] = None,
        sum: Optional['types.WeeklyResultSumAggregateInput'] = None,
        min: Optional['types.WeeklyResultMinAggregateInput'] = None,
        max: Optional['types.WeeklyResultMaxAggregateInput'] = None,
        having: Optional['types.WeeklyResultScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WeeklyResultCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WeeklyResultScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WeeklyResultScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WeeklyResultGroupByOutput']:
        """Group WeeklyResult records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar WeeklyResult fields to group records by
        where
            WeeklyResult filter to select records
        take
            Limit the maximum number of WeeklyResult records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WeeklyResultGroupByOutput]
            A list of dictionaries representing the WeeklyResult record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group WeeklyResult records by weekNumber values
        # and count how many records are in each group
        results = await WeeklyResult.prisma().group_by(
            ['weekNumber'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Notification]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Notification.prisma().query_raw(
            'SELECT * FROM Notification WHERE id = $1',
            612396821,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Notification
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Notification.prisma().query_first(
            'SELECT * FROM Notification WHERE userId = $1',
            1808130602,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Notification record.

        Parameters
        ----------
        data
            Notification record data
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created Notification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Notification record from just the required fields
        notification = await Notification.prisma().create(
            data={
                # data to create a Notification record
                'userId': 1151748123,
                'message': 'hiagajie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Notification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Notification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Notification.prisma().create_many(
            data=[
                {
                    # data to create a Notification record
                    'userId': 444983185,
                    'message': 'efgbahec',
                },
                {
                    # data to create a Notification record
                    'userId': 769084151,
                    'message': 'bddefjjabc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Notification record.

        Parameters
        ----------
        where
            Notification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The deleted Notification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().delete(
            where={
                'id': 1116761037,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Notification record.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique(
            where={
                'id': 1172606082,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Notification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique_or_raise(
            where={
                'id': 330014611,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Notification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N results
        where
            Notification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Notification]
            The list of all Notification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Notification records
        notifications = await Notification.prisma().find_many(take=10)

        # find the first 5 Notification records ordered by the message field
        notifications = await Notification.prisma().find_many(
            take=5,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Notification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the sentDate field
        notification = await Notification.prisma().find_first(
            skip=1,
            order={
                'sentDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Notification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the id field
        notification = await Notification.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Notification record.

        Parameters
        ----------
        data
            Notification record data specifying what to update
        where
            Notification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The updated Notification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notification = await Notification.prisma().update(
            where={
                'id': 1768156112,
            },
            data={
                # data to update the Notification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Notification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created or updated Notification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().upsert(
            where={
                'id': 71628745,
            },
            data={
                'create': {
                    'id': 71628745,
                    'userId': 769084151,
                    'message': 'bddefjjabc',
                },
                'update': {
                    'userId': 769084151,
                    'message': 'bddefjjabc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> int:
        """Update multiple Notification records

        Parameters
        ----------
        data
            Notification data to update the selected Notification records to
        where
            Filter to select the Notification records to update

        Returns
        -------
        int
            The total number of Notification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Notification records
        total = await Notification.prisma().update_many(
            data={
                'userId': 55766734
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'message': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> types.NotificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationCountAggregateOutput]:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'sentDate': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None
    ) -> int:
        """Delete multiple Notification records.

        Parameters
        ----------
        where
            Optional Notification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Notification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Notification records
        total = await Notification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationScalarFieldKeys'],
        *,
        where: Optional['types.NotificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationAvgAggregateInput'] = None,
        sum: Optional['types.NotificationSumAggregateInput'] = None,
        min: Optional['types.NotificationMinAggregateInput'] = None,
        max: Optional['types.NotificationMaxAggregateInput'] = None,
        having: Optional['types.NotificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationGroupByOutput']:
        """Group Notification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Notification fields to group records by
        where
            Notification filter to select records
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationGroupByOutput]
            A list of dictionaries representing the Notification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Notification records by id values
        # and count how many records are in each group
        results = await Notification.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AdvertisementActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Advertisement]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Advertisement.prisma().query_raw(
            'SELECT * FROM Advertisement WHERE id = $1',
            812032495,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Advertisement
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Advertisement.prisma().query_first(
            'SELECT * FROM Advertisement WHERE content = $1',
            'bdcdfgccdg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AdvertisementCreateInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> _PrismaModelT:
        """Create a new Advertisement record.

        Parameters
        ----------
        data
            Advertisement record data
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The created Advertisement record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Advertisement record from just the required fields
        advertisement = await Advertisement.prisma().create(
            data={
                # data to create a Advertisement record
                'content': 'edhjgdfh',
                'partnerId': 1345530330,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AdvertisementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Advertisement records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Advertisement record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Advertisement.prisma().create_many(
            data=[
                {
                    # data to create a Advertisement record
                    'content': 'bjgfdihchf',
                    'partnerId': 804873448,
                },
                {
                    # data to create a Advertisement record
                    'content': 'bfggejgfbd',
                    'partnerId': 850004390,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Advertisement record.

        Parameters
        ----------
        where
            Advertisement filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The deleted Advertisement record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().delete(
            where={
                'id': 2109399015,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Advertisement record.

        Parameters
        ----------
        where
            Advertisement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The found Advertisement record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().find_unique(
            where={
                'id': 1282664340,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Advertisement record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Advertisement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The found Advertisement record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().find_unique_or_raise(
            where={
                'id': 241230397,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
        include: Optional[types.AdvertisementInclude] = None,
        order: Optional[Union[types.AdvertisementOrderByInput, List[types.AdvertisementOrderByInput]]] = None,
        distinct: Optional[List[types.AdvertisementScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Advertisement records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Advertisement records returned
        skip
            Ignore the first N results
        where
            Advertisement filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Advertisement model
        order
            Order the returned Advertisement records by any field
        distinct
            Filter Advertisement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Advertisement]
            The list of all Advertisement records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Advertisement records
        advertisements = await Advertisement.prisma().find_many(take=10)

        # find the first 5 Advertisement records ordered by the partnerId field
        advertisements = await Advertisement.prisma().find_many(
            take=5,
            order={
                'partnerId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
        include: Optional[types.AdvertisementInclude] = None,
        order: Optional[Union[types.AdvertisementOrderByInput, List[types.AdvertisementOrderByInput]]] = None,
        distinct: Optional[List[types.AdvertisementScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Advertisement record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Advertisement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Advertisement model
        order
            Order the returned Advertisement records by any field
        distinct
            Filter Advertisement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Advertisement
            The first Advertisement record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Advertisement record ordered by the isActive field
        advertisement = await Advertisement.prisma().find_first(
            skip=1,
            order={
                'isActive': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
        include: Optional[types.AdvertisementInclude] = None,
        order: Optional[Union[types.AdvertisementOrderByInput, List[types.AdvertisementOrderByInput]]] = None,
        distinct: Optional[List[types.AdvertisementScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Advertisement record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Advertisement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Advertisement model
        order
            Order the returned Advertisement records by any field
        distinct
            Filter Advertisement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Advertisement
            The first Advertisement record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Advertisement record ordered by the id field
        advertisement = await Advertisement.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AdvertisementUpdateInput,
        where: types.AdvertisementWhereUniqueInput,
        include: Optional[types.AdvertisementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Advertisement record.

        Parameters
        ----------
        data
            Advertisement record data specifying what to update
        where
            Advertisement filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The updated Advertisement record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().update(
            where={
                'id': 475863602,
            },
            data={
                # data to update the Advertisement record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AdvertisementWhereUniqueInput,
        data: types.AdvertisementUpsertInput,
        include: Optional[types.AdvertisementInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Advertisement filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Advertisement model

        Returns
        -------
        prisma.models.Advertisement
            The created or updated Advertisement record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        advertisement = await Advertisement.prisma().upsert(
            where={
                'id': 1716228995,
            },
            data={
                'create': {
                    'id': 1716228995,
                    'content': 'bfggejgfbd',
                    'partnerId': 850004390,
                },
                'update': {
                    'content': 'bfggejgfbd',
                    'partnerId': 850004390,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AdvertisementUpdateManyMutationInput,
        where: types.AdvertisementWhereInput,
    ) -> int:
        """Update multiple Advertisement records

        Parameters
        ----------
        data
            Advertisement data to update the selected Advertisement records to
        where
            Filter to select the Advertisement records to update

        Returns
        -------
        int
            The total number of Advertisement records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Advertisement records
        total = await Advertisement.prisma().update_many(
            data={
                'content': 'bigjhdgbjc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Advertisement records present in the database

        Parameters
        ----------
        select
            Select the Advertisement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Advertisement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdvertisementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Advertisement.prisma().count()

        # results: prisma.types.AdvertisementCountAggregateOutput
        results = await Advertisement.prisma().count(
            select={
                '_all': True,
                'partnerId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AdvertisementCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
    ) -> types.AdvertisementCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AdvertisementCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdvertisementWhereInput] = None,
        cursor: Optional[types.AdvertisementWhereUniqueInput] = None,
    ) -> Union[int, types.AdvertisementCountAggregateOutput]:
        """Count the number of Advertisement records present in the database

        Parameters
        ----------
        select
            Select the Advertisement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Advertisement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdvertisementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Advertisement.prisma().count()

        # results: prisma.types.AdvertisementCountAggregateOutput
        results = await Advertisement.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AdvertisementCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AdvertisementWhereInput] = None
    ) -> int:
        """Delete multiple Advertisement records.

        Parameters
        ----------
        where
            Optional Advertisement filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Advertisement records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Advertisement records
        total = await Advertisement.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AdvertisementScalarFieldKeys'],
        *,
        where: Optional['types.AdvertisementWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AdvertisementAvgAggregateInput'] = None,
        sum: Optional['types.AdvertisementSumAggregateInput'] = None,
        min: Optional['types.AdvertisementMinAggregateInput'] = None,
        max: Optional['types.AdvertisementMaxAggregateInput'] = None,
        having: Optional['types.AdvertisementScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AdvertisementCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AdvertisementScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AdvertisementScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AdvertisementGroupByOutput']:
        """Group Advertisement records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Advertisement fields to group records by
        where
            Advertisement filter to select records
        take
            Limit the maximum number of Advertisement records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AdvertisementGroupByOutput]
            A list of dictionaries representing the Advertisement record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Advertisement records by id values
        # and count how many records are in each group
        results = await Advertisement.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PartnerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Partner]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Partner.prisma().query_raw(
            'SELECT * FROM Partner WHERE id = $1',
            1585341753,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Partner
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Partner.prisma().query_first(
            'SELECT * FROM Partner WHERE name = $1',
            'cjchbjde',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PartnerCreateInput,
        include: Optional[types.PartnerInclude] = None
    ) -> _PrismaModelT:
        """Create a new Partner record.

        Parameters
        ----------
        data
            Partner record data
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The created Partner record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Partner record from just the required fields
        partner = await Partner.prisma().create(
            data={
                # data to create a Partner record
                'name': 'bfiibjcehj',
                'contactInfo': 'ijieafghg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PartnerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Partner records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Partner record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Partner.prisma().create_many(
            data=[
                {
                    # data to create a Partner record
                    'name': 'hhhegahcf',
                    'contactInfo': 'edhijefdi',
                },
                {
                    # data to create a Partner record
                    'name': 'djddecjhb',
                    'contactInfo': 'bgdicjhie',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Partner record.

        Parameters
        ----------
        where
            Partner filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The deleted Partner record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().delete(
            where={
                'id': 248152689,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Partner record.

        Parameters
        ----------
        where
            Partner filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The found Partner record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().find_unique(
            where={
                'id': 341715030,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Partner record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Partner filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The found Partner record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().find_unique_or_raise(
            where={
                'id': 1692766423,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
        include: Optional[types.PartnerInclude] = None,
        order: Optional[Union[types.PartnerOrderByInput, List[types.PartnerOrderByInput]]] = None,
        distinct: Optional[List[types.PartnerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Partner records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Partner records returned
        skip
            Ignore the first N results
        where
            Partner filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Partner model
        order
            Order the returned Partner records by any field
        distinct
            Filter Partner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Partner]
            The list of all Partner records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Partner records
        partners = await Partner.prisma().find_many(take=10)

        # find the first 5 Partner records ordered by the contactInfo field
        partners = await Partner.prisma().find_many(
            take=5,
            order={
                'contactInfo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
        include: Optional[types.PartnerInclude] = None,
        order: Optional[Union[types.PartnerOrderByInput, List[types.PartnerOrderByInput]]] = None,
        distinct: Optional[List[types.PartnerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Partner record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Partner filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Partner model
        order
            Order the returned Partner records by any field
        distinct
            Filter Partner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Partner
            The first Partner record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Partner record ordered by the id field
        partner = await Partner.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
        include: Optional[types.PartnerInclude] = None,
        order: Optional[Union[types.PartnerOrderByInput, List[types.PartnerOrderByInput]]] = None,
        distinct: Optional[List[types.PartnerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Partner record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Partner filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Partner model
        order
            Order the returned Partner records by any field
        distinct
            Filter Partner records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Partner
            The first Partner record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Partner record ordered by the name field
        partner = await Partner.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PartnerUpdateInput,
        where: types.PartnerWhereUniqueInput,
        include: Optional[types.PartnerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Partner record.

        Parameters
        ----------
        data
            Partner record data specifying what to update
        where
            Partner filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The updated Partner record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        partner = await Partner.prisma().update(
            where={
                'id': 86662596,
            },
            data={
                # data to update the Partner record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PartnerWhereUniqueInput,
        data: types.PartnerUpsertInput,
        include: Optional[types.PartnerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Partner filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Partner model

        Returns
        -------
        prisma.models.Partner
            The created or updated Partner record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        partner = await Partner.prisma().upsert(
            where={
                'id': 1697895597,
            },
            data={
                'create': {
                    'id': 1697895597,
                    'name': 'djddecjhb',
                    'contactInfo': 'bgdicjhie',
                },
                'update': {
                    'name': 'djddecjhb',
                    'contactInfo': 'bgdicjhie',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PartnerUpdateManyMutationInput,
        where: types.PartnerWhereInput,
    ) -> int:
        """Update multiple Partner records

        Parameters
        ----------
        data
            Partner data to update the selected Partner records to
        where
            Filter to select the Partner records to update

        Returns
        -------
        int
            The total number of Partner records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Partner records
        total = await Partner.prisma().update_many(
            data={
                'contactInfo': 'bcigdhache'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Partner records present in the database

        Parameters
        ----------
        select
            Select the Partner fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Partner filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PartnerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Partner.prisma().count()

        # results: prisma.types.PartnerCountAggregateOutput
        results = await Partner.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PartnerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
    ) -> types.PartnerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PartnerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PartnerWhereInput] = None,
        cursor: Optional[types.PartnerWhereUniqueInput] = None,
    ) -> Union[int, types.PartnerCountAggregateOutput]:
        """Count the number of Partner records present in the database

        Parameters
        ----------
        select
            Select the Partner fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Partner filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PartnerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Partner.prisma().count()

        # results: prisma.types.PartnerCountAggregateOutput
        results = await Partner.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PartnerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PartnerWhereInput] = None
    ) -> int:
        """Delete multiple Partner records.

        Parameters
        ----------
        where
            Optional Partner filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Partner records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Partner records
        total = await Partner.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PartnerScalarFieldKeys'],
        *,
        where: Optional['types.PartnerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PartnerAvgAggregateInput'] = None,
        sum: Optional['types.PartnerSumAggregateInput'] = None,
        min: Optional['types.PartnerMinAggregateInput'] = None,
        max: Optional['types.PartnerMaxAggregateInput'] = None,
        having: Optional['types.PartnerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PartnerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PartnerScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PartnerScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PartnerGroupByOutput']:
        """Group Partner records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Partner fields to group records by
        where
            Partner filter to select records
        take
            Limit the maximum number of Partner records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PartnerGroupByOutput]
            A list of dictionaries representing the Partner record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Partner records by contactInfo values
        # and count how many records are in each group
        results = await Partner.prisma().group_by(
            ['contactInfo'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AchievementActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Achievement]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Achievement.prisma().query_raw(
            'SELECT * FROM Achievement WHERE id = $1',
            864576371,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Achievement
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Achievement.prisma().query_first(
            'SELECT * FROM Achievement WHERE name = $1',
            'ejbiifbae',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AchievementCreateInput,
        include: Optional[types.AchievementInclude] = None
    ) -> _PrismaModelT:
        """Create a new Achievement record.

        Parameters
        ----------
        data
            Achievement record data
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The created Achievement record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Achievement record from just the required fields
        achievement = await Achievement.prisma().create(
            data={
                # data to create a Achievement record
                'name': 'djcfgedjd',
                'description': 'bdbjcdegag',
                'type': 'hbchfebch',
                'criteria': Json({'bcjjffegfc': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AchievementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Achievement records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Achievement record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Achievement.prisma().create_many(
            data=[
                {
                    # data to create a Achievement record
                    'name': 'cahaeaicjd',
                    'description': 'ibbjaacbi',
                    'type': 'djgacbcch',
                    'criteria': Json({'geeeegace': True}),
                },
                {
                    # data to create a Achievement record
                    'name': 'bbgdigchd',
                    'description': 'dajcifgdi',
                    'type': 'ccedhdbj',
                    'criteria': Json({'bjaabjjjce': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Achievement record.

        Parameters
        ----------
        where
            Achievement filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The deleted Achievement record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().delete(
            where={
                'id': 2057323293,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Achievement record.

        Parameters
        ----------
        where
            Achievement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The found Achievement record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().find_unique(
            where={
                'id': 1344117138,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Achievement record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Achievement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The found Achievement record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().find_unique_or_raise(
            where={
                'id': 2052132707,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
        include: Optional[types.AchievementInclude] = None,
        order: Optional[Union[types.AchievementOrderByInput, List[types.AchievementOrderByInput]]] = None,
        distinct: Optional[List[types.AchievementScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Achievement records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Achievement records returned
        skip
            Ignore the first N results
        where
            Achievement filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Achievement model
        order
            Order the returned Achievement records by any field
        distinct
            Filter Achievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Achievement]
            The list of all Achievement records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Achievement records
        achievements = await Achievement.prisma().find_many(take=10)

        # find the first 5 Achievement records ordered by the description field
        achievements = await Achievement.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
        include: Optional[types.AchievementInclude] = None,
        order: Optional[Union[types.AchievementOrderByInput, List[types.AchievementOrderByInput]]] = None,
        distinct: Optional[List[types.AchievementScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Achievement record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Achievement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Achievement model
        order
            Order the returned Achievement records by any field
        distinct
            Filter Achievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Achievement
            The first Achievement record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Achievement record ordered by the type field
        achievement = await Achievement.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
        include: Optional[types.AchievementInclude] = None,
        order: Optional[Union[types.AchievementOrderByInput, List[types.AchievementOrderByInput]]] = None,
        distinct: Optional[List[types.AchievementScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Achievement record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Achievement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Achievement model
        order
            Order the returned Achievement records by any field
        distinct
            Filter Achievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Achievement
            The first Achievement record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Achievement record ordered by the criteria field
        achievement = await Achievement.prisma().find_first_or_raise(
            skip=1,
            order={
                'criteria': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AchievementUpdateInput,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Achievement record.

        Parameters
        ----------
        data
            Achievement record data specifying what to update
        where
            Achievement filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The updated Achievement record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        achievement = await Achievement.prisma().update(
            where={
                'id': 1355147104,
            },
            data={
                # data to update the Achievement record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AchievementWhereUniqueInput,
        data: types.AchievementUpsertInput,
        include: Optional[types.AchievementInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Achievement filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The created or updated Achievement record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().upsert(
            where={
                'id': 84079641,
            },
            data={
                'create': {
                    'id': 84079641,
                    'name': 'bbgdigchd',
                    'description': 'dajcifgdi',
                    'type': 'ccedhdbj',
                    'criteria': Json({'bjaabjjjce': True}),
                },
                'update': {
                    'name': 'bbgdigchd',
                    'description': 'dajcifgdi',
                    'type': 'ccedhdbj',
                    'criteria': Json({'bjaabjjjce': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AchievementUpdateManyMutationInput,
        where: types.AchievementWhereInput,
    ) -> int:
        """Update multiple Achievement records

        Parameters
        ----------
        data
            Achievement data to update the selected Achievement records to
        where
            Filter to select the Achievement records to update

        Returns
        -------
        int
            The total number of Achievement records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Achievement records
        total = await Achievement.prisma().update_many(
            data={
                'reward': 754433246
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Achievement records present in the database

        Parameters
        ----------
        select
            Select the Achievement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Achievement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AchievementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Achievement.prisma().count()

        # results: prisma.types.AchievementCountAggregateOutput
        results = await Achievement.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AchievementCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
    ) -> types.AchievementCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AchievementCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
    ) -> Union[int, types.AchievementCountAggregateOutput]:
        """Count the number of Achievement records present in the database

        Parameters
        ----------
        select
            Select the Achievement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Achievement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AchievementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Achievement.prisma().count()

        # results: prisma.types.AchievementCountAggregateOutput
        results = await Achievement.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AchievementCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AchievementWhereInput] = None
    ) -> int:
        """Delete multiple Achievement records.

        Parameters
        ----------
        where
            Optional Achievement filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Achievement records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Achievement records
        total = await Achievement.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AchievementScalarFieldKeys'],
        *,
        where: Optional['types.AchievementWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AchievementAvgAggregateInput'] = None,
        sum: Optional['types.AchievementSumAggregateInput'] = None,
        min: Optional['types.AchievementMinAggregateInput'] = None,
        max: Optional['types.AchievementMaxAggregateInput'] = None,
        having: Optional['types.AchievementScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AchievementCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AchievementScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AchievementScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AchievementGroupByOutput']:
        """Group Achievement records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Achievement fields to group records by
        where
            Achievement filter to select records
        take
            Limit the maximum number of Achievement records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AchievementGroupByOutput]
            A list of dictionaries representing the Achievement record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Achievement records by id values
        # and count how many records are in each group
        results = await Achievement.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserAchievementActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserAchievement]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserAchievement.prisma().query_raw(
            'SELECT * FROM UserAchievement WHERE id = $1',
            314261183,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserAchievement
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserAchievement.prisma().query_first(
            'SELECT * FROM UserAchievement WHERE userId = $1',
            227678604,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserAchievementCreateInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserAchievement record.

        Parameters
        ----------
        data
            UserAchievement record data
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The created UserAchievement record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserAchievement record from just the required fields
        userachievement = await UserAchievement.prisma().create(
            data={
                # data to create a UserAchievement record
                'userId': 423999701,
                'achievementId': 180275434,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserAchievementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserAchievement records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserAchievement record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserAchievement.prisma().create_many(
            data=[
                {
                    # data to create a UserAchievement record
                    'userId': 57608155,
                    'achievementId': 2030912120,
                },
                {
                    # data to create a UserAchievement record
                    'userId': 1974865233,
                    'achievementId': 1949862326,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserAchievementWhereUniqueInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserAchievement record.

        Parameters
        ----------
        where
            UserAchievement filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The deleted UserAchievement record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userachievement = await UserAchievement.prisma().delete(
            where={
                'id': 1858881207,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserAchievementWhereUniqueInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserAchievement record.

        Parameters
        ----------
        where
            UserAchievement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The found UserAchievement record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userachievement = await UserAchievement.prisma().find_unique(
            where={
                'id': 319819300,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserAchievementWhereUniqueInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserAchievement record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserAchievement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The found UserAchievement record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userachievement = await UserAchievement.prisma().find_unique_or_raise(
            where={
                'id': 368913805,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
        include: Optional[types.UserAchievementInclude] = None,
        order: Optional[Union[types.UserAchievementOrderByInput, List[types.UserAchievementOrderByInput]]] = None,
        distinct: Optional[List[types.UserAchievementScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserAchievement records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserAchievement records returned
        skip
            Ignore the first N results
        where
            UserAchievement filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAchievement model
        order
            Order the returned UserAchievement records by any field
        distinct
            Filter UserAchievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserAchievement]
            The list of all UserAchievement records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserAchievement records
        userachievements = await UserAchievement.prisma().find_many(take=10)

        # find the first 5 UserAchievement records ordered by the achievementId field
        userachievements = await UserAchievement.prisma().find_many(
            take=5,
            order={
                'achievementId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
        include: Optional[types.UserAchievementInclude] = None,
        order: Optional[Union[types.UserAchievementOrderByInput, List[types.UserAchievementOrderByInput]]] = None,
        distinct: Optional[List[types.UserAchievementScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserAchievement record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserAchievement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAchievement model
        order
            Order the returned UserAchievement records by any field
        distinct
            Filter UserAchievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserAchievement
            The first UserAchievement record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserAchievement record ordered by the achievedAt field
        userachievement = await UserAchievement.prisma().find_first(
            skip=1,
            order={
                'achievedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
        include: Optional[types.UserAchievementInclude] = None,
        order: Optional[Union[types.UserAchievementOrderByInput, List[types.UserAchievementOrderByInput]]] = None,
        distinct: Optional[List[types.UserAchievementScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserAchievement record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserAchievement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAchievement model
        order
            Order the returned UserAchievement records by any field
        distinct
            Filter UserAchievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserAchievement
            The first UserAchievement record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserAchievement record ordered by the id field
        userachievement = await UserAchievement.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserAchievementUpdateInput,
        where: types.UserAchievementWhereUniqueInput,
        include: Optional[types.UserAchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserAchievement record.

        Parameters
        ----------
        data
            UserAchievement record data specifying what to update
        where
            UserAchievement filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The updated UserAchievement record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userachievement = await UserAchievement.prisma().update(
            where={
                'id': 146508610,
            },
            data={
                # data to update the UserAchievement record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserAchievementWhereUniqueInput,
        data: types.UserAchievementUpsertInput,
        include: Optional[types.UserAchievementInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserAchievement filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserAchievement model

        Returns
        -------
        prisma.models.UserAchievement
            The created or updated UserAchievement record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userachievement = await UserAchievement.prisma().upsert(
            where={
                'id': 1398052691,
            },
            data={
                'create': {
                    'id': 1398052691,
                    'userId': 1974865233,
                    'achievementId': 1949862326,
                },
                'update': {
                    'userId': 1974865233,
                    'achievementId': 1949862326,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserAchievementUpdateManyMutationInput,
        where: types.UserAchievementWhereInput,
    ) -> int:
        """Update multiple UserAchievement records

        Parameters
        ----------
        data
            UserAchievement data to update the selected UserAchievement records to
        where
            Filter to select the UserAchievement records to update

        Returns
        -------
        int
            The total number of UserAchievement records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserAchievement records
        total = await UserAchievement.prisma().update_many(
            data={
                'userId': 1582426256
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserAchievement records present in the database

        Parameters
        ----------
        select
            Select the UserAchievement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserAchievement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserAchievementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserAchievement.prisma().count()

        # results: prisma.types.UserAchievementCountAggregateOutput
        results = await UserAchievement.prisma().count(
            select={
                '_all': True,
                'achievementId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserAchievementCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
    ) -> types.UserAchievementCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserAchievementCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAchievementWhereInput] = None,
        cursor: Optional[types.UserAchievementWhereUniqueInput] = None,
    ) -> Union[int, types.UserAchievementCountAggregateOutput]:
        """Count the number of UserAchievement records present in the database

        Parameters
        ----------
        select
            Select the UserAchievement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserAchievement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserAchievementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserAchievement.prisma().count()

        # results: prisma.types.UserAchievementCountAggregateOutput
        results = await UserAchievement.prisma().count(
            select={
                '_all': True,
                'achievedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserAchievementCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserAchievementWhereInput] = None
    ) -> int:
        """Delete multiple UserAchievement records.

        Parameters
        ----------
        where
            Optional UserAchievement filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserAchievement records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserAchievement records
        total = await UserAchievement.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserAchievementScalarFieldKeys'],
        *,
        where: Optional['types.UserAchievementWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAchievementAvgAggregateInput'] = None,
        sum: Optional['types.UserAchievementSumAggregateInput'] = None,
        min: Optional['types.UserAchievementMinAggregateInput'] = None,
        max: Optional['types.UserAchievementMaxAggregateInput'] = None,
        having: Optional['types.UserAchievementScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserAchievementCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserAchievementScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserAchievementScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserAchievementGroupByOutput']:
        """Group UserAchievement records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserAchievement fields to group records by
        where
            UserAchievement filter to select records
        take
            Limit the maximum number of UserAchievement records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserAchievementGroupByOutput]
            A list of dictionaries representing the UserAchievement record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserAchievement records by id values
        # and count how many records are in each group
        results = await UserAchievement.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class auth_groupActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.auth_group]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await auth_group.prisma().query_raw(
            'SELECT * FROM auth_group WHERE id = $1',
            219944329,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.auth_group
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await auth_group.prisma().query_first(
            'SELECT * FROM auth_group WHERE name = $1',
            'dedgbbhja',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.auth_groupCreateInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> _PrismaModelT:
        """Create a new auth_group record.

        Parameters
        ----------
        data
            auth_group record data
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The created auth_group record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a auth_group record from just the required fields
        auth_group = await auth_group.prisma().create(
            data={
                # data to create a auth_group record
                'name': 'cabiahchj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.auth_groupCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple auth_group records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of auth_group record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await auth_group.prisma().create_many(
            data=[
                {
                    # data to create a auth_group record
                    'name': 'cgbeccfce',
                },
                {
                    # data to create a auth_group record
                    'name': 'fcjcagef',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.auth_groupWhereUniqueInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single auth_group record.

        Parameters
        ----------
        where
            auth_group filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The deleted auth_group record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group = await auth_group.prisma().delete(
            where={
                'id': 1637040282,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.auth_groupWhereUniqueInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique auth_group record.

        Parameters
        ----------
        where
            auth_group filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The found auth_group record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group = await auth_group.prisma().find_unique(
            where={
                'id': 2055052747,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.auth_groupWhereUniqueInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> _PrismaModelT:
        """Find a unique auth_group record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            auth_group filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The found auth_group record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group = await auth_group.prisma().find_unique_or_raise(
            where={
                'id': 59914664,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
        include: Optional[types.auth_groupInclude] = None,
        order: Optional[Union[types.auth_groupOrderByInput, List[types.auth_groupOrderByInput]]] = None,
        distinct: Optional[List[types.auth_groupScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple auth_group records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of auth_group records returned
        skip
            Ignore the first N results
        where
            auth_group filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group model
        order
            Order the returned auth_group records by any field
        distinct
            Filter auth_group records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.auth_group]
            The list of all auth_group records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 auth_group records
        auth_groups = await auth_group.prisma().find_many(take=10)

        # find the first 5 auth_group records ordered by the id field
        auth_groups = await auth_group.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
        include: Optional[types.auth_groupInclude] = None,
        order: Optional[Union[types.auth_groupOrderByInput, List[types.auth_groupOrderByInput]]] = None,
        distinct: Optional[List[types.auth_groupScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single auth_group record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_group filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group model
        order
            Order the returned auth_group records by any field
        distinct
            Filter auth_group records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_group
            The first auth_group record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_group record ordered by the name field
        auth_group = await auth_group.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
        include: Optional[types.auth_groupInclude] = None,
        order: Optional[Union[types.auth_groupOrderByInput, List[types.auth_groupOrderByInput]]] = None,
        distinct: Optional[List[types.auth_groupScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single auth_group record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_group filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group model
        order
            Order the returned auth_group records by any field
        distinct
            Filter auth_group records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_group
            The first auth_group record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_group record ordered by the id field
        auth_group = await auth_group.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.auth_groupUpdateInput,
        where: types.auth_groupWhereUniqueInput,
        include: Optional[types.auth_groupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single auth_group record.

        Parameters
        ----------
        data
            auth_group record data specifying what to update
        where
            auth_group filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The updated auth_group record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auth_group = await auth_group.prisma().update(
            where={
                'id': 1388571841,
            },
            data={
                # data to update the auth_group record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.auth_groupWhereUniqueInput,
        data: types.auth_groupUpsertInput,
        include: Optional[types.auth_groupInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            auth_group filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned auth_group model

        Returns
        -------
        prisma.models.auth_group
            The created or updated auth_group record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group = await auth_group.prisma().upsert(
            where={
                'id': 232049766,
            },
            data={
                'create': {
                    'id': 232049766,
                    'name': 'fcjcagef',
                },
                'update': {
                    'name': 'fcjcagef',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.auth_groupUpdateManyMutationInput,
        where: types.auth_groupWhereInput,
    ) -> int:
        """Update multiple auth_group records

        Parameters
        ----------
        data
            auth_group data to update the selected auth_group records to
        where
            Filter to select the auth_group records to update

        Returns
        -------
        int
            The total number of auth_group records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all auth_group records
        total = await auth_group.prisma().update_many(
            data={
                'name': 'jbijgfbfj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
    ) -> int:
        """Count the number of auth_group records present in the database

        Parameters
        ----------
        select
            Select the auth_group fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_group filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_groupCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_group.prisma().count()

        # results: prisma.types.auth_groupCountAggregateOutput
        results = await auth_group.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.auth_groupCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
    ) -> types.auth_groupCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.auth_groupCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_groupWhereInput] = None,
        cursor: Optional[types.auth_groupWhereUniqueInput] = None,
    ) -> Union[int, types.auth_groupCountAggregateOutput]:
        """Count the number of auth_group records present in the database

        Parameters
        ----------
        select
            Select the auth_group fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_group filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_groupCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_group.prisma().count()

        # results: prisma.types.auth_groupCountAggregateOutput
        results = await auth_group.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.auth_groupCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.auth_groupWhereInput] = None
    ) -> int:
        """Delete multiple auth_group records.

        Parameters
        ----------
        where
            Optional auth_group filter to find the records to be deleted

        Returns
        -------
        int
            The total number of auth_group records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all auth_group records
        total = await auth_group.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.auth_groupScalarFieldKeys'],
        *,
        where: Optional['types.auth_groupWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.auth_groupAvgAggregateInput'] = None,
        sum: Optional['types.auth_groupSumAggregateInput'] = None,
        min: Optional['types.auth_groupMinAggregateInput'] = None,
        max: Optional['types.auth_groupMaxAggregateInput'] = None,
        having: Optional['types.auth_groupScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.auth_groupCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.auth_groupScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.auth_groupScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.auth_groupGroupByOutput']:
        """Group auth_group records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar auth_group fields to group records by
        where
            auth_group filter to select records
        take
            Limit the maximum number of auth_group records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.auth_groupGroupByOutput]
            A list of dictionaries representing the auth_group record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group auth_group records by id values
        # and count how many records are in each group
        results = await auth_group.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class auth_group_permissionsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.auth_group_permissions]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await auth_group_permissions.prisma().query_raw(
            'SELECT * FROM auth_group_permissions WHERE id = $1',
            7981720560,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.auth_group_permissions
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await auth_group_permissions.prisma().query_first(
            'SELECT * FROM auth_group_permissions WHERE group_id = $1',
            39949309,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.auth_group_permissionsCreateInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> _PrismaModelT:
        """Create a new auth_group_permissions record.

        Parameters
        ----------
        data
            auth_group_permissions record data
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The created auth_group_permissions record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a auth_group_permissions record from just the required fields
        auth_group_permissions = await auth_group_permissions.prisma().create(
            data={
                # data to create a auth_group_permissions record
                'group_id': 1901152498,
                'permission_id': 1627519811,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.auth_group_permissionsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple auth_group_permissions records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of auth_group_permissions record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await auth_group_permissions.prisma().create_many(
            data=[
                {
                    # data to create a auth_group_permissions record
                    'group_id': 1094227392,
                    'permission_id': 356020985,
                },
                {
                    # data to create a auth_group_permissions record
                    'group_id': 1638335038,
                    'permission_id': 1891567775,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.auth_group_permissionsWhereUniqueInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single auth_group_permissions record.

        Parameters
        ----------
        where
            auth_group_permissions filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The deleted auth_group_permissions record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group_permissions = await auth_group_permissions.prisma().delete(
            where={
                'id': 12873344784,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.auth_group_permissionsWhereUniqueInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique auth_group_permissions record.

        Parameters
        ----------
        where
            auth_group_permissions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The found auth_group_permissions record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group_permissions = await auth_group_permissions.prisma().find_unique(
            where={
                'id': 22551938172,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.auth_group_permissionsWhereUniqueInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique auth_group_permissions record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            auth_group_permissions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The found auth_group_permissions record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group_permissions = await auth_group_permissions.prisma().find_unique_or_raise(
            where={
                'id': 18934936440,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
        include: Optional[types.auth_group_permissionsInclude] = None,
        order: Optional[Union[types.auth_group_permissionsOrderByInput, List[types.auth_group_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.auth_group_permissionsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple auth_group_permissions records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of auth_group_permissions records returned
        skip
            Ignore the first N results
        where
            auth_group_permissions filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model
        order
            Order the returned auth_group_permissions records by any field
        distinct
            Filter auth_group_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.auth_group_permissions]
            The list of all auth_group_permissions records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 auth_group_permissions records
        auth_group_permissions = await auth_group_permissions.prisma().find_many(take=10)

        # find the first 5 auth_group_permissions records ordered by the permission_id field
        auth_group_permissions = await auth_group_permissions.prisma().find_many(
            take=5,
            order={
                'permission_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
        include: Optional[types.auth_group_permissionsInclude] = None,
        order: Optional[Union[types.auth_group_permissionsOrderByInput, List[types.auth_group_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.auth_group_permissionsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single auth_group_permissions record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_group_permissions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model
        order
            Order the returned auth_group_permissions records by any field
        distinct
            Filter auth_group_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_group_permissions
            The first auth_group_permissions record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_group_permissions record ordered by the id field
        auth_group_permissions = await auth_group_permissions.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
        include: Optional[types.auth_group_permissionsInclude] = None,
        order: Optional[Union[types.auth_group_permissionsOrderByInput, List[types.auth_group_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.auth_group_permissionsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single auth_group_permissions record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_group_permissions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model
        order
            Order the returned auth_group_permissions records by any field
        distinct
            Filter auth_group_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_group_permissions
            The first auth_group_permissions record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_group_permissions record ordered by the group_id field
        auth_group_permissions = await auth_group_permissions.prisma().find_first_or_raise(
            skip=1,
            order={
                'group_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.auth_group_permissionsUpdateInput,
        where: types.auth_group_permissionsWhereUniqueInput,
        include: Optional[types.auth_group_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single auth_group_permissions record.

        Parameters
        ----------
        data
            auth_group_permissions record data specifying what to update
        where
            auth_group_permissions filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The updated auth_group_permissions record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auth_group_permissions = await auth_group_permissions.prisma().update(
            where={
                'id': 6056754372,
            },
            data={
                # data to update the auth_group_permissions record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.auth_group_permissionsWhereUniqueInput,
        data: types.auth_group_permissionsUpsertInput,
        include: Optional[types.auth_group_permissionsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            auth_group_permissions filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned auth_group_permissions model

        Returns
        -------
        prisma.models.auth_group_permissions
            The created or updated auth_group_permissions record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_group_permissions = await auth_group_permissions.prisma().upsert(
            where={
                'id': 1330141728,
            },
            data={
                'create': {
                    'id': 1330141728,
                    'group_id': 1638335038,
                    'permission_id': 1891567775,
                },
                'update': {
                    'group_id': 1638335038,
                    'permission_id': 1891567775,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.auth_group_permissionsUpdateManyMutationInput,
        where: types.auth_group_permissionsWhereInput,
    ) -> int:
        """Update multiple auth_group_permissions records

        Parameters
        ----------
        data
            auth_group_permissions data to update the selected auth_group_permissions records to
        where
            Filter to select the auth_group_permissions records to update

        Returns
        -------
        int
            The total number of auth_group_permissions records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all auth_group_permissions records
        total = await auth_group_permissions.prisma().update_many(
            data={
                'permission_id': 1300269105
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of auth_group_permissions records present in the database

        Parameters
        ----------
        select
            Select the auth_group_permissions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_group_permissions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_group_permissionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_group_permissions.prisma().count()

        # results: prisma.types.auth_group_permissionsCountAggregateOutput
        results = await auth_group_permissions.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.auth_group_permissionsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
    ) -> types.auth_group_permissionsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.auth_group_permissionsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_group_permissionsWhereInput] = None,
        cursor: Optional[types.auth_group_permissionsWhereUniqueInput] = None,
    ) -> Union[int, types.auth_group_permissionsCountAggregateOutput]:
        """Count the number of auth_group_permissions records present in the database

        Parameters
        ----------
        select
            Select the auth_group_permissions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_group_permissions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_group_permissionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_group_permissions.prisma().count()

        # results: prisma.types.auth_group_permissionsCountAggregateOutput
        results = await auth_group_permissions.prisma().count(
            select={
                '_all': True,
                'group_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.auth_group_permissionsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.auth_group_permissionsWhereInput] = None
    ) -> int:
        """Delete multiple auth_group_permissions records.

        Parameters
        ----------
        where
            Optional auth_group_permissions filter to find the records to be deleted

        Returns
        -------
        int
            The total number of auth_group_permissions records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all auth_group_permissions records
        total = await auth_group_permissions.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.auth_group_permissionsScalarFieldKeys'],
        *,
        where: Optional['types.auth_group_permissionsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.auth_group_permissionsAvgAggregateInput'] = None,
        sum: Optional['types.auth_group_permissionsSumAggregateInput'] = None,
        min: Optional['types.auth_group_permissionsMinAggregateInput'] = None,
        max: Optional['types.auth_group_permissionsMaxAggregateInput'] = None,
        having: Optional['types.auth_group_permissionsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.auth_group_permissionsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.auth_group_permissionsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.auth_group_permissionsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.auth_group_permissionsGroupByOutput']:
        """Group auth_group_permissions records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar auth_group_permissions fields to group records by
        where
            auth_group_permissions filter to select records
        take
            Limit the maximum number of auth_group_permissions records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.auth_group_permissionsGroupByOutput]
            A list of dictionaries representing the auth_group_permissions record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group auth_group_permissions records by permission_id values
        # and count how many records are in each group
        results = await auth_group_permissions.prisma().group_by(
            ['permission_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class auth_permissionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.auth_permission]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await auth_permission.prisma().query_raw(
            'SELECT * FROM auth_permission WHERE id = $1',
            1881086742,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.auth_permission
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await auth_permission.prisma().query_first(
            'SELECT * FROM auth_permission WHERE name = $1',
            'baicdfeidj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.auth_permissionCreateInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> _PrismaModelT:
        """Create a new auth_permission record.

        Parameters
        ----------
        data
            auth_permission record data
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The created auth_permission record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a auth_permission record from just the required fields
        auth_permission = await auth_permission.prisma().create(
            data={
                # data to create a auth_permission record
                'name': 'befgiciadg',
                'content_type_id': 2124707437,
                'codename': 'bcjihiaide',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.auth_permissionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple auth_permission records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of auth_permission record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await auth_permission.prisma().create_many(
            data=[
                {
                    # data to create a auth_permission record
                    'name': 'bagfijcgfj',
                    'content_type_id': 1266478832,
                    'codename': 'bjcdacgacf',
                },
                {
                    # data to create a auth_permission record
                    'name': 'jfieeahi',
                    'content_type_id': 1895913359,
                    'codename': 'cdcdjdcee',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.auth_permissionWhereUniqueInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single auth_permission record.

        Parameters
        ----------
        where
            auth_permission filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The deleted auth_permission record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_permission = await auth_permission.prisma().delete(
            where={
                'id': 1116931621,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.auth_permissionWhereUniqueInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique auth_permission record.

        Parameters
        ----------
        where
            auth_permission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The found auth_permission record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_permission = await auth_permission.prisma().find_unique(
            where={
                'id': 1243026426,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.auth_permissionWhereUniqueInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique auth_permission record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            auth_permission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The found auth_permission record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_permission = await auth_permission.prisma().find_unique_or_raise(
            where={
                'id': 21355947,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
        include: Optional[types.auth_permissionInclude] = None,
        order: Optional[Union[types.auth_permissionOrderByInput, List[types.auth_permissionOrderByInput]]] = None,
        distinct: Optional[List[types.auth_permissionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple auth_permission records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of auth_permission records returned
        skip
            Ignore the first N results
        where
            auth_permission filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_permission model
        order
            Order the returned auth_permission records by any field
        distinct
            Filter auth_permission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.auth_permission]
            The list of all auth_permission records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 auth_permission records
        auth_permissions = await auth_permission.prisma().find_many(take=10)

        # find the first 5 auth_permission records ordered by the content_type_id field
        auth_permissions = await auth_permission.prisma().find_many(
            take=5,
            order={
                'content_type_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
        include: Optional[types.auth_permissionInclude] = None,
        order: Optional[Union[types.auth_permissionOrderByInput, List[types.auth_permissionOrderByInput]]] = None,
        distinct: Optional[List[types.auth_permissionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single auth_permission record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_permission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_permission model
        order
            Order the returned auth_permission records by any field
        distinct
            Filter auth_permission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_permission
            The first auth_permission record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_permission record ordered by the codename field
        auth_permission = await auth_permission.prisma().find_first(
            skip=1,
            order={
                'codename': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
        include: Optional[types.auth_permissionInclude] = None,
        order: Optional[Union[types.auth_permissionOrderByInput, List[types.auth_permissionOrderByInput]]] = None,
        distinct: Optional[List[types.auth_permissionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single auth_permission record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            auth_permission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned auth_permission model
        order
            Order the returned auth_permission records by any field
        distinct
            Filter auth_permission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.auth_permission
            The first auth_permission record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second auth_permission record ordered by the id field
        auth_permission = await auth_permission.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.auth_permissionUpdateInput,
        where: types.auth_permissionWhereUniqueInput,
        include: Optional[types.auth_permissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single auth_permission record.

        Parameters
        ----------
        data
            auth_permission record data specifying what to update
        where
            auth_permission filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The updated auth_permission record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auth_permission = await auth_permission.prisma().update(
            where={
                'id': 831237128,
            },
            data={
                # data to update the auth_permission record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.auth_permissionWhereUniqueInput,
        data: types.auth_permissionUpsertInput,
        include: Optional[types.auth_permissionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            auth_permission filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned auth_permission model

        Returns
        -------
        prisma.models.auth_permission
            The created or updated auth_permission record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auth_permission = await auth_permission.prisma().upsert(
            where={
                'id': 1024647073,
            },
            data={
                'create': {
                    'id': 1024647073,
                    'name': 'jfieeahi',
                    'content_type_id': 1895913359,
                    'codename': 'cdcdjdcee',
                },
                'update': {
                    'name': 'jfieeahi',
                    'content_type_id': 1895913359,
                    'codename': 'cdcdjdcee',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.auth_permissionUpdateManyMutationInput,
        where: types.auth_permissionWhereInput,
    ) -> int:
        """Update multiple auth_permission records

        Parameters
        ----------
        data
            auth_permission data to update the selected auth_permission records to
        where
            Filter to select the auth_permission records to update

        Returns
        -------
        int
            The total number of auth_permission records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all auth_permission records
        total = await auth_permission.prisma().update_many(
            data={
                'name': 'ebedeihec'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of auth_permission records present in the database

        Parameters
        ----------
        select
            Select the auth_permission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_permission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_permissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_permission.prisma().count()

        # results: prisma.types.auth_permissionCountAggregateOutput
        results = await auth_permission.prisma().count(
            select={
                '_all': True,
                'content_type_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.auth_permissionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
    ) -> types.auth_permissionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.auth_permissionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.auth_permissionWhereInput] = None,
        cursor: Optional[types.auth_permissionWhereUniqueInput] = None,
    ) -> Union[int, types.auth_permissionCountAggregateOutput]:
        """Count the number of auth_permission records present in the database

        Parameters
        ----------
        select
            Select the auth_permission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            auth_permission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.auth_permissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await auth_permission.prisma().count()

        # results: prisma.types.auth_permissionCountAggregateOutput
        results = await auth_permission.prisma().count(
            select={
                '_all': True,
                'codename': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.auth_permissionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.auth_permissionWhereInput] = None
    ) -> int:
        """Delete multiple auth_permission records.

        Parameters
        ----------
        where
            Optional auth_permission filter to find the records to be deleted

        Returns
        -------
        int
            The total number of auth_permission records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all auth_permission records
        total = await auth_permission.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.auth_permissionScalarFieldKeys'],
        *,
        where: Optional['types.auth_permissionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.auth_permissionAvgAggregateInput'] = None,
        sum: Optional['types.auth_permissionSumAggregateInput'] = None,
        min: Optional['types.auth_permissionMinAggregateInput'] = None,
        max: Optional['types.auth_permissionMaxAggregateInput'] = None,
        having: Optional['types.auth_permissionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.auth_permissionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.auth_permissionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.auth_permissionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.auth_permissionGroupByOutput']:
        """Group auth_permission records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar auth_permission fields to group records by
        where
            auth_permission filter to select records
        take
            Limit the maximum number of auth_permission records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.auth_permissionGroupByOutput]
            A list of dictionaries representing the auth_permission record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group auth_permission records by id values
        # and count how many records are in each group
        results = await auth_permission.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class authtoken_tokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.authtoken_token]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await authtoken_token.prisma().query_raw(
            'SELECT * FROM authtoken_token WHERE key = $1',
            'bajagjdfbb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.authtoken_token
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await authtoken_token.prisma().query_first(
            'SELECT * FROM authtoken_token WHERE created = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.authtoken_tokenCreateInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new authtoken_token record.

        Parameters
        ----------
        data
            authtoken_token record data
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The created authtoken_token record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a authtoken_token record from just the required fields
        authtoken_token = await authtoken_token.prisma().create(
            data={
                # data to create a authtoken_token record
                'key': 'bggedbjggi',
                'created': datetime.datetime.utcnow(),
                'user_id': 9132702300,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.authtoken_tokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple authtoken_token records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of authtoken_token record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await authtoken_token.prisma().create_many(
            data=[
                {
                    # data to create a authtoken_token record
                    'key': 'bejiecfecg',
                    'created': datetime.datetime.utcnow(),
                    'user_id': 23522448804,
                },
                {
                    # data to create a authtoken_token record
                    'key': 'beeaihbefg',
                    'created': datetime.datetime.utcnow(),
                    'user_id': 18187720236,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.authtoken_tokenWhereUniqueInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single authtoken_token record.

        Parameters
        ----------
        where
            authtoken_token filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The deleted authtoken_token record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken_token = await authtoken_token.prisma().delete(
            where={
                'key': 'jbgheibja',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.authtoken_tokenWhereUniqueInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique authtoken_token record.

        Parameters
        ----------
        where
            authtoken_token filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The found authtoken_token record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken_token = await authtoken_token.prisma().find_unique(
            where={
                'key': 'eejajbid',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.authtoken_tokenWhereUniqueInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique authtoken_token record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            authtoken_token filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The found authtoken_token record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken_token = await authtoken_token.prisma().find_unique_or_raise(
            where={
                'key': 'efhdcdaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
        include: Optional[types.authtoken_tokenInclude] = None,
        order: Optional[Union[types.authtoken_tokenOrderByInput, List[types.authtoken_tokenOrderByInput]]] = None,
        distinct: Optional[List[types.authtoken_tokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple authtoken_token records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of authtoken_token records returned
        skip
            Ignore the first N results
        where
            authtoken_token filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned authtoken_token model
        order
            Order the returned authtoken_token records by any field
        distinct
            Filter authtoken_token records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.authtoken_token]
            The list of all authtoken_token records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 authtoken_token records
        authtoken_tokens = await authtoken_token.prisma().find_many(take=10)

        # find the first 5 authtoken_token records ordered by the user_id field
        authtoken_tokens = await authtoken_token.prisma().find_many(
            take=5,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
        include: Optional[types.authtoken_tokenInclude] = None,
        order: Optional[Union[types.authtoken_tokenOrderByInput, List[types.authtoken_tokenOrderByInput]]] = None,
        distinct: Optional[List[types.authtoken_tokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single authtoken_token record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            authtoken_token filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned authtoken_token model
        order
            Order the returned authtoken_token records by any field
        distinct
            Filter authtoken_token records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.authtoken_token
            The first authtoken_token record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second authtoken_token record ordered by the key field
        authtoken_token = await authtoken_token.prisma().find_first(
            skip=1,
            order={
                'key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
        include: Optional[types.authtoken_tokenInclude] = None,
        order: Optional[Union[types.authtoken_tokenOrderByInput, List[types.authtoken_tokenOrderByInput]]] = None,
        distinct: Optional[List[types.authtoken_tokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single authtoken_token record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            authtoken_token filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned authtoken_token model
        order
            Order the returned authtoken_token records by any field
        distinct
            Filter authtoken_token records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.authtoken_token
            The first authtoken_token record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second authtoken_token record ordered by the created field
        authtoken_token = await authtoken_token.prisma().find_first_or_raise(
            skip=1,
            order={
                'created': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.authtoken_tokenUpdateInput,
        where: types.authtoken_tokenWhereUniqueInput,
        include: Optional[types.authtoken_tokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single authtoken_token record.

        Parameters
        ----------
        data
            authtoken_token record data specifying what to update
        where
            authtoken_token filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The updated authtoken_token record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        authtoken_token = await authtoken_token.prisma().update(
            where={
                'key': 'cadejecgbd',
            },
            data={
                # data to update the authtoken_token record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.authtoken_tokenWhereUniqueInput,
        data: types.authtoken_tokenUpsertInput,
        include: Optional[types.authtoken_tokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            authtoken_token filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned authtoken_token model

        Returns
        -------
        prisma.models.authtoken_token
            The created or updated authtoken_token record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        authtoken_token = await authtoken_token.prisma().upsert(
            where={
                'key': 'bahjhjjhcc',
            },
            data={
                'create': {
                    'key': 'bahjhjjhcc',
                    'created': datetime.datetime.utcnow(),
                    'user_id': 18187720236,
                },
                'update': {
                    'created': datetime.datetime.utcnow(),
                    'user_id': 18187720236,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.authtoken_tokenUpdateManyMutationInput,
        where: types.authtoken_tokenWhereInput,
    ) -> int:
        """Update multiple authtoken_token records

        Parameters
        ----------
        data
            authtoken_token data to update the selected authtoken_token records to
        where
            Filter to select the authtoken_token records to update

        Returns
        -------
        int
            The total number of authtoken_token records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all authtoken_token records
        total = await authtoken_token.prisma().update_many(
            data={
                'user_id': 5006056260
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of authtoken_token records present in the database

        Parameters
        ----------
        select
            Select the authtoken_token fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            authtoken_token filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.authtoken_tokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await authtoken_token.prisma().count()

        # results: prisma.types.authtoken_tokenCountAggregateOutput
        results = await authtoken_token.prisma().count(
            select={
                '_all': True,
                'key': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.authtoken_tokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
    ) -> types.authtoken_tokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.authtoken_tokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.authtoken_tokenWhereInput] = None,
        cursor: Optional[types.authtoken_tokenWhereUniqueInput] = None,
    ) -> Union[int, types.authtoken_tokenCountAggregateOutput]:
        """Count the number of authtoken_token records present in the database

        Parameters
        ----------
        select
            Select the authtoken_token fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            authtoken_token filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.authtoken_tokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await authtoken_token.prisma().count()

        # results: prisma.types.authtoken_tokenCountAggregateOutput
        results = await authtoken_token.prisma().count(
            select={
                '_all': True,
                'created': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.authtoken_tokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.authtoken_tokenWhereInput] = None
    ) -> int:
        """Delete multiple authtoken_token records.

        Parameters
        ----------
        where
            Optional authtoken_token filter to find the records to be deleted

        Returns
        -------
        int
            The total number of authtoken_token records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all authtoken_token records
        total = await authtoken_token.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.authtoken_tokenScalarFieldKeys'],
        *,
        where: Optional['types.authtoken_tokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.authtoken_tokenAvgAggregateInput'] = None,
        sum: Optional['types.authtoken_tokenSumAggregateInput'] = None,
        min: Optional['types.authtoken_tokenMinAggregateInput'] = None,
        max: Optional['types.authtoken_tokenMaxAggregateInput'] = None,
        having: Optional['types.authtoken_tokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.authtoken_tokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.authtoken_tokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.authtoken_tokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.authtoken_tokenGroupByOutput']:
        """Group authtoken_token records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar authtoken_token fields to group records by
        where
            authtoken_token filter to select records
        take
            Limit the maximum number of authtoken_token records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.authtoken_tokenGroupByOutput]
            A list of dictionaries representing the authtoken_token record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group authtoken_token records by user_id values
        # and count how many records are in each group
        results = await authtoken_token.prisma().group_by(
            ['user_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class django_admin_logActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.django_admin_log]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await django_admin_log.prisma().query_raw(
            'SELECT * FROM django_admin_log WHERE id = $1',
            1384523576,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.django_admin_log
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await django_admin_log.prisma().query_first(
            'SELECT * FROM django_admin_log WHERE action_time = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.django_admin_logCreateInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> _PrismaModelT:
        """Create a new django_admin_log record.

        Parameters
        ----------
        data
            django_admin_log record data
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The created django_admin_log record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a django_admin_log record from just the required fields
        django_admin_log = await django_admin_log.prisma().create(
            data={
                # data to create a django_admin_log record
                'action_time': datetime.datetime.utcnow(),
                'object_repr': 'cheifeghd',
                'action_flag': 568974454,
                'change_message': 'hcbgbhfch',
                'user_id': 18133938864,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.django_admin_logCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple django_admin_log records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of django_admin_log record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await django_admin_log.prisma().create_many(
            data=[
                {
                    # data to create a django_admin_log record
                    'action_time': datetime.datetime.utcnow(),
                    'object_repr': 'ibijjdeb',
                    'action_flag': 2047822338,
                    'change_message': 'bgcahjbafj',
                    'user_id': 22531784640,
                },
                {
                    # data to create a django_admin_log record
                    'action_time': datetime.datetime.utcnow(),
                    'object_repr': 'bdgbfahbef',
                    'action_flag': 522978382,
                    'change_message': 'bdgfdgdaff',
                    'user_id': 21916896720,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.django_admin_logWhereUniqueInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single django_admin_log record.

        Parameters
        ----------
        where
            django_admin_log filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The deleted django_admin_log record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_admin_log = await django_admin_log.prisma().delete(
            where={
                'id': 509770501,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.django_admin_logWhereUniqueInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique django_admin_log record.

        Parameters
        ----------
        where
            django_admin_log filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The found django_admin_log record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_admin_log = await django_admin_log.prisma().find_unique(
            where={
                'id': 1548228442,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.django_admin_logWhereUniqueInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> _PrismaModelT:
        """Find a unique django_admin_log record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            django_admin_log filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The found django_admin_log record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_admin_log = await django_admin_log.prisma().find_unique_or_raise(
            where={
                'id': 728468875,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
        include: Optional[types.django_admin_logInclude] = None,
        order: Optional[Union[types.django_admin_logOrderByInput, List[types.django_admin_logOrderByInput]]] = None,
        distinct: Optional[List[types.django_admin_logScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple django_admin_log records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of django_admin_log records returned
        skip
            Ignore the first N results
        where
            django_admin_log filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_admin_log model
        order
            Order the returned django_admin_log records by any field
        distinct
            Filter django_admin_log records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.django_admin_log]
            The list of all django_admin_log records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 django_admin_log records
        django_admin_logs = await django_admin_log.prisma().find_many(take=10)

        # find the first 5 django_admin_log records ordered by the object_id field
        django_admin_logs = await django_admin_log.prisma().find_many(
            take=5,
            order={
                'object_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
        include: Optional[types.django_admin_logInclude] = None,
        order: Optional[Union[types.django_admin_logOrderByInput, List[types.django_admin_logOrderByInput]]] = None,
        distinct: Optional[List[types.django_admin_logScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single django_admin_log record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_admin_log filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_admin_log model
        order
            Order the returned django_admin_log records by any field
        distinct
            Filter django_admin_log records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_admin_log
            The first django_admin_log record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_admin_log record ordered by the object_repr field
        django_admin_log = await django_admin_log.prisma().find_first(
            skip=1,
            order={
                'object_repr': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
        include: Optional[types.django_admin_logInclude] = None,
        order: Optional[Union[types.django_admin_logOrderByInput, List[types.django_admin_logOrderByInput]]] = None,
        distinct: Optional[List[types.django_admin_logScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single django_admin_log record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_admin_log filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_admin_log model
        order
            Order the returned django_admin_log records by any field
        distinct
            Filter django_admin_log records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_admin_log
            The first django_admin_log record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_admin_log record ordered by the action_flag field
        django_admin_log = await django_admin_log.prisma().find_first_or_raise(
            skip=1,
            order={
                'action_flag': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.django_admin_logUpdateInput,
        where: types.django_admin_logWhereUniqueInput,
        include: Optional[types.django_admin_logInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single django_admin_log record.

        Parameters
        ----------
        data
            django_admin_log record data specifying what to update
        where
            django_admin_log filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The updated django_admin_log record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        django_admin_log = await django_admin_log.prisma().update(
            where={
                'id': 107859560,
            },
            data={
                # data to update the django_admin_log record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.django_admin_logWhereUniqueInput,
        data: types.django_admin_logUpsertInput,
        include: Optional[types.django_admin_logInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            django_admin_log filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned django_admin_log model

        Returns
        -------
        prisma.models.django_admin_log
            The created or updated django_admin_log record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_admin_log = await django_admin_log.prisma().upsert(
            where={
                'id': 1041547905,
            },
            data={
                'create': {
                    'id': 1041547905,
                    'action_time': datetime.datetime.utcnow(),
                    'object_repr': 'bdgbfahbef',
                    'action_flag': 522978382,
                    'change_message': 'bdgfdgdaff',
                    'user_id': 21916896720,
                },
                'update': {
                    'action_time': datetime.datetime.utcnow(),
                    'object_repr': 'bdgbfahbef',
                    'action_flag': 522978382,
                    'change_message': 'bdgfdgdaff',
                    'user_id': 21916896720,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.django_admin_logUpdateManyMutationInput,
        where: types.django_admin_logWhereInput,
    ) -> int:
        """Update multiple django_admin_log records

        Parameters
        ----------
        data
            django_admin_log data to update the selected django_admin_log records to
        where
            Filter to select the django_admin_log records to update

        Returns
        -------
        int
            The total number of django_admin_log records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all django_admin_log records
        total = await django_admin_log.prisma().update_many(
            data={
                'change_message': 'bjchdacjfa'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
    ) -> int:
        """Count the number of django_admin_log records present in the database

        Parameters
        ----------
        select
            Select the django_admin_log fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_admin_log filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_admin_logCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_admin_log.prisma().count()

        # results: prisma.types.django_admin_logCountAggregateOutput
        results = await django_admin_log.prisma().count(
            select={
                '_all': True,
                'content_type_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.django_admin_logCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
    ) -> types.django_admin_logCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.django_admin_logCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_admin_logWhereInput] = None,
        cursor: Optional[types.django_admin_logWhereUniqueInput] = None,
    ) -> Union[int, types.django_admin_logCountAggregateOutput]:
        """Count the number of django_admin_log records present in the database

        Parameters
        ----------
        select
            Select the django_admin_log fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_admin_log filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_admin_logCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_admin_log.prisma().count()

        # results: prisma.types.django_admin_logCountAggregateOutput
        results = await django_admin_log.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.django_admin_logCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.django_admin_logWhereInput] = None
    ) -> int:
        """Delete multiple django_admin_log records.

        Parameters
        ----------
        where
            Optional django_admin_log filter to find the records to be deleted

        Returns
        -------
        int
            The total number of django_admin_log records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all django_admin_log records
        total = await django_admin_log.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.django_admin_logScalarFieldKeys'],
        *,
        where: Optional['types.django_admin_logWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.django_admin_logAvgAggregateInput'] = None,
        sum: Optional['types.django_admin_logSumAggregateInput'] = None,
        min: Optional['types.django_admin_logMinAggregateInput'] = None,
        max: Optional['types.django_admin_logMaxAggregateInput'] = None,
        having: Optional['types.django_admin_logScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.django_admin_logCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.django_admin_logScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.django_admin_logScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.django_admin_logGroupByOutput']:
        """Group django_admin_log records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar django_admin_log fields to group records by
        where
            django_admin_log filter to select records
        take
            Limit the maximum number of django_admin_log records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.django_admin_logGroupByOutput]
            A list of dictionaries representing the django_admin_log record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group django_admin_log records by id values
        # and count how many records are in each group
        results = await django_admin_log.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class django_content_typeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.django_content_type]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await django_content_type.prisma().query_raw(
            'SELECT * FROM django_content_type WHERE id = $1',
            520320871,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.django_content_type
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await django_content_type.prisma().query_first(
            'SELECT * FROM django_content_type WHERE app_label = $1',
            'bbdcibggga',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.django_content_typeCreateInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> _PrismaModelT:
        """Create a new django_content_type record.

        Parameters
        ----------
        data
            django_content_type record data
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The created django_content_type record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a django_content_type record from just the required fields
        django_content_type = await django_content_type.prisma().create(
            data={
                # data to create a django_content_type record
                'app_label': 'bagbibfheb',
                'model': 'bidgcabjag',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.django_content_typeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple django_content_type records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of django_content_type record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await django_content_type.prisma().create_many(
            data=[
                {
                    # data to create a django_content_type record
                    'app_label': 'hechjdjih',
                    'model': 'cgfjefhci',
                },
                {
                    # data to create a django_content_type record
                    'app_label': 'egcidbiab',
                    'model': 'cehjjfgeg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.django_content_typeWhereUniqueInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single django_content_type record.

        Parameters
        ----------
        where
            django_content_type filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The deleted django_content_type record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_content_type = await django_content_type.prisma().delete(
            where={
                'id': 780004447,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.django_content_typeWhereUniqueInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique django_content_type record.

        Parameters
        ----------
        where
            django_content_type filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The found django_content_type record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_content_type = await django_content_type.prisma().find_unique(
            where={
                'id': 438093484,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.django_content_typeWhereUniqueInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique django_content_type record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            django_content_type filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The found django_content_type record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_content_type = await django_content_type.prisma().find_unique_or_raise(
            where={
                'id': 936456053,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
        include: Optional[types.django_content_typeInclude] = None,
        order: Optional[Union[types.django_content_typeOrderByInput, List[types.django_content_typeOrderByInput]]] = None,
        distinct: Optional[List[types.django_content_typeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple django_content_type records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of django_content_type records returned
        skip
            Ignore the first N results
        where
            django_content_type filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_content_type model
        order
            Order the returned django_content_type records by any field
        distinct
            Filter django_content_type records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.django_content_type]
            The list of all django_content_type records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 django_content_type records
        django_content_types = await django_content_type.prisma().find_many(take=10)

        # find the first 5 django_content_type records ordered by the model field
        django_content_types = await django_content_type.prisma().find_many(
            take=5,
            order={
                'model': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
        include: Optional[types.django_content_typeInclude] = None,
        order: Optional[Union[types.django_content_typeOrderByInput, List[types.django_content_typeOrderByInput]]] = None,
        distinct: Optional[List[types.django_content_typeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single django_content_type record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_content_type filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_content_type model
        order
            Order the returned django_content_type records by any field
        distinct
            Filter django_content_type records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_content_type
            The first django_content_type record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_content_type record ordered by the id field
        django_content_type = await django_content_type.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
        include: Optional[types.django_content_typeInclude] = None,
        order: Optional[Union[types.django_content_typeOrderByInput, List[types.django_content_typeOrderByInput]]] = None,
        distinct: Optional[List[types.django_content_typeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single django_content_type record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_content_type filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_content_type model
        order
            Order the returned django_content_type records by any field
        distinct
            Filter django_content_type records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_content_type
            The first django_content_type record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_content_type record ordered by the app_label field
        django_content_type = await django_content_type.prisma().find_first_or_raise(
            skip=1,
            order={
                'app_label': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.django_content_typeUpdateInput,
        where: types.django_content_typeWhereUniqueInput,
        include: Optional[types.django_content_typeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single django_content_type record.

        Parameters
        ----------
        data
            django_content_type record data specifying what to update
        where
            django_content_type filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The updated django_content_type record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        django_content_type = await django_content_type.prisma().update(
            where={
                'id': 1778715402,
            },
            data={
                # data to update the django_content_type record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.django_content_typeWhereUniqueInput,
        data: types.django_content_typeUpsertInput,
        include: Optional[types.django_content_typeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            django_content_type filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned django_content_type model

        Returns
        -------
        prisma.models.django_content_type
            The created or updated django_content_type record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_content_type = await django_content_type.prisma().upsert(
            where={
                'id': 1094643579,
            },
            data={
                'create': {
                    'id': 1094643579,
                    'app_label': 'egcidbiab',
                    'model': 'cehjjfgeg',
                },
                'update': {
                    'app_label': 'egcidbiab',
                    'model': 'cehjjfgeg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.django_content_typeUpdateManyMutationInput,
        where: types.django_content_typeWhereInput,
    ) -> int:
        """Update multiple django_content_type records

        Parameters
        ----------
        data
            django_content_type data to update the selected django_content_type records to
        where
            Filter to select the django_content_type records to update

        Returns
        -------
        int
            The total number of django_content_type records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all django_content_type records
        total = await django_content_type.prisma().update_many(
            data={
                'model': 'bhfjihjfhg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of django_content_type records present in the database

        Parameters
        ----------
        select
            Select the django_content_type fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_content_type filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_content_typeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_content_type.prisma().count()

        # results: prisma.types.django_content_typeCountAggregateOutput
        results = await django_content_type.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.django_content_typeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
    ) -> types.django_content_typeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.django_content_typeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_content_typeWhereInput] = None,
        cursor: Optional[types.django_content_typeWhereUniqueInput] = None,
    ) -> Union[int, types.django_content_typeCountAggregateOutput]:
        """Count the number of django_content_type records present in the database

        Parameters
        ----------
        select
            Select the django_content_type fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_content_type filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_content_typeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_content_type.prisma().count()

        # results: prisma.types.django_content_typeCountAggregateOutput
        results = await django_content_type.prisma().count(
            select={
                '_all': True,
                'app_label': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.django_content_typeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.django_content_typeWhereInput] = None
    ) -> int:
        """Delete multiple django_content_type records.

        Parameters
        ----------
        where
            Optional django_content_type filter to find the records to be deleted

        Returns
        -------
        int
            The total number of django_content_type records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all django_content_type records
        total = await django_content_type.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.django_content_typeScalarFieldKeys'],
        *,
        where: Optional['types.django_content_typeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.django_content_typeAvgAggregateInput'] = None,
        sum: Optional['types.django_content_typeSumAggregateInput'] = None,
        min: Optional['types.django_content_typeMinAggregateInput'] = None,
        max: Optional['types.django_content_typeMaxAggregateInput'] = None,
        having: Optional['types.django_content_typeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.django_content_typeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.django_content_typeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.django_content_typeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.django_content_typeGroupByOutput']:
        """Group django_content_type records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar django_content_type fields to group records by
        where
            django_content_type filter to select records
        take
            Limit the maximum number of django_content_type records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.django_content_typeGroupByOutput]
            A list of dictionaries representing the django_content_type record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group django_content_type records by model values
        # and count how many records are in each group
        results = await django_content_type.prisma().group_by(
            ['model'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class django_migrationsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.django_migrations]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await django_migrations.prisma().query_raw(
            'SELECT * FROM django_migrations WHERE id = $1',
            10584041292,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.django_migrations
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await django_migrations.prisma().query_first(
            'SELECT * FROM django_migrations WHERE app = $1',
            'bigjggdhac',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.django_migrationsCreateInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> _PrismaModelT:
        """Create a new django_migrations record.

        Parameters
        ----------
        data
            django_migrations record data
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The created django_migrations record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a django_migrations record from just the required fields
        django_migrations = await django_migrations.prisma().create(
            data={
                # data to create a django_migrations record
                'app': 'bfdbbbjhad',
                'name': 'bdibjhdici',
                'applied': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.django_migrationsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple django_migrations records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of django_migrations record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await django_migrations.prisma().create_many(
            data=[
                {
                    # data to create a django_migrations record
                    'app': 'bceigehcbd',
                    'name': 'caehahihfe',
                    'applied': datetime.datetime.utcnow(),
                },
                {
                    # data to create a django_migrations record
                    'app': 'jjacdhech',
                    'name': 'bbbjadabjc',
                    'applied': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.django_migrationsWhereUniqueInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single django_migrations record.

        Parameters
        ----------
        where
            django_migrations filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The deleted django_migrations record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_migrations = await django_migrations.prisma().delete(
            where={
                'id': 9245129196,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.django_migrationsWhereUniqueInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique django_migrations record.

        Parameters
        ----------
        where
            django_migrations filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The found django_migrations record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_migrations = await django_migrations.prisma().find_unique(
            where={
                'id': 8395756584,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.django_migrationsWhereUniqueInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique django_migrations record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            django_migrations filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The found django_migrations record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_migrations = await django_migrations.prisma().find_unique_or_raise(
            where={
                'id': 227018676,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
        include: Optional[types.django_migrationsInclude] = None,
        order: Optional[Union[types.django_migrationsOrderByInput, List[types.django_migrationsOrderByInput]]] = None,
        distinct: Optional[List[types.django_migrationsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple django_migrations records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of django_migrations records returned
        skip
            Ignore the first N results
        where
            django_migrations filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_migrations model
        order
            Order the returned django_migrations records by any field
        distinct
            Filter django_migrations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.django_migrations]
            The list of all django_migrations records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 django_migrations records
        django_migrations = await django_migrations.prisma().find_many(take=10)

        # find the first 5 django_migrations records ordered by the name field
        django_migrations = await django_migrations.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
        include: Optional[types.django_migrationsInclude] = None,
        order: Optional[Union[types.django_migrationsOrderByInput, List[types.django_migrationsOrderByInput]]] = None,
        distinct: Optional[List[types.django_migrationsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single django_migrations record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_migrations filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_migrations model
        order
            Order the returned django_migrations records by any field
        distinct
            Filter django_migrations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_migrations
            The first django_migrations record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_migrations record ordered by the applied field
        django_migrations = await django_migrations.prisma().find_first(
            skip=1,
            order={
                'applied': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
        include: Optional[types.django_migrationsInclude] = None,
        order: Optional[Union[types.django_migrationsOrderByInput, List[types.django_migrationsOrderByInput]]] = None,
        distinct: Optional[List[types.django_migrationsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single django_migrations record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_migrations filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_migrations model
        order
            Order the returned django_migrations records by any field
        distinct
            Filter django_migrations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_migrations
            The first django_migrations record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_migrations record ordered by the id field
        django_migrations = await django_migrations.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.django_migrationsUpdateInput,
        where: types.django_migrationsWhereUniqueInput,
        include: Optional[types.django_migrationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single django_migrations record.

        Parameters
        ----------
        data
            django_migrations record data specifying what to update
        where
            django_migrations filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The updated django_migrations record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        django_migrations = await django_migrations.prisma().update(
            where={
                'id': 25207661136,
            },
            data={
                # data to update the django_migrations record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.django_migrationsWhereUniqueInput,
        data: types.django_migrationsUpsertInput,
        include: Optional[types.django_migrationsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            django_migrations filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned django_migrations model

        Returns
        -------
        prisma.models.django_migrations
            The created or updated django_migrations record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_migrations = await django_migrations.prisma().upsert(
            where={
                'id': 11134205628,
            },
            data={
                'create': {
                    'id': 11134205628,
                    'app': 'jjacdhech',
                    'name': 'bbbjadabjc',
                    'applied': datetime.datetime.utcnow(),
                },
                'update': {
                    'app': 'jjacdhech',
                    'name': 'bbbjadabjc',
                    'applied': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.django_migrationsUpdateManyMutationInput,
        where: types.django_migrationsWhereInput,
    ) -> int:
        """Update multiple django_migrations records

        Parameters
        ----------
        data
            django_migrations data to update the selected django_migrations records to
        where
            Filter to select the django_migrations records to update

        Returns
        -------
        int
            The total number of django_migrations records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all django_migrations records
        total = await django_migrations.prisma().update_many(
            data={
                'app': 'dhhdhfebi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of django_migrations records present in the database

        Parameters
        ----------
        select
            Select the django_migrations fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_migrations filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_migrationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_migrations.prisma().count()

        # results: prisma.types.django_migrationsCountAggregateOutput
        results = await django_migrations.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.django_migrationsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
    ) -> types.django_migrationsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.django_migrationsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_migrationsWhereInput] = None,
        cursor: Optional[types.django_migrationsWhereUniqueInput] = None,
    ) -> Union[int, types.django_migrationsCountAggregateOutput]:
        """Count the number of django_migrations records present in the database

        Parameters
        ----------
        select
            Select the django_migrations fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_migrations filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_migrationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_migrations.prisma().count()

        # results: prisma.types.django_migrationsCountAggregateOutput
        results = await django_migrations.prisma().count(
            select={
                '_all': True,
                'applied': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.django_migrationsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.django_migrationsWhereInput] = None
    ) -> int:
        """Delete multiple django_migrations records.

        Parameters
        ----------
        where
            Optional django_migrations filter to find the records to be deleted

        Returns
        -------
        int
            The total number of django_migrations records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all django_migrations records
        total = await django_migrations.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.django_migrationsScalarFieldKeys'],
        *,
        where: Optional['types.django_migrationsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.django_migrationsAvgAggregateInput'] = None,
        sum: Optional['types.django_migrationsSumAggregateInput'] = None,
        min: Optional['types.django_migrationsMinAggregateInput'] = None,
        max: Optional['types.django_migrationsMaxAggregateInput'] = None,
        having: Optional['types.django_migrationsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.django_migrationsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.django_migrationsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.django_migrationsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.django_migrationsGroupByOutput']:
        """Group django_migrations records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar django_migrations fields to group records by
        where
            django_migrations filter to select records
        take
            Limit the maximum number of django_migrations records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.django_migrationsGroupByOutput]
            A list of dictionaries representing the django_migrations record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group django_migrations records by id values
        # and count how many records are in each group
        results = await django_migrations.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class django_sessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.django_session]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await django_session.prisma().query_raw(
            'SELECT * FROM django_session WHERE session_key = $1',
            'decchddih',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.django_session
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await django_session.prisma().query_first(
            'SELECT * FROM django_session WHERE session_data = $1',
            'bbegbdehci',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.django_sessionCreateInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new django_session record.

        Parameters
        ----------
        data
            django_session record data
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The created django_session record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a django_session record from just the required fields
        django_session = await django_session.prisma().create(
            data={
                # data to create a django_session record
                'session_key': 'bcebgbhhgb',
                'session_data': 'ghegfaceg',
                'expire_date': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.django_sessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple django_session records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of django_session record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await django_session.prisma().create_many(
            data=[
                {
                    # data to create a django_session record
                    'session_key': 'hdeaejgah',
                    'session_data': 'ddiiihaci',
                    'expire_date': datetime.datetime.utcnow(),
                },
                {
                    # data to create a django_session record
                    'session_key': 'jdhfacdgf',
                    'session_data': 'fcbbahcbi',
                    'expire_date': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.django_sessionWhereUniqueInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single django_session record.

        Parameters
        ----------
        where
            django_session filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The deleted django_session record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_session = await django_session.prisma().delete(
            where={
                'session_key': 'edcgchech',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.django_sessionWhereUniqueInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique django_session record.

        Parameters
        ----------
        where
            django_session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The found django_session record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_session = await django_session.prisma().find_unique(
            where={
                'session_key': 'bfehccdcge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.django_sessionWhereUniqueInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique django_session record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            django_session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The found django_session record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_session = await django_session.prisma().find_unique_or_raise(
            where={
                'session_key': 'ehcibdegf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
        include: Optional[types.django_sessionInclude] = None,
        order: Optional[Union[types.django_sessionOrderByInput, List[types.django_sessionOrderByInput]]] = None,
        distinct: Optional[List[types.django_sessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple django_session records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of django_session records returned
        skip
            Ignore the first N results
        where
            django_session filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_session model
        order
            Order the returned django_session records by any field
        distinct
            Filter django_session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.django_session]
            The list of all django_session records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 django_session records
        django_sessions = await django_session.prisma().find_many(take=10)

        # find the first 5 django_session records ordered by the expire_date field
        django_sessions = await django_session.prisma().find_many(
            take=5,
            order={
                'expire_date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
        include: Optional[types.django_sessionInclude] = None,
        order: Optional[Union[types.django_sessionOrderByInput, List[types.django_sessionOrderByInput]]] = None,
        distinct: Optional[List[types.django_sessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single django_session record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_session model
        order
            Order the returned django_session records by any field
        distinct
            Filter django_session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_session
            The first django_session record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_session record ordered by the session_key field
        django_session = await django_session.prisma().find_first(
            skip=1,
            order={
                'session_key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
        include: Optional[types.django_sessionInclude] = None,
        order: Optional[Union[types.django_sessionOrderByInput, List[types.django_sessionOrderByInput]]] = None,
        distinct: Optional[List[types.django_sessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single django_session record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            django_session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned django_session model
        order
            Order the returned django_session records by any field
        distinct
            Filter django_session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.django_session
            The first django_session record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second django_session record ordered by the session_data field
        django_session = await django_session.prisma().find_first_or_raise(
            skip=1,
            order={
                'session_data': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.django_sessionUpdateInput,
        where: types.django_sessionWhereUniqueInput,
        include: Optional[types.django_sessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single django_session record.

        Parameters
        ----------
        data
            django_session record data specifying what to update
        where
            django_session filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The updated django_session record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        django_session = await django_session.prisma().update(
            where={
                'session_key': 'ebhjifbbi',
            },
            data={
                # data to update the django_session record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.django_sessionWhereUniqueInput,
        data: types.django_sessionUpsertInput,
        include: Optional[types.django_sessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            django_session filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned django_session model

        Returns
        -------
        prisma.models.django_session
            The created or updated django_session record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        django_session = await django_session.prisma().upsert(
            where={
                'session_key': 'jaigficdj',
            },
            data={
                'create': {
                    'session_key': 'jaigficdj',
                    'session_data': 'fcbbahcbi',
                    'expire_date': datetime.datetime.utcnow(),
                },
                'update': {
                    'session_data': 'fcbbahcbi',
                    'expire_date': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.django_sessionUpdateManyMutationInput,
        where: types.django_sessionWhereInput,
    ) -> int:
        """Update multiple django_session records

        Parameters
        ----------
        data
            django_session data to update the selected django_session records to
        where
            Filter to select the django_session records to update

        Returns
        -------
        int
            The total number of django_session records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all django_session records
        total = await django_session.prisma().update_many(
            data={
                'expire_date': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of django_session records present in the database

        Parameters
        ----------
        select
            Select the django_session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_sessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_session.prisma().count()

        # results: prisma.types.django_sessionCountAggregateOutput
        results = await django_session.prisma().count(
            select={
                '_all': True,
                'session_key': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.django_sessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
    ) -> types.django_sessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.django_sessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.django_sessionWhereInput] = None,
        cursor: Optional[types.django_sessionWhereUniqueInput] = None,
    ) -> Union[int, types.django_sessionCountAggregateOutput]:
        """Count the number of django_session records present in the database

        Parameters
        ----------
        select
            Select the django_session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            django_session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.django_sessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await django_session.prisma().count()

        # results: prisma.types.django_sessionCountAggregateOutput
        results = await django_session.prisma().count(
            select={
                '_all': True,
                'session_data': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.django_sessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.django_sessionWhereInput] = None
    ) -> int:
        """Delete multiple django_session records.

        Parameters
        ----------
        where
            Optional django_session filter to find the records to be deleted

        Returns
        -------
        int
            The total number of django_session records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all django_session records
        total = await django_session.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.django_sessionScalarFieldKeys'],
        *,
        where: Optional['types.django_sessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.django_sessionAvgAggregateInput'] = None,
        sum: Optional['types.django_sessionSumAggregateInput'] = None,
        min: Optional['types.django_sessionMinAggregateInput'] = None,
        max: Optional['types.django_sessionMaxAggregateInput'] = None,
        having: Optional['types.django_sessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.django_sessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.django_sessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.django_sessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.django_sessionGroupByOutput']:
        """Group django_session records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar django_session fields to group records by
        where
            django_session filter to select records
        take
            Limit the maximum number of django_session records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.django_sessionGroupByOutput]
            A list of dictionaries representing the django_session record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group django_session records by expire_date values
        # and count how many records are in each group
        results = await django_session.prisma().group_by(
            ['expire_date'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class token_blacklist_blacklistedtokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.token_blacklist_blacklistedtoken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await token_blacklist_blacklistedtoken.prisma().query_raw(
            'SELECT * FROM token_blacklist_blacklistedtoken WHERE id = $1',
            19951027344,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await token_blacklist_blacklistedtoken.prisma().query_first(
            'SELECT * FROM token_blacklist_blacklistedtoken WHERE blacklisted_at = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.token_blacklist_blacklistedtokenCreateInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new token_blacklist_blacklistedtoken record.

        Parameters
        ----------
        data
            token_blacklist_blacklistedtoken record data
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The created token_blacklist_blacklistedtoken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a token_blacklist_blacklistedtoken record from just the required fields
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().create(
            data={
                # data to create a token_blacklist_blacklistedtoken record
                'blacklisted_at': datetime.datetime.utcnow(),
                'token_id': 21403177980,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.token_blacklist_blacklistedtokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple token_blacklist_blacklistedtoken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of token_blacklist_blacklistedtoken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await token_blacklist_blacklistedtoken.prisma().create_many(
            data=[
                {
                    # data to create a token_blacklist_blacklistedtoken record
                    'blacklisted_at': datetime.datetime.utcnow(),
                    'token_id': 6315707640,
                },
                {
                    # data to create a token_blacklist_blacklistedtoken record
                    'blacklisted_at': datetime.datetime.utcnow(),
                    'token_id': 139810884,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single token_blacklist_blacklistedtoken record.

        Parameters
        ----------
        where
            token_blacklist_blacklistedtoken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The deleted token_blacklist_blacklistedtoken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().delete(
            where={
                'id': 13251219360,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique token_blacklist_blacklistedtoken record.

        Parameters
        ----------
        where
            token_blacklist_blacklistedtoken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The found token_blacklist_blacklistedtoken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().find_unique(
            where={
                'id': 8916249036,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique token_blacklist_blacklistedtoken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            token_blacklist_blacklistedtoken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The found token_blacklist_blacklistedtoken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().find_unique_or_raise(
            where={
                'id': 2123314824,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_blacklistedtokenOrderByInput, List[types.token_blacklist_blacklistedtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_blacklistedtokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple token_blacklist_blacklistedtoken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of token_blacklist_blacklistedtoken records returned
        skip
            Ignore the first N results
        where
            token_blacklist_blacklistedtoken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model
        order
            Order the returned token_blacklist_blacklistedtoken records by any field
        distinct
            Filter token_blacklist_blacklistedtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.token_blacklist_blacklistedtoken]
            The list of all token_blacklist_blacklistedtoken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 token_blacklist_blacklistedtoken records
        token_blacklist_blacklistedtokens = await token_blacklist_blacklistedtoken.prisma().find_many(take=10)

        # find the first 5 token_blacklist_blacklistedtoken records ordered by the token_id field
        token_blacklist_blacklistedtokens = await token_blacklist_blacklistedtoken.prisma().find_many(
            take=5,
            order={
                'token_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_blacklistedtokenOrderByInput, List[types.token_blacklist_blacklistedtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_blacklistedtokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single token_blacklist_blacklistedtoken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            token_blacklist_blacklistedtoken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model
        order
            Order the returned token_blacklist_blacklistedtoken records by any field
        distinct
            Filter token_blacklist_blacklistedtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The first token_blacklist_blacklistedtoken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second token_blacklist_blacklistedtoken record ordered by the id field
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_blacklistedtokenOrderByInput, List[types.token_blacklist_blacklistedtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_blacklistedtokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single token_blacklist_blacklistedtoken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            token_blacklist_blacklistedtoken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model
        order
            Order the returned token_blacklist_blacklistedtoken records by any field
        distinct
            Filter token_blacklist_blacklistedtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The first token_blacklist_blacklistedtoken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second token_blacklist_blacklistedtoken record ordered by the blacklisted_at field
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().find_first_or_raise(
            skip=1,
            order={
                'blacklisted_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.token_blacklist_blacklistedtokenUpdateInput,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single token_blacklist_blacklistedtoken record.

        Parameters
        ----------
        data
            token_blacklist_blacklistedtoken record data specifying what to update
        where
            token_blacklist_blacklistedtoken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The updated token_blacklist_blacklistedtoken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().update(
            where={
                'id': 18166180500,
            },
            data={
                # data to update the token_blacklist_blacklistedtoken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.token_blacklist_blacklistedtokenWhereUniqueInput,
        data: types.token_blacklist_blacklistedtokenUpsertInput,
        include: Optional[types.token_blacklist_blacklistedtokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            token_blacklist_blacklistedtoken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned token_blacklist_blacklistedtoken model

        Returns
        -------
        prisma.models.token_blacklist_blacklistedtoken
            The created or updated token_blacklist_blacklistedtoken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_blacklistedtoken = await token_blacklist_blacklistedtoken.prisma().upsert(
            where={
                'id': 6709590960,
            },
            data={
                'create': {
                    'id': 6709590960,
                    'blacklisted_at': datetime.datetime.utcnow(),
                    'token_id': 139810884,
                },
                'update': {
                    'blacklisted_at': datetime.datetime.utcnow(),
                    'token_id': 139810884,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.token_blacklist_blacklistedtokenUpdateManyMutationInput,
        where: types.token_blacklist_blacklistedtokenWhereInput,
    ) -> int:
        """Update multiple token_blacklist_blacklistedtoken records

        Parameters
        ----------
        data
            token_blacklist_blacklistedtoken data to update the selected token_blacklist_blacklistedtoken records to
        where
            Filter to select the token_blacklist_blacklistedtoken records to update

        Returns
        -------
        int
            The total number of token_blacklist_blacklistedtoken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all token_blacklist_blacklistedtoken records
        total = await token_blacklist_blacklistedtoken.prisma().update_many(
            data={
                'token_id': 9058077852
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of token_blacklist_blacklistedtoken records present in the database

        Parameters
        ----------
        select
            Select the token_blacklist_blacklistedtoken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            token_blacklist_blacklistedtoken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.token_blacklist_blacklistedtokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await token_blacklist_blacklistedtoken.prisma().count()

        # results: prisma.types.token_blacklist_blacklistedtokenCountAggregateOutput
        results = await token_blacklist_blacklistedtoken.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.token_blacklist_blacklistedtokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
    ) -> types.token_blacklist_blacklistedtokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.token_blacklist_blacklistedtokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_blacklistedtokenWhereUniqueInput] = None,
    ) -> Union[int, types.token_blacklist_blacklistedtokenCountAggregateOutput]:
        """Count the number of token_blacklist_blacklistedtoken records present in the database

        Parameters
        ----------
        select
            Select the token_blacklist_blacklistedtoken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            token_blacklist_blacklistedtoken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.token_blacklist_blacklistedtokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await token_blacklist_blacklistedtoken.prisma().count()

        # results: prisma.types.token_blacklist_blacklistedtokenCountAggregateOutput
        results = await token_blacklist_blacklistedtoken.prisma().count(
            select={
                '_all': True,
                'blacklisted_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.token_blacklist_blacklistedtokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.token_blacklist_blacklistedtokenWhereInput] = None
    ) -> int:
        """Delete multiple token_blacklist_blacklistedtoken records.

        Parameters
        ----------
        where
            Optional token_blacklist_blacklistedtoken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of token_blacklist_blacklistedtoken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all token_blacklist_blacklistedtoken records
        total = await token_blacklist_blacklistedtoken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.token_blacklist_blacklistedtokenScalarFieldKeys'],
        *,
        where: Optional['types.token_blacklist_blacklistedtokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.token_blacklist_blacklistedtokenAvgAggregateInput'] = None,
        sum: Optional['types.token_blacklist_blacklistedtokenSumAggregateInput'] = None,
        min: Optional['types.token_blacklist_blacklistedtokenMinAggregateInput'] = None,
        max: Optional['types.token_blacklist_blacklistedtokenMaxAggregateInput'] = None,
        having: Optional['types.token_blacklist_blacklistedtokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.token_blacklist_blacklistedtokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.token_blacklist_blacklistedtokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.token_blacklist_blacklistedtokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.token_blacklist_blacklistedtokenGroupByOutput']:
        """Group token_blacklist_blacklistedtoken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar token_blacklist_blacklistedtoken fields to group records by
        where
            token_blacklist_blacklistedtoken filter to select records
        take
            Limit the maximum number of token_blacklist_blacklistedtoken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.token_blacklist_blacklistedtokenGroupByOutput]
            A list of dictionaries representing the token_blacklist_blacklistedtoken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group token_blacklist_blacklistedtoken records by token_id values
        # and count how many records are in each group
        results = await token_blacklist_blacklistedtoken.prisma().group_by(
            ['token_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class token_blacklist_outstandingtokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.token_blacklist_outstandingtoken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await token_blacklist_outstandingtoken.prisma().query_raw(
            'SELECT * FROM token_blacklist_outstandingtoken WHERE id = $1',
            13815867672,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await token_blacklist_outstandingtoken.prisma().query_first(
            'SELECT * FROM token_blacklist_outstandingtoken WHERE token = $1',
            'biggefaged',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.token_blacklist_outstandingtokenCreateInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new token_blacklist_outstandingtoken record.

        Parameters
        ----------
        data
            token_blacklist_outstandingtoken record data
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The created token_blacklist_outstandingtoken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a token_blacklist_outstandingtoken record from just the required fields
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().create(
            data={
                # data to create a token_blacklist_outstandingtoken record
                'token': 'gfdbeaejg',
                'expires_at': datetime.datetime.utcnow(),
                'jti': 'bhacdebcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.token_blacklist_outstandingtokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple token_blacklist_outstandingtoken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of token_blacklist_outstandingtoken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await token_blacklist_outstandingtoken.prisma().create_many(
            data=[
                {
                    # data to create a token_blacklist_outstandingtoken record
                    'token': 'jhffeibhe',
                    'expires_at': datetime.datetime.utcnow(),
                    'jti': 'iaiieefjb',
                },
                {
                    # data to create a token_blacklist_outstandingtoken record
                    'token': 'jjhjdgjfg',
                    'expires_at': datetime.datetime.utcnow(),
                    'jti': 'bhhjcfadhd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single token_blacklist_outstandingtoken record.

        Parameters
        ----------
        where
            token_blacklist_outstandingtoken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The deleted token_blacklist_outstandingtoken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().delete(
            where={
                'id': 617883960,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique token_blacklist_outstandingtoken record.

        Parameters
        ----------
        where
            token_blacklist_outstandingtoken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The found token_blacklist_outstandingtoken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().find_unique(
            where={
                'id': 23290371972,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique token_blacklist_outstandingtoken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            token_blacklist_outstandingtoken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The found token_blacklist_outstandingtoken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().find_unique_or_raise(
            where={
                'id': 5093041632,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_outstandingtokenOrderByInput, List[types.token_blacklist_outstandingtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_outstandingtokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple token_blacklist_outstandingtoken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of token_blacklist_outstandingtoken records returned
        skip
            Ignore the first N results
        where
            token_blacklist_outstandingtoken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model
        order
            Order the returned token_blacklist_outstandingtoken records by any field
        distinct
            Filter token_blacklist_outstandingtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.token_blacklist_outstandingtoken]
            The list of all token_blacklist_outstandingtoken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 token_blacklist_outstandingtoken records
        token_blacklist_outstandingtokens = await token_blacklist_outstandingtoken.prisma().find_many(take=10)

        # find the first 5 token_blacklist_outstandingtoken records ordered by the created_at field
        token_blacklist_outstandingtokens = await token_blacklist_outstandingtoken.prisma().find_many(
            take=5,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_outstandingtokenOrderByInput, List[types.token_blacklist_outstandingtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_outstandingtokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single token_blacklist_outstandingtoken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            token_blacklist_outstandingtoken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model
        order
            Order the returned token_blacklist_outstandingtoken records by any field
        distinct
            Filter token_blacklist_outstandingtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The first token_blacklist_outstandingtoken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second token_blacklist_outstandingtoken record ordered by the expires_at field
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().find_first(
            skip=1,
            order={
                'expires_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None,
        order: Optional[Union[types.token_blacklist_outstandingtokenOrderByInput, List[types.token_blacklist_outstandingtokenOrderByInput]]] = None,
        distinct: Optional[List[types.token_blacklist_outstandingtokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single token_blacklist_outstandingtoken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            token_blacklist_outstandingtoken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model
        order
            Order the returned token_blacklist_outstandingtoken records by any field
        distinct
            Filter token_blacklist_outstandingtoken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The first token_blacklist_outstandingtoken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second token_blacklist_outstandingtoken record ordered by the user_id field
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.token_blacklist_outstandingtokenUpdateInput,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single token_blacklist_outstandingtoken record.

        Parameters
        ----------
        data
            token_blacklist_outstandingtoken record data specifying what to update
        where
            token_blacklist_outstandingtoken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The updated token_blacklist_outstandingtoken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().update(
            where={
                'id': 16321094412,
            },
            data={
                # data to update the token_blacklist_outstandingtoken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.token_blacklist_outstandingtokenWhereUniqueInput,
        data: types.token_blacklist_outstandingtokenUpsertInput,
        include: Optional[types.token_blacklist_outstandingtokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            token_blacklist_outstandingtoken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned token_blacklist_outstandingtoken model

        Returns
        -------
        prisma.models.token_blacklist_outstandingtoken
            The created or updated token_blacklist_outstandingtoken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        token_blacklist_outstandingtoken = await token_blacklist_outstandingtoken.prisma().upsert(
            where={
                'id': 3331774152,
            },
            data={
                'create': {
                    'id': 3331774152,
                    'token': 'jjhjdgjfg',
                    'expires_at': datetime.datetime.utcnow(),
                    'jti': 'bhhjcfadhd',
                },
                'update': {
                    'token': 'jjhjdgjfg',
                    'expires_at': datetime.datetime.utcnow(),
                    'jti': 'bhhjcfadhd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.token_blacklist_outstandingtokenUpdateManyMutationInput,
        where: types.token_blacklist_outstandingtokenWhereInput,
    ) -> int:
        """Update multiple token_blacklist_outstandingtoken records

        Parameters
        ----------
        data
            token_blacklist_outstandingtoken data to update the selected token_blacklist_outstandingtoken records to
        where
            Filter to select the token_blacklist_outstandingtoken records to update

        Returns
        -------
        int
            The total number of token_blacklist_outstandingtoken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all token_blacklist_outstandingtoken records
        total = await token_blacklist_outstandingtoken.prisma().update_many(
            data={
                'jti': 'faggbiggd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of token_blacklist_outstandingtoken records present in the database

        Parameters
        ----------
        select
            Select the token_blacklist_outstandingtoken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            token_blacklist_outstandingtoken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.token_blacklist_outstandingtokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await token_blacklist_outstandingtoken.prisma().count()

        # results: prisma.types.token_blacklist_outstandingtokenCountAggregateOutput
        results = await token_blacklist_outstandingtoken.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.token_blacklist_outstandingtokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
    ) -> types.token_blacklist_outstandingtokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.token_blacklist_outstandingtokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None,
        cursor: Optional[types.token_blacklist_outstandingtokenWhereUniqueInput] = None,
    ) -> Union[int, types.token_blacklist_outstandingtokenCountAggregateOutput]:
        """Count the number of token_blacklist_outstandingtoken records present in the database

        Parameters
        ----------
        select
            Select the token_blacklist_outstandingtoken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            token_blacklist_outstandingtoken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.token_blacklist_outstandingtokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await token_blacklist_outstandingtoken.prisma().count()

        # results: prisma.types.token_blacklist_outstandingtokenCountAggregateOutput
        results = await token_blacklist_outstandingtoken.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.token_blacklist_outstandingtokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.token_blacklist_outstandingtokenWhereInput] = None
    ) -> int:
        """Delete multiple token_blacklist_outstandingtoken records.

        Parameters
        ----------
        where
            Optional token_blacklist_outstandingtoken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of token_blacklist_outstandingtoken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all token_blacklist_outstandingtoken records
        total = await token_blacklist_outstandingtoken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.token_blacklist_outstandingtokenScalarFieldKeys'],
        *,
        where: Optional['types.token_blacklist_outstandingtokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.token_blacklist_outstandingtokenAvgAggregateInput'] = None,
        sum: Optional['types.token_blacklist_outstandingtokenSumAggregateInput'] = None,
        min: Optional['types.token_blacklist_outstandingtokenMinAggregateInput'] = None,
        max: Optional['types.token_blacklist_outstandingtokenMaxAggregateInput'] = None,
        having: Optional['types.token_blacklist_outstandingtokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.token_blacklist_outstandingtokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.token_blacklist_outstandingtokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.token_blacklist_outstandingtokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.token_blacklist_outstandingtokenGroupByOutput']:
        """Group token_blacklist_outstandingtoken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar token_blacklist_outstandingtoken fields to group records by
        where
            token_blacklist_outstandingtoken filter to select records
        take
            Limit the maximum number of token_blacklist_outstandingtoken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.token_blacklist_outstandingtokenGroupByOutput]
            A list of dictionaries representing the token_blacklist_outstandingtoken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group token_blacklist_outstandingtoken records by created_at values
        # and count how many records are in each group
        results = await token_blacklist_outstandingtoken.prisma().group_by(
            ['created_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class users_userActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.users_user]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users_user.prisma().query_raw(
            'SELECT * FROM users_user WHERE id = $1',
            15467771376,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.users_user
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await users_user.prisma().query_first(
            'SELECT * FROM users_user WHERE password = $1',
            'bdjaadchgf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.users_userCreateInput,
        include: Optional[types.users_userInclude] = None
    ) -> _PrismaModelT:
        """Create a new users_user record.

        Parameters
        ----------
        data
            users_user record data
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The created users_user record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a users_user record from just the required fields
        users_user = await users_user.prisma().create(
            data={
                # data to create a users_user record
                'password': 'biadfeebhi',
                'is_superuser': False,
                'username': 'ddgjjicai',
                'first_name': 'efihdjdcb',
                'last_name': 'bdeacajaig',
                'is_staff': False,
                'is_active': True,
                'date_joined': datetime.datetime.utcnow(),
                'email': 'bjchjgjib',
                'is_premium': True,
                'hide_ads': False,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.users_userCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple users_user records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of users_user record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await users_user.prisma().create_many(
            data=[
                {
                    # data to create a users_user record
                    'password': 'bajgjiebfc',
                    'is_superuser': False,
                    'username': 'bijhaihbcg',
                    'first_name': 'cbgcjeecd',
                    'last_name': 'bebibighfg',
                    'is_staff': False,
                    'is_active': True,
                    'date_joined': datetime.datetime.utcnow(),
                    'email': 'jgijgagjb',
                    'is_premium': True,
                    'hide_ads': False,
                },
                {
                    # data to create a users_user record
                    'password': 'ichjgigcc',
                    'is_superuser': False,
                    'username': 'bdegidheae',
                    'first_name': 'bddbbjidhd',
                    'last_name': 'jefedjaji',
                    'is_staff': False,
                    'is_active': True,
                    'date_joined': datetime.datetime.utcnow(),
                    'email': 'bagfajdjcb',
                    'is_premium': True,
                    'hide_ads': False,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.users_userWhereUniqueInput,
        include: Optional[types.users_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single users_user record.

        Parameters
        ----------
        where
            users_user filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The deleted users_user record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user = await users_user.prisma().delete(
            where={
                'id': 3423541872,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.users_userWhereUniqueInput,
        include: Optional[types.users_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique users_user record.

        Parameters
        ----------
        where
            users_user filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The found users_user record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user = await users_user.prisma().find_unique(
            where={
                'id': 1595843676,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.users_userWhereUniqueInput,
        include: Optional[types.users_userInclude] = None
    ) -> _PrismaModelT:
        """Find a unique users_user record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            users_user filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The found users_user record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user = await users_user.prisma().find_unique_or_raise(
            where={
                'id': 18543691224,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
        include: Optional[types.users_userInclude] = None,
        order: Optional[Union[types.users_userOrderByInput, List[types.users_userOrderByInput]]] = None,
        distinct: Optional[List[types.users_userScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple users_user records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of users_user records returned
        skip
            Ignore the first N results
        where
            users_user filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user model
        order
            Order the returned users_user records by any field
        distinct
            Filter users_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.users_user]
            The list of all users_user records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 users_user records
        users_users = await users_user.prisma().find_many(take=10)

        # find the first 5 users_user records ordered by the last_login field
        users_users = await users_user.prisma().find_many(
            take=5,
            order={
                'last_login': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
        include: Optional[types.users_userInclude] = None,
        order: Optional[Union[types.users_userOrderByInput, List[types.users_userOrderByInput]]] = None,
        distinct: Optional[List[types.users_userScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single users_user record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user model
        order
            Order the returned users_user records by any field
        distinct
            Filter users_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user
            The first users_user record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user record ordered by the is_superuser field
        users_user = await users_user.prisma().find_first(
            skip=1,
            order={
                'is_superuser': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
        include: Optional[types.users_userInclude] = None,
        order: Optional[Union[types.users_userOrderByInput, List[types.users_userOrderByInput]]] = None,
        distinct: Optional[List[types.users_userScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single users_user record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user model
        order
            Order the returned users_user records by any field
        distinct
            Filter users_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user
            The first users_user record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user record ordered by the username field
        users_user = await users_user.prisma().find_first_or_raise(
            skip=1,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.users_userUpdateInput,
        where: types.users_userWhereUniqueInput,
        include: Optional[types.users_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single users_user record.

        Parameters
        ----------
        data
            users_user record data specifying what to update
        where
            users_user filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The updated users_user record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users_user = await users_user.prisma().update(
            where={
                'id': 21927415716,
            },
            data={
                # data to update the users_user record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.users_userWhereUniqueInput,
        data: types.users_userUpsertInput,
        include: Optional[types.users_userInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            users_user filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned users_user model

        Returns
        -------
        prisma.models.users_user
            The created or updated users_user record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user = await users_user.prisma().upsert(
            where={
                'id': 25073263488,
            },
            data={
                'create': {
                    'id': 25073263488,
                    'password': 'ichjgigcc',
                    'is_superuser': False,
                    'username': 'bdegidheae',
                    'first_name': 'bddbbjidhd',
                    'last_name': 'jefedjaji',
                    'is_staff': False,
                    'is_active': True,
                    'date_joined': datetime.datetime.utcnow(),
                    'email': 'bagfajdjcb',
                    'is_premium': True,
                    'hide_ads': False,
                },
                'update': {
                    'password': 'ichjgigcc',
                    'is_superuser': False,
                    'username': 'bdegidheae',
                    'first_name': 'bddbbjidhd',
                    'last_name': 'jefedjaji',
                    'is_staff': False,
                    'is_active': True,
                    'date_joined': datetime.datetime.utcnow(),
                    'email': 'bagfajdjcb',
                    'is_premium': True,
                    'hide_ads': False,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.users_userUpdateManyMutationInput,
        where: types.users_userWhereInput,
    ) -> int:
        """Update multiple users_user records

        Parameters
        ----------
        data
            users_user data to update the selected users_user records to
        where
            Filter to select the users_user records to update

        Returns
        -------
        int
            The total number of users_user records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all users_user records
        total = await users_user.prisma().update_many(
            data={
                'first_name': 'bebebdfbcj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
    ) -> int:
        """Count the number of users_user records present in the database

        Parameters
        ----------
        select
            Select the users_user fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_userCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user.prisma().count()

        # results: prisma.types.users_userCountAggregateOutput
        results = await users_user.prisma().count(
            select={
                '_all': True,
                'last_name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.users_userCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
    ) -> types.users_userCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.users_userCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_userWhereInput] = None,
        cursor: Optional[types.users_userWhereUniqueInput] = None,
    ) -> Union[int, types.users_userCountAggregateOutput]:
        """Count the number of users_user records present in the database

        Parameters
        ----------
        select
            Select the users_user fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_userCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user.prisma().count()

        # results: prisma.types.users_userCountAggregateOutput
        results = await users_user.prisma().count(
            select={
                '_all': True,
                'is_staff': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.users_userCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.users_userWhereInput] = None
    ) -> int:
        """Delete multiple users_user records.

        Parameters
        ----------
        where
            Optional users_user filter to find the records to be deleted

        Returns
        -------
        int
            The total number of users_user records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all users_user records
        total = await users_user.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.users_userScalarFieldKeys'],
        *,
        where: Optional['types.users_userWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.users_userAvgAggregateInput'] = None,
        sum: Optional['types.users_userSumAggregateInput'] = None,
        min: Optional['types.users_userMinAggregateInput'] = None,
        max: Optional['types.users_userMaxAggregateInput'] = None,
        having: Optional['types.users_userScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.users_userCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.users_userScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.users_userScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.users_userGroupByOutput']:
        """Group users_user records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar users_user fields to group records by
        where
            users_user filter to select records
        take
            Limit the maximum number of users_user records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.users_userGroupByOutput]
            A list of dictionaries representing the users_user record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group users_user records by is_active values
        # and count how many records are in each group
        results = await users_user.prisma().group_by(
            ['is_active'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class users_user_groupsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.users_user_groups]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users_user_groups.prisma().query_raw(
            'SELECT * FROM users_user_groups WHERE id = $1',
            24668937576,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.users_user_groups
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await users_user_groups.prisma().query_first(
            'SELECT * FROM users_user_groups WHERE user_id = $1',
            9045964788,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.users_user_groupsCreateInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> _PrismaModelT:
        """Create a new users_user_groups record.

        Parameters
        ----------
        data
            users_user_groups record data
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The created users_user_groups record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a users_user_groups record from just the required fields
        users_user_groups = await users_user_groups.prisma().create(
            data={
                # data to create a users_user_groups record
                'user_id': 14865640848,
                'group_id': 1377048085,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.users_user_groupsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple users_user_groups records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of users_user_groups record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await users_user_groups.prisma().create_many(
            data=[
                {
                    # data to create a users_user_groups record
                    'user_id': 24667217400,
                    'group_id': 1990969115,
                },
                {
                    # data to create a users_user_groups record
                    'user_id': 11211524256,
                    'group_id': 1261239953,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.users_user_groupsWhereUniqueInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single users_user_groups record.

        Parameters
        ----------
        where
            users_user_groups filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The deleted users_user_groups record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_groups = await users_user_groups.prisma().delete(
            where={
                'id': 21918455688,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.users_user_groupsWhereUniqueInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique users_user_groups record.

        Parameters
        ----------
        where
            users_user_groups filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The found users_user_groups record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_groups = await users_user_groups.prisma().find_unique(
            where={
                'id': 10511234964,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.users_user_groupsWhereUniqueInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique users_user_groups record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            users_user_groups filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The found users_user_groups record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_groups = await users_user_groups.prisma().find_unique_or_raise(
            where={
                'id': 7565182128,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
        include: Optional[types.users_user_groupsInclude] = None,
        order: Optional[Union[types.users_user_groupsOrderByInput, List[types.users_user_groupsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_groupsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple users_user_groups records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of users_user_groups records returned
        skip
            Ignore the first N results
        where
            users_user_groups filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_groups model
        order
            Order the returned users_user_groups records by any field
        distinct
            Filter users_user_groups records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.users_user_groups]
            The list of all users_user_groups records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 users_user_groups records
        users_user_groups = await users_user_groups.prisma().find_many(take=10)

        # find the first 5 users_user_groups records ordered by the group_id field
        users_user_groups = await users_user_groups.prisma().find_many(
            take=5,
            order={
                'group_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
        include: Optional[types.users_user_groupsInclude] = None,
        order: Optional[Union[types.users_user_groupsOrderByInput, List[types.users_user_groupsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_groupsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single users_user_groups record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user_groups filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_groups model
        order
            Order the returned users_user_groups records by any field
        distinct
            Filter users_user_groups records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user_groups
            The first users_user_groups record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user_groups record ordered by the id field
        users_user_groups = await users_user_groups.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
        include: Optional[types.users_user_groupsInclude] = None,
        order: Optional[Union[types.users_user_groupsOrderByInput, List[types.users_user_groupsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_groupsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single users_user_groups record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user_groups filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_groups model
        order
            Order the returned users_user_groups records by any field
        distinct
            Filter users_user_groups records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user_groups
            The first users_user_groups record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user_groups record ordered by the user_id field
        users_user_groups = await users_user_groups.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.users_user_groupsUpdateInput,
        where: types.users_user_groupsWhereUniqueInput,
        include: Optional[types.users_user_groupsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single users_user_groups record.

        Parameters
        ----------
        data
            users_user_groups record data specifying what to update
        where
            users_user_groups filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The updated users_user_groups record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users_user_groups = await users_user_groups.prisma().update(
            where={
                'id': 21757387164,
            },
            data={
                # data to update the users_user_groups record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.users_user_groupsWhereUniqueInput,
        data: types.users_user_groupsUpsertInput,
        include: Optional[types.users_user_groupsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            users_user_groups filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned users_user_groups model

        Returns
        -------
        prisma.models.users_user_groups
            The created or updated users_user_groups record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_groups = await users_user_groups.prisma().upsert(
            where={
                'id': 16745519640,
            },
            data={
                'create': {
                    'id': 16745519640,
                    'user_id': 11211524256,
                    'group_id': 1261239953,
                },
                'update': {
                    'user_id': 11211524256,
                    'group_id': 1261239953,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.users_user_groupsUpdateManyMutationInput,
        where: types.users_user_groupsWhereInput,
    ) -> int:
        """Update multiple users_user_groups records

        Parameters
        ----------
        data
            users_user_groups data to update the selected users_user_groups records to
        where
            Filter to select the users_user_groups records to update

        Returns
        -------
        int
            The total number of users_user_groups records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all users_user_groups records
        total = await users_user_groups.prisma().update_many(
            data={
                'group_id': 1929510547
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of users_user_groups records present in the database

        Parameters
        ----------
        select
            Select the users_user_groups fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user_groups filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_user_groupsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user_groups.prisma().count()

        # results: prisma.types.users_user_groupsCountAggregateOutput
        results = await users_user_groups.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.users_user_groupsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
    ) -> types.users_user_groupsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.users_user_groupsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_groupsWhereInput] = None,
        cursor: Optional[types.users_user_groupsWhereUniqueInput] = None,
    ) -> Union[int, types.users_user_groupsCountAggregateOutput]:
        """Count the number of users_user_groups records present in the database

        Parameters
        ----------
        select
            Select the users_user_groups fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user_groups filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_user_groupsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user_groups.prisma().count()

        # results: prisma.types.users_user_groupsCountAggregateOutput
        results = await users_user_groups.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.users_user_groupsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.users_user_groupsWhereInput] = None
    ) -> int:
        """Delete multiple users_user_groups records.

        Parameters
        ----------
        where
            Optional users_user_groups filter to find the records to be deleted

        Returns
        -------
        int
            The total number of users_user_groups records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all users_user_groups records
        total = await users_user_groups.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.users_user_groupsScalarFieldKeys'],
        *,
        where: Optional['types.users_user_groupsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.users_user_groupsAvgAggregateInput'] = None,
        sum: Optional['types.users_user_groupsSumAggregateInput'] = None,
        min: Optional['types.users_user_groupsMinAggregateInput'] = None,
        max: Optional['types.users_user_groupsMaxAggregateInput'] = None,
        having: Optional['types.users_user_groupsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.users_user_groupsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.users_user_groupsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.users_user_groupsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.users_user_groupsGroupByOutput']:
        """Group users_user_groups records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar users_user_groups fields to group records by
        where
            users_user_groups filter to select records
        take
            Limit the maximum number of users_user_groups records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.users_user_groupsGroupByOutput]
            A list of dictionaries representing the users_user_groups record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group users_user_groups records by group_id values
        # and count how many records are in each group
        results = await users_user_groups.prisma().group_by(
            ['group_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class users_user_user_permissionsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.users_user_user_permissions]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users_user_user_permissions.prisma().query_raw(
            'SELECT * FROM users_user_user_permissions WHERE id = $1',
            15323132352,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.users_user_user_permissions
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await users_user_user_permissions.prisma().query_first(
            'SELECT * FROM users_user_user_permissions WHERE user_id = $1',
            10034819436,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.users_user_user_permissionsCreateInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> _PrismaModelT:
        """Create a new users_user_user_permissions record.

        Parameters
        ----------
        data
            users_user_user_permissions record data
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The created users_user_user_permissions record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a users_user_user_permissions record from just the required fields
        users_user_user_permissions = await users_user_user_permissions.prisma().create(
            data={
                # data to create a users_user_user_permissions record
                'user_id': 12111132072,
                'permission_id': 407105775,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.users_user_user_permissionsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple users_user_user_permissions records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of users_user_user_permissions record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await users_user_user_permissions.prisma().create_many(
            data=[
                {
                    # data to create a users_user_user_permissions record
                    'user_id': 3259441104,
                    'permission_id': 1005039237,
                },
                {
                    # data to create a users_user_user_permissions record
                    'user_id': 17855167032,
                    'permission_id': 2131275019,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.users_user_user_permissionsWhereUniqueInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single users_user_user_permissions record.

        Parameters
        ----------
        where
            users_user_user_permissions filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The deleted users_user_user_permissions record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_user_permissions = await users_user_user_permissions.prisma().delete(
            where={
                'id': 18708602592,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.users_user_user_permissionsWhereUniqueInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique users_user_user_permissions record.

        Parameters
        ----------
        where
            users_user_user_permissions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The found users_user_user_permissions record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_user_permissions = await users_user_user_permissions.prisma().find_unique(
            where={
                'id': 25261516812,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.users_user_user_permissionsWhereUniqueInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique users_user_user_permissions record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            users_user_user_permissions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The found users_user_user_permissions record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_user_permissions = await users_user_user_permissions.prisma().find_unique_or_raise(
            where={
                'id': 17233541064,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
        include: Optional[types.users_user_user_permissionsInclude] = None,
        order: Optional[Union[types.users_user_user_permissionsOrderByInput, List[types.users_user_user_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_user_permissionsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple users_user_user_permissions records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of users_user_user_permissions records returned
        skip
            Ignore the first N results
        where
            users_user_user_permissions filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model
        order
            Order the returned users_user_user_permissions records by any field
        distinct
            Filter users_user_user_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.users_user_user_permissions]
            The list of all users_user_user_permissions records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 users_user_user_permissions records
        users_user_user_permissions = await users_user_user_permissions.prisma().find_many(take=10)

        # find the first 5 users_user_user_permissions records ordered by the permission_id field
        users_user_user_permissions = await users_user_user_permissions.prisma().find_many(
            take=5,
            order={
                'permission_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
        include: Optional[types.users_user_user_permissionsInclude] = None,
        order: Optional[Union[types.users_user_user_permissionsOrderByInput, List[types.users_user_user_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_user_permissionsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single users_user_user_permissions record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user_user_permissions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model
        order
            Order the returned users_user_user_permissions records by any field
        distinct
            Filter users_user_user_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user_user_permissions
            The first users_user_user_permissions record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user_user_permissions record ordered by the id field
        users_user_user_permissions = await users_user_user_permissions.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
        include: Optional[types.users_user_user_permissionsInclude] = None,
        order: Optional[Union[types.users_user_user_permissionsOrderByInput, List[types.users_user_user_permissionsOrderByInput]]] = None,
        distinct: Optional[List[types.users_user_user_permissionsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single users_user_user_permissions record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users_user_user_permissions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model
        order
            Order the returned users_user_user_permissions records by any field
        distinct
            Filter users_user_user_permissions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users_user_user_permissions
            The first users_user_user_permissions record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users_user_user_permissions record ordered by the user_id field
        users_user_user_permissions = await users_user_user_permissions.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.users_user_user_permissionsUpdateInput,
        where: types.users_user_user_permissionsWhereUniqueInput,
        include: Optional[types.users_user_user_permissionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single users_user_user_permissions record.

        Parameters
        ----------
        data
            users_user_user_permissions record data specifying what to update
        where
            users_user_user_permissions filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The updated users_user_user_permissions record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users_user_user_permissions = await users_user_user_permissions.prisma().update(
            where={
                'id': 18537034452,
            },
            data={
                # data to update the users_user_user_permissions record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.users_user_user_permissionsWhereUniqueInput,
        data: types.users_user_user_permissionsUpsertInput,
        include: Optional[types.users_user_user_permissionsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            users_user_user_permissions filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned users_user_user_permissions model

        Returns
        -------
        prisma.models.users_user_user_permissions
            The created or updated users_user_user_permissions record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users_user_user_permissions = await users_user_user_permissions.prisma().upsert(
            where={
                'id': 9728098032,
            },
            data={
                'create': {
                    'id': 9728098032,
                    'user_id': 17855167032,
                    'permission_id': 2131275019,
                },
                'update': {
                    'user_id': 17855167032,
                    'permission_id': 2131275019,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.users_user_user_permissionsUpdateManyMutationInput,
        where: types.users_user_user_permissionsWhereInput,
    ) -> int:
        """Update multiple users_user_user_permissions records

        Parameters
        ----------
        data
            users_user_user_permissions data to update the selected users_user_user_permissions records to
        where
            Filter to select the users_user_user_permissions records to update

        Returns
        -------
        int
            The total number of users_user_user_permissions records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all users_user_user_permissions records
        total = await users_user_user_permissions.prisma().update_many(
            data={
                'permission_id': 181545277
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of users_user_user_permissions records present in the database

        Parameters
        ----------
        select
            Select the users_user_user_permissions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user_user_permissions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_user_user_permissionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user_user_permissions.prisma().count()

        # results: prisma.types.users_user_user_permissionsCountAggregateOutput
        results = await users_user_user_permissions.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.users_user_user_permissionsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
    ) -> types.users_user_user_permissionsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.users_user_user_permissionsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.users_user_user_permissionsWhereInput] = None,
        cursor: Optional[types.users_user_user_permissionsWhereUniqueInput] = None,
    ) -> Union[int, types.users_user_user_permissionsCountAggregateOutput]:
        """Count the number of users_user_user_permissions records present in the database

        Parameters
        ----------
        select
            Select the users_user_user_permissions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users_user_user_permissions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.users_user_user_permissionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users_user_user_permissions.prisma().count()

        # results: prisma.types.users_user_user_permissionsCountAggregateOutput
        results = await users_user_user_permissions.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.users_user_user_permissionsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.users_user_user_permissionsWhereInput] = None
    ) -> int:
        """Delete multiple users_user_user_permissions records.

        Parameters
        ----------
        where
            Optional users_user_user_permissions filter to find the records to be deleted

        Returns
        -------
        int
            The total number of users_user_user_permissions records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all users_user_user_permissions records
        total = await users_user_user_permissions.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.users_user_user_permissionsScalarFieldKeys'],
        *,
        where: Optional['types.users_user_user_permissionsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.users_user_user_permissionsAvgAggregateInput'] = None,
        sum: Optional['types.users_user_user_permissionsSumAggregateInput'] = None,
        min: Optional['types.users_user_user_permissionsMinAggregateInput'] = None,
        max: Optional['types.users_user_user_permissionsMaxAggregateInput'] = None,
        having: Optional['types.users_user_user_permissionsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.users_user_user_permissionsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.users_user_user_permissionsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.users_user_user_permissionsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.users_user_user_permissionsGroupByOutput']:
        """Group users_user_user_permissions records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar users_user_user_permissions fields to group records by
        where
            users_user_user_permissions filter to select records
        take
            Limit the maximum number of users_user_user_permissions records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.users_user_user_permissionsGroupByOutput]
            A list of dictionaries representing the users_user_user_permissions record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group users_user_user_permissions records by permission_id values
        # and count how many records are in each group
        results = await users_user_user_permissions.prisma().group_by(
            ['permission_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models